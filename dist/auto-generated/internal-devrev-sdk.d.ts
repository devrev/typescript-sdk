export declare enum AccessLevel {
    External = "external",
    Internal = "internal",
    Private = "private",
    Public = "public",
    Restricted = "restricted"
}
/** account */
export type Account = OrgBase & {
    /** Custom fields. */
    custom_fields?: object;
    /** Custom schema fragments. */
    custom_schema_fragments?: string[];
    /** Custom schema fragments. */
    custom_schema_fragments_v1?: string;
    /** Description of the corresponding Account. */
    description?: string;
    /** Company's domain names. Example - 'devrev.ai'. */
    domains?: string[];
    /** List of Dev user IDs owning this Account. */
    owned_by: UserSummary[];
    /**
     * Combination of stock and custom schema fragment IDs.
     * @deprecated
     */
    schema_fragment_ids?: string[];
    /** Combination of stock and custom schema fragment IDs. */
    schema_fragment_ids_v1?: string;
    /** Stock schema fragment. */
    stock_schema_fragment?: string;
    /** Stock schema fragment. */
    stock_schema_fragment_v1?: string;
    /** Subtype corresponding to the custom type fragment. */
    subtype?: string;
    /** Tags associated with an object. */
    tags?: TagWithValue[];
};
/** account-search-summary */
export type AccountSearchSummary = SearchSummaryBase & {
    account: AccountSummary;
};
/** account-summary */
export type AccountSummary = OrgBaseSummary;
/** accounts-count-request */
export interface AccountsCountRequest {
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /** Array of domain for Accounts to be filtered. */
    domains?: string[];
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
}
/** accounts-count-response */
export interface AccountsCountResponse {
    /**
     * Count of accounts matching the filter.
     * @format int32
     */
    count: number;
}
/**
 * accounts-create-request
 * Request object to create a new Account in the Dev organization.
 */
export interface AccountsCreateRequest {
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** Description of the Account. */
    description?: string;
    /** Name of the Account. */
    display_name: string;
    /** Company's domain names. Example - 'devrev.ai'. */
    domains?: string[];
    /** List of Dev users owning this Account. */
    owned_by?: string[];
    /** Schema fragment IDs associated with this Account SOR. */
    schema_fragment_ids?: string[];
    /** Tags associated with the Account. */
    tags?: SetTagWithValue[];
}
/**
 * accounts-create-response
 * Response object for request to create a new Account.
 */
export interface AccountsCreateResponse {
    account: Account;
}
/**
 * accounts-delete-request
 * Request object to delete a Account.
 */
export interface AccountsDeleteRequest {
    /** The ID of Account to delete. */
    id: string;
}
/**
 * accounts-delete-response
 * The response to deleting a Account.
 */
export type AccountsDeleteResponse = object;
/**
 * accounts-get-request
 * Request object to get Account's information.
 */
export interface AccountsGetRequest {
    /** The ID of the required Account. */
    id: string;
}
/**
 * accounts-get-response
 * The response to getting a Account's information.
 */
export interface AccountsGetResponse {
    account: Account;
}
/**
 * accounts-group
 * Group object for accounts group request.
 */
export interface AccountsGroup {
    /** The group of accounts. */
    accounts: Account[];
    /** Unique key according to which the items are grouped. */
    key: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * accounts-group-request
 * A request to get group list of Groups.
 */
export interface AccountsGroupRequest {
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /** Array of domain for Accounts to be filtered. */
    domains?: string[];
    /** The field to group the accounts by. */
    group_by: string;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of accounts to return for an individual group.
     * If not set, then the default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /** Fields to sort the accounts by. */
    sort_by?: string[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
}
/**
 * accounts-group-response
 * Response object for accounts group request.
 */
export interface AccountsGroupResponse {
    /** The list of groups. */
    groups: AccountsGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * accounts-list-request
 * A request to get the list of Accounts for the authenticated user's Dev
 * organization.
 */
export interface AccountsListRequest {
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /** Array of domain for Accounts to be filtered. */
    domains?: string[];
    /**
     * The maximum number of Accounts to be retrieved per page.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /** Fields to sort the Accounts by and the direction to sort them. */
    sort_by?: string[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
}
/**
 * accounts-list-response
 * The response to getting a list of Accounts' information.
 */
export interface AccountsListResponse {
    /** List with all of the Accounts' information. */
    accounts: Account[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /**
     * Total number of Accounts matching the input filter.
     * @deprecated
     * @format int32
     */
    total: number;
}
/**
 * accounts-merge-request
 * Request object to merge a Account.
 */
export interface AccountsMergeRequest {
    /** The ID of Account data is to be merged from. */
    from: string;
    /** The ID of Account data is to be merged to. */
    to: string;
}
/**
 * accounts-merge-response
 * The response to merging a Account.
 */
export interface AccountsMergeResponse {
    account: Account;
}
/**
 * accounts-update-request
 * Request object to update information of the Account.
 */
export interface AccountsUpdateRequest {
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** Description of the Account. */
    description?: string;
    /** Customer chosen name for the Account. */
    display_name?: string;
    /** Company's domain names. Example - 'devrev.ai'. */
    domains?: string[];
    /** The ID of Account to update. */
    id: string;
    /**
     * Artifact ID of the account's logo.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    logo_id?: string | null;
    /** List of Users owning this Account. */
    owned_by?: string[];
    /** Schema fragment IDs associated with this Account SOR. */
    schema_fragment_ids?: string[];
    /** Tags associated with the Account. */
    tags?: SetTagWithValue[];
}
/**
 * accounts-update-response
 * Response object to updating Account's information.
 */
export interface AccountsUpdateResponse {
    account: Account;
}
export declare enum ActionTypeValue {
    Create = "create",
    Delete = "delete",
    Read = "read",
    Unknown = "unknown",
    Update = "update"
}
/** addon-rules */
export type AddonRules = AtomBase & {
    addon_sku: SkuSummary;
    /** Type of association between SKU and addon, defaults to optional. */
    associativity?: AddonRulesAssociativity;
    /** Description of the SKU rules. */
    description?: string;
    product: PartSummary;
    subscription_sku: SkuSummary;
};
/** Type of association between SKU and addon, defaults to optional. */
export declare enum AddonRulesAssociativity {
    Mandatory = "mandatory",
    Optional = "optional"
}
/** addon-rules-create-request */
export interface AddonRulesCreateRequest {
    /** Addon SKU for which the rule is defined. */
    addon_id: string;
    /** Type of association between SKU and addon, defaults to optional. */
    associativity?: AddonRulesAssociativity;
    /** Description of the addon rule. */
    description?: string;
    /** Human readable name of the addon rule. */
    name: string;
    /** Subscription SKU for which the rule is defined. */
    subscription_sku_id: string;
}
/** addon-rules-create-response */
export interface AddonRulesCreateResponse {
    addon_rule: AddonRules;
}
/** addon-rules-delete-request */
export interface AddonRulesDeleteRequest {
    /** The addon rule object's DON. */
    id: string;
}
/** addon-rules-get-request */
export interface AddonRulesGetRequest {
    /** The addon rule object's DON. */
    id: string;
}
/** addon-rules-get-response */
export interface AddonRulesGetResponse {
    addon_rule: AddonRules;
}
/** addon-rules-list-request */
export interface AddonRulesListRequest {
    /**
     * The list of addon SKU DONs for which addon rulesare to be
     * aggregated.
     */
    addon_ids?: string[];
    /** The associativity for which the addon rules need to be aggregated */
    associativity?: AddonRulesAssociativity[];
    /** The list of addon rule DONs which are to be aggregated. */
    ids?: string[];
    /**
     * The list of product DONs for which addon rulesare to be aggregated.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    product_ids?: string[];
    /**
     * List of fields to sort the addon rules, by and how to sort them.
     * Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /**
     * The list of subscription SKU DONs for which addon rulesare to be
     * aggregated.
     */
    subscription_sku_ids?: string[];
}
/** addon-rules-list-response */
export interface AddonRulesListResponse {
    /** The list of addon rules. */
    addon_rules: AddonRules[];
}
/** addon-rules-summary */
export type AddonRulesSummary = AtomBaseSummary;
/** addon-rules-update-request */
export interface AddonRulesUpdateRequest {
    /** Type of association between SKU and addon, defaults to optional. */
    associativity?: AddonRulesAssociativity;
    /** Description of the addon rule. */
    description?: string;
    /** The addon rule object's DON. */
    id: string;
    /** Human readable name of the addon rule. */
    name?: string;
}
/** addon-rules-update-response */
export interface AddonRulesUpdateResponse {
    addon_rule: AddonRules;
}
/**
 * address
 * Address details of the customer.
 */
export interface Address {
    /** Address line 1 (e.g., street, PO Box, or company name). */
    address_line_1: string;
    /** Address line 2 (e.g., apartment, suite, unit, or building). */
    address_line_2?: string;
    /** City, district, suburb, town, or village. */
    city: string;
    /** Country. */
    country: string;
    /** ZIP or postal code. */
    postal_code?: string;
    /** State, county, province, or region. */
    state?: string;
}
/** aggregated-schema */
export interface AggregatedSchema {
    /** True if at least one custom schema fragment has a newer version. */
    can_upgrade?: boolean;
    /** List of all custom fields in this schema. */
    custom_fields: FieldDescriptor[];
    /** Description of the schema. */
    description?: string;
    missing_tenant_fragment_id?: AtomSummary;
    /** List of all composite schemas used by stock fields. */
    stock_composite_schemas: CompositeSchema[];
    /** List of stock field enum overrides. */
    stock_field_enum_overrides?: StockFieldEnumOverride[];
    /** List of all stock fields in this schema. */
    stock_fields: FieldDescriptor[];
    /**
     * (Optional) Subtype of the custom type fragment used to populate the
     * same in the leaf type.
     */
    subtype?: string;
    /** Name of the schema. */
    title?: string;
}
/** aggregated-schema-get-request */
export interface AggregatedSchemaGetRequest {
    /** The list of custom schema fragment DONs which are to be aggregated. */
    custom_schema_fragment_ids: string[];
    /** Per object schema, if associated with the leaf type. */
    per_object_schema?: FieldDescriptor[];
    /** The stock schema fragment which is to be aggregated. */
    stock_schema_fragment_id: string;
}
/** aggregated-schema-get-response */
export interface AggregatedSchemaGetResponse {
    schema: AggregatedSchema;
}
/**
 * api-endpoint
 * API endpoint information.
 */
export interface ApiEndpoint {
    /**
     * Operations associated with this API, such as the HTTP Verb,
     * parameters, etc.
     */
    api_operations?: ApiOperation[];
    /** The URL of the API. */
    api_path?: string;
    /** The Host of the API. */
    host?: string;
}
/** api-endpoint-identifier */
export interface ApiEndpointIdentifier {
    /** The host information of the API endpoint. */
    host: string;
    /** The path information of the API endpoint. */
    path: string;
}
/**
 * api-operation
 * API operation summary information.
 */
export interface ApiOperation {
    /** Parameters associated with the API operation. */
    api_parameters?: string[];
    /** The RestAPI path of the discovered API operation. */
    api_path?: string;
    /** Tags associated with the API operation, as defined in the api file. */
    api_tags?: string[];
    /** FulfilledBy IDs per API operation. */
    fulfilled_by?: PartSummary[];
    /** The Http verb of the discovered API operation. */
    http_operation?: ApiOperationHttpOperation;
    /** Repo + file locations where the operation was detected. */
    locations?: RevLocationSummary[];
    /** Name of the API operation. */
    name?: string;
}
/** The Http verb of the discovered API operation. */
export declare enum ApiOperationHttpOperation {
    Connect = "connect",
    Delete = "delete",
    Get = "get",
    Head = "head",
    Options = "options",
    Patch = "patch",
    Post = "post",
    Put = "put",
    Trace = "trace"
}
/** app-fragment */
export type AppFragment = CustomSchemaFragmentBase & {
    /** App this fragment applies to. */
    app?: string;
    /** Name of the app fragment. */
    app_fragment_name?: string;
};
/** app-fragment-summary */
export type AppFragmentSummary = CustomSchemaFragmentBaseSummary;
export declare enum AppRouteValue {
    Customers = "customers",
    Lobby = "lobby",
    MyTasks = "my_tasks",
    Parts = "parts",
    PlugInbox = "plug_inbox",
    Trails = "trails",
    Unknown = "unknown",
    Updates = "updates",
    Vista = "vista"
}
/**
 * archetype-link-summary
 * Link summary.
 */
export interface ArchetypeLinkSummary {
    /** ID of the link. */
    link_id?: string;
    /** ID of the link. */
    link_id_v1?: string;
    /** Type of link used to define the relationship. */
    link_type?: string;
    /** The target object. */
    target?: string;
    /** Target object display ID. */
    target_display_id?: string;
    /** Target object type. */
    target_object_type?: string;
    /** The target object. */
    target_v1?: string;
}
/**
 * archetype-sla-summary
 * SLA summary for the object.
 */
export interface ArchetypeSlaSummary {
    /** The summary of a metric being tracked in an SLA. */
    closest_to_breach?: SlaMetricSummary;
    sla_tracker?: AtomSummary;
}
/** article */
export type Article = AtomBase & {
    access_level?: AccessLevel;
    /** Details of the parts relevant to the article. */
    applies_to_parts: PartSummary[];
    /** Users that authored the article. */
    authored_by?: UserSummary[];
    /** Description of the article. */
    description?: string;
    /** Language of the article for i18n support. */
    language?: string;
    /** The users that own the article. */
    owned_by: UserSummary[];
    /**
     * Timestamp when the article was published.
     * @format date-time
     */
    published_date?: string;
    /** Resource details. */
    resource?: Resource;
    /** Status of the article. */
    status?: ArticleStatus;
    /** Tags associated with the article. */
    tags?: TagWithValue[];
    /** Title of the article. */
    title?: string;
};
/** Status of the article. */
export declare enum ArticleStatus {
    Archived = "archived",
    Draft = "draft",
    Published = "published",
    ReviewNeeded = "review_needed"
}
/** article-summary */
export type ArticleSummary = AtomBaseSummary;
/**
 * articles-bulk-create-request
 * The request to create articles.
 */
export interface ArticlesBulkCreateRequest {
    /** Articles to be created. */
    articles: ArticlesCreateRequest[];
}
/**
 * articles-bulk-create-response
 * Create articles response.
 */
export interface ArticlesBulkCreateResponse {
    /** Returned articles. */
    articles: Article[];
}
/**
 * articles-create-request
 * The request to create an article.
 */
export interface ArticlesCreateRequest {
    access_level?: AccessLevel;
    /**
     * The parts that the article applies to. Specifying at least one part
     * is required when creating articles.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts: string[];
    /**
     * The authors of the article.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    authored_by?: string[];
    /**
     * The authors of the article.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    authored_by_ids?: string[];
    /** Description for the article. */
    description?: string;
    /** Language of the article. */
    language?: string;
    /**
     * The users that own the article.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * The users that own the article.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /**
     * The published date of the article.
     * @format date-time
     */
    published_at?: string;
    resource: ArticlesCreateRequestResource;
    /** Status of the article. */
    status?: ArticleStatus;
    /** Tags associated with the article. */
    tags?: SetTagWithValue[];
    /** Name of the article. */
    title: string;
}
/** articles-create-request-resource */
export interface ArticlesCreateRequestResource {
    /**
     * IDs of the artifacts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifact_ids?: string[];
    /**
     * IDs of the artifacts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifacts?: string[];
    /** URL of the external article. */
    url?: string;
}
/**
 * articles-create-response
 * Create article response.
 */
export interface ArticlesCreateResponse {
    article: Article;
}
/**
 * articles-delete-request
 * The request to delete an article.
 */
export interface ArticlesDeleteRequest {
    /**
     * The ID of the article.
     * @deprecated
     */
    article_id?: string;
    /** The ID of the article. */
    id?: string;
}
/**
 * articles-get-request
 * The request to get an article.
 */
export interface ArticlesGetRequest {
    /** The ID of the required article. */
    article_id: string;
}
/**
 * articles-get-response
 * Get article response.
 */
export interface ArticlesGetResponse {
    article: Article;
}
/**
 * articles-list-request
 * The request to list articles.
 */
export interface ArticlesListRequest {
    /** Filters for access level of the articles. */
    access_level?: AccessLevel[];
    /**
     * Filters for article belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    /**
     * Filters for articles authored by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    authored_by?: string[];
    /**
     * Filters for articles created after the timestamp provided.
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for articles created before the timestamp provided.
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for articles created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of articles to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Filters for articles owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for articles published after the timestamp provided.
     * @format date-time
     */
    published_after_date?: string;
    /**
     * Filters for articles published before the timestamp provided.
     * @format date-time
     */
    published_before_date?: string;
    /** Filters for status of the articles. */
    status?: ArticleStatus[];
    /**
     * Filters for article with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/**
 * articles-list-response
 * List articles response.
 */
export interface ArticlesListResponse {
    /** The article entries matching the request. */
    articles: Article[];
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /**
     * Total number of article items for the request.
     * @format int32
     */
    total: number;
}
/**
 * articles-update-request
 * The request to update an article.
 */
export interface ArticlesUpdateRequest {
    access_level?: AccessLevel;
    applies_to_parts?: ArticlesUpdateRequestAppliesToParts;
    artifacts?: ArticlesUpdateRequestArtifactsIds;
    authored_by?: ArticlesUpdateRequestAuthoredBy;
    /**
     * Updated description of the article object, or unchanged if not
     * provided.
     */
    description?: string;
    /** The article's ID. */
    id: string;
    /** Updates the language of the article. */
    language?: string;
    owned_by?: ArticlesUpdateRequestOwnedBy;
    /**
     * Updates the timestamp for when the article is published.
     * @format date-time
     */
    published_date?: string;
    /** Status of the article. */
    status?: ArticleStatus;
    tags?: ArticlesUpdateRequestTags;
    /** Updated title of the article object, or unchanged if not provided. */
    title?: string;
    /** Updates the URL of the external article. */
    url?: string;
}
/** articles-update-request-applies-to-parts */
export interface ArticlesUpdateRequestAppliesToParts {
    /**
     * Updates the parts that the article applies to.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    set?: string[];
}
/** articles-update-request-artifacts-ids */
export interface ArticlesUpdateRequestArtifactsIds {
    /**
     * Updates IDs of the artifacts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    set?: string[];
}
/** articles-update-request-authored-by */
export interface ArticlesUpdateRequestAuthoredBy {
    /**
     * Sets the users that authored the article.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** articles-update-request-owned-by */
export interface ArticlesUpdateRequestOwnedBy {
    /**
     * Sets the owner IDs to the provided user IDs. This must not be
     * empty.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** articles-update-request-tags */
export interface ArticlesUpdateRequestTags {
    /** Sets the provided tags on the article. */
    set?: SetTagWithValue[];
}
/** articles-update-response */
export interface ArticlesUpdateResponse {
    article: Article;
}
/** artifact */
export type Artifact = AtomBase & {
    /**
     * Timestamp when the artifact was archived.
     * @format date-time
     */
    archived_date?: string;
    /** Represents a set of configuration to be used with the artifacts object. */
    configuration_set?: ArtifactConfigurationSet;
    /** Defines a file object. */
    file?: File;
    /**
     * Information of system generated files like preview, multiple
     * resolutions, etc.
     */
    generated_files?: File[];
    parent_id?: AtomSummary;
    /** Preview URL of the artifact. */
    preview_url?: string;
    /**
     * Timestamp when the artifact was published.
     * @format date-time
     */
    published_date?: string;
};
/** Represents a set of configuration to be used with the artifacts object. */
export declare enum ArtifactConfigurationSet {
    Default = "default",
    OrgLogo = "org_logo",
    SnapInFunctionsCode = "snap_in_functions_code",
    UserProfilePicture = "user_profile_picture",
    Work = "work"
}
/** artifact-search-summary */
export type ArtifactSearchSummary = SearchSummaryBase & {
    artifact: ArtifactSummary;
};
/** artifact-summary */
export type ArtifactSummary = AtomBaseSummary;
/**
 * artifacts-get-request
 * The request to get an artifact's information.
 */
export interface ArtifactsGetRequest {
    /**
     * The requested artifact's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    id: string;
}
/**
 * artifacts-get-response
 * The response to getting an artifact's information.
 */
export interface ArtifactsGetResponse {
    artifact: Artifact;
}
/**
 * artifacts-list-request
 * The request to list artifacts attached to an object.
 */
export interface ArtifactsListRequest {
    /** The ID of the object to filter artifacts. */
    parent_id: string;
}
/**
 * artifacts-list-response
 * The response to list artifacts attached to an object.
 */
export interface ArtifactsListResponse {
    /** The artifact's information. */
    artifacts: Artifact[];
}
/**
 * artifacts-locate-request
 * The request to get an artifact's download URL.
 */
export interface ArtifactsLocateRequest {
    /**
     * The ID of the artifact to get the URL for.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    id: string;
    /**
     * The required variant of the file. By default, it returns the
     * original file.
     */
    variant?: string;
}
/**
 * artifacts-locate-response
 * The response to getting an artifact's download URL.
 */
export interface ArtifactsLocateResponse {
    /**
     * The expiration timestamp of the URL.
     * @format date-time
     */
    expires_at?: string;
    /**
     * The expiration timestamp of the URL.
     * @deprecated
     * @format date-time
     */
    expiry_time: string;
    /** The artifact's download URL. */
    url: string;
}
/**
 * artifacts-prepare-request
 * The request to prepare a URL to upload a file.
 */
export interface ArtifactsPrepareRequest {
    /** Represents a set of configuration to be used with the artifacts object. */
    configuration_set?: ArtifactConfigurationSet;
    /** The name of the file that's being uploaded. */
    file_name: string;
    /** The type of file that's being uploaded. */
    file_type?: string;
}
/**
 * artifacts-prepare-response
 * The response to preparing a URL to upload a file.
 */
export interface ArtifactsPrepareResponse {
    /** The POST policy form data. */
    form_data: ArtifactsPrepareResponseFormData[];
    /**
     * The generated artifact's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    id: string;
    /** The generated artifact's ID. */
    id_v1?: string;
    /** The URL that the file's data should be uploaded to. */
    url: string;
}
/** artifacts-prepare-response-form-data */
export interface ArtifactsPrepareResponseFormData {
    /** Key of the form field. */
    key: string;
    /** Value corresponding to the key. */
    value: string;
}
/** assign-result */
export interface AssignResult {
    /**
     * The error message in case the assignment failed for the given Rev
     * organization.
     */
    error_message?: string;
    rev_org: RevOrgSummary;
}
/** atom-base */
export interface AtomBase {
    created_by?: UserSummary;
    /**
     * Timestamp when the object was created.
     * @format date-time
     */
    created_date?: string;
    /** Human-readable object ID unique to the Dev organization. */
    display_id?: string;
    /** Globally unique object ID. */
    id: string;
    /** Globally unique object ID. */
    id_v1?: string;
    modified_by?: UserSummary;
    /**
     * Timestamp when the object was last modified.
     * @format date-time
     */
    modified_date?: string;
}
/** atom-base-summary */
export interface AtomBaseSummary {
    /** Human-readable object ID unique to the Dev organization. */
    display_id?: string;
    /** Globally unique object ID. */
    id: string;
    /** Globally unique object ID. */
    id_v1?: string;
}
/** atom-summary */
export type AtomSummary = (AccountSummary | AddonRulesSummary | AppFragmentSummary | ArticleSummary | ArtifactSummary | AuthTokenSummary | AutomationSummary | CapabilitySummary | CommandSummary | ComponentSummary | ConditionalRoleSummary | ConversationCreatedNotificationSummary | ConversationInactivityReminderSummary | ConversationSummary | CreditCouponSummary | CreditSummary | CustomObjectSummary | CustomPartSummary | CustomStageSummary | CustomStateSummary | CustomTypeFragmentSummary | CustomWorkSummary | DevOrgSummary | DevUserSummary | DevrevProfileSummary | DevrevReminderSummary | DevuInviteSummary | DiscoveryGitCommitSummary | DiscoveryGitEventSummary | DiscoveryProfileSummary | DiscoveryRunSummary | DiscoverySettingsSummary | EnhancementSummary | EventSourceSummary | FeaturePinSummary | FeatureSummary | FlowSummary | FunctionDefinitionSummary | GroupSummary | InvoiceSummary | IssueSummary | KeyringSummary | LinkSummary | LinkablePinSummary | LinkableSummary | MarketplaceCategorySummary | MarketplaceItemSummary | MarketplaceSummary | MeetingSummary | MetricDefinitionSummary | MicroflowDefinitionSummary | MicroserviceSummary | NewsSummary | ObjectAssignmentNotificationSummary | ObjectMemberSummary | OneTimeLineItemSummary | OpportunitySummary | OrgPreferencesSummary | PaymentMethodBankAccountSummary | PaymentMethodCardSummary | PrReviewReminderSummary | PricingSummary | ProductSummary | ProjectSummary | PushDeviceSummary | RealTimeInsightSummary | RealTimeInsightValueSummary | RecurringLineItemSummary | RevOrgSummary | RevUserSummary | RewardSummary | RewardTransactionSummary | RoleSummary | RoomSummary | RunnablePinSummary | RunnableSummary | ScheduleFragmentSummary | ScheduleSummary | ServiceAccountSummary | ServicePlanSummary | SettingsSummary | SkuRulesSummary | SkuSummary | SlaSummary | SlaTrackerSummary | SnapInFunctionSummary | SnapInPackageSummary | SnapInSummary | SnapInVersionSummary | SnapKitActionSummary | StageDiagramSummary | StockSchemaFragmentSummary | SurveySummary | SysUserSummary | TagSummary | TaskSummary | TenantFragmentSummary | TicketSummary | TimelineChangeEventSummary | TimelineCommentSummary | UomSummary | UserMentionedNotificationSummary | UserParticipationNotificationSummary | UserPreferencesSummary | VistaSharedNotificationSummary | WebhookSummary | WindowBasedInsightSummary | WindowBasedInsightValueSummary) & {
    type: AtomType;
};
export declare enum AtomType {
    Account = "account",
    AddonRules = "addon_rules",
    AppFragment = "app_fragment",
    Article = "article",
    Artifact = "artifact",
    AuthToken = "auth_token",
    Automation = "automation",
    Capability = "capability",
    Command = "command",
    Component = "component",
    ConditionalRole = "conditional_role",
    Conversation = "conversation",
    ConversationCreatedNotification = "conversation_created_notification",
    ConversationInactivityReminder = "conversation_inactivity_reminder",
    Credit = "credit",
    CreditCoupon = "credit_coupon",
    CustomObject = "custom_object",
    CustomPart = "custom_part",
    CustomStage = "custom_stage",
    CustomState = "custom_state",
    CustomTypeFragment = "custom_type_fragment",
    CustomWork = "custom_work",
    DevOrg = "dev_org",
    DevUser = "dev_user",
    DevrevProfile = "devrev_profile",
    DevrevReminder = "devrev_reminder",
    DevuInvite = "devu_invite",
    DiscoveryGitCommit = "discovery_git_commit",
    DiscoveryGitEvent = "discovery_git_event",
    DiscoveryProfile = "discovery_profile",
    DiscoveryRun = "discovery_run",
    DiscoverySettings = "discovery_settings",
    Enhancement = "enhancement",
    EventSource = "event_source",
    Feature = "feature",
    FeaturePin = "feature_pin",
    Flow = "flow",
    FunctionDefinition = "function_definition",
    Group = "group",
    Invoice = "invoice",
    Issue = "issue",
    Keyring = "keyring",
    Link = "link",
    Linkable = "linkable",
    LinkablePin = "linkable_pin",
    Marketplace = "marketplace",
    MarketplaceCategory = "marketplace_category",
    MarketplaceItem = "marketplace_item",
    Meeting = "meeting",
    MetricDefinition = "metric_definition",
    MicroflowDefinition = "microflow_definition",
    Microservice = "microservice",
    News = "news",
    ObjectAssignmentNotification = "object_assignment_notification",
    ObjectMember = "object_member",
    OneTimeLineItem = "one_time_line_item",
    Opportunity = "opportunity",
    OrgPreferences = "org_preferences",
    PaymentMethodBankAccount = "payment_method_bank_account",
    PaymentMethodCard = "payment_method_card",
    PrReviewReminder = "pr_review_reminder",
    Pricing = "pricing",
    Product = "product",
    Project = "project",
    PushDevice = "push_device",
    RealTimeInsight = "real_time_insight",
    RealTimeInsightValue = "real_time_insight_value",
    RecurringLineItem = "recurring_line_item",
    RevOrg = "rev_org",
    RevUser = "rev_user",
    Reward = "reward",
    RewardTransaction = "reward_transaction",
    Role = "role",
    Room = "room",
    Runnable = "runnable",
    RunnablePin = "runnable_pin",
    Schedule = "schedule",
    ScheduleFragment = "schedule_fragment",
    ServiceAccount = "service_account",
    ServicePlan = "service_plan",
    Settings = "settings",
    Sku = "sku",
    SkuRules = "sku_rules",
    Sla = "sla",
    SlaTracker = "sla_tracker",
    SnapIn = "snap_in",
    SnapInFunction = "snap_in_function",
    SnapInPackage = "snap_in_package",
    SnapInVersion = "snap_in_version",
    SnapKitAction = "snap_kit_action",
    StageDiagram = "stage_diagram",
    StockSchemaFragment = "stock_schema_fragment",
    Survey = "survey",
    SysUser = "sys_user",
    Tag = "tag",
    Task = "task",
    TenantFragment = "tenant_fragment",
    Ticket = "ticket",
    TimelineChangeEvent = "timeline_change_event",
    TimelineComment = "timeline_comment",
    Uom = "uom",
    UserMentionedNotification = "user_mentioned_notification",
    UserParticipationNotification = "user_participation_notification",
    UserPreferences = "user_preferences",
    VistaSharedNotification = "vista_shared_notification",
    Webhook = "webhook",
    WindowBasedInsight = "window_based_insight",
    WindowBasedInsightValue = "window_based_insight_value"
}
/**
 * auth-connection
 * Connection object that specifies the configuration for an
 * authentication connection that is set up for a Dev organization.
 */
export type AuthConnection = (AuthConnectionOptionsAzureAd | AuthConnectionOptionsGoogleApps | AuthConnectionOptionsOidc | AuthConnectionOptionsSaml | AuthConnectionOptionsSocial) & {
    /**
     * Display name of the authentication connection. This name will be
     * visible to all the users when they sign in to this Dev
     * organization. For example, if the display_name is 'abclogin', then
     * it would appear on the login button as 'Log in to abclogin'.
     */
    display_name?: string;
    /**
     * Whether the authentication connection is enabled or disabled. If
     * set to false, the authentication connection will not show up on the
     * login screen as a login option.
     */
    enabled?: boolean;
    /** ID of the authentication connection. */
    id: string;
    /**
     * Defines the type for the authentication connection. The configuration
     * for each authentication connection will depend on the type value.
     */
    type: AuthConnectionType;
};
/**
 * auth-connection-options-azure-ad
 * Object encapsulating the configuration parameters for an Azure AD
 * authentication connection.
 */
export interface AuthConnectionOptionsAzureAd {
    /** Client ID for the Azure authentication connection. */
    client_id?: string;
    /** Client secret for the Azure authentication connection. */
    client_secret?: string;
    /** Domain URL of the Azure authentication connection. */
    domain?: string;
}
/**
 * auth-connection-options-google-apps
 * Object encapsulating the configuration parameters for a Google Apps
 * authentication connection.
 */
export interface AuthConnectionOptionsGoogleApps {
    /** Client ID for the Google Apps authentication connection. */
    client_id?: string;
    /** Client secret for the Google Apps authentication connection. */
    client_secret?: string;
    /** Tenant domain URL of the Google Apps authentication connection. */
    tenant_domain?: string;
}
/**
 * auth-connection-options-oidc
 * Object encapsulating the configuration parameters for an OIDC
 * authentication connection.
 */
export interface AuthConnectionOptionsOidc {
    /** Client ID for the OIDC authentication connection. */
    client_id?: string;
    /** Client secret for the OIDC authentication connection. */
    client_secret?: string;
    /** Issuer URL of the OIDC authentication connection. */
    issuer?: string;
}
/**
 * auth-connection-options-saml
 * Object encapsulating the configuration parameters for a SAML
 * authentication connection.
 */
export interface AuthConnectionOptionsSaml {
    /** Sign In endpoint for the SAML authentication connection. */
    sign_in_endpoint?: string;
    /** Signing certificate for the SAML authentication connection. */
    signing_cert?: string;
}
/** auth-connection-options-social */
export type AuthConnectionOptionsSocial = object;
export declare enum AuthConnectionToggle {
    Disable = "disable",
    Enable = "enable"
}
/**
 * Defines the type for the authentication connection. The configuration
 * for each authentication connection will depend on the type value.
 */
export declare enum AuthConnectionType {
    GoogleApps = "google_apps",
    Oidc = "oidc",
    Samlp = "samlp",
    Social = "social",
    Waad = "waad"
}
/** auth-token */
export type AuthToken = AtomBase & {
    /**
     * An identifier that represents the application that requested the
     * token. Only applicable for application access tokens.
     */
    client_id?: string;
    /**
     * The time at which the token expires.
     * @format date-time
     */
    expires_at?: string;
    /**
     * The time at which the token was issued.
     * @format date-time
     */
    issued_at?: string;
    /** The type of the requested token. */
    requested_token_type?: AuthTokenRequestedTokenType;
    /** The scopes associated with the issued token. */
    scopes?: string[];
    /** The status of the token. */
    status?: AuthTokenStatus;
    /** The subject of the token. */
    subject?: string;
    /** A hint that identifies the token. */
    token_hint?: string;
};
/** Specifies the process of obtaining a token. */
export declare enum AuthTokenGrantType {
    UrnDevrevParamsOauthGrantTypeTokenIssue = "urn:devrev:params:oauth:grant-type:token-issue",
    UrnIetfParamsOauthGrantTypeTokenExchange = "urn:ietf:params:oauth:grant-type:token-exchange"
}
/** The type of the requested token. */
export declare enum AuthTokenRequestedTokenType {
    UrnDevrevParamsOauthTokenTypeAat = "urn:devrev:params:oauth:token-type:aat",
    UrnDevrevParamsOauthTokenTypeAatPublic = "urn:devrev:params:oauth:token-type:aat:public",
    UrnDevrevParamsOauthTokenTypeDev = "urn:devrev:params:oauth:token-type:dev",
    UrnDevrevParamsOauthTokenTypePat = "urn:devrev:params:oauth:token-type:pat",
    UrnDevrevParamsOauthTokenTypeRev = "urn:devrev:params:oauth:token-type:rev",
    UrnDevrevParamsOauthTokenTypeSession = "urn:devrev:params:oauth:token-type:session",
    UrnDevrevParamsOauthTokenTypeSessionDev0 = "urn:devrev:params:oauth:token-type:session:dev0",
    UrnDevrevParamsOauthTokenTypeSys = "urn:devrev:params:oauth:token-type:sys",
    UrnIetfParamsOauthTokenTypeJwt = "urn:ietf:params:oauth:token-type:jwt"
}
/** The status of the token. */
export declare enum AuthTokenStatus {
    Active = "active",
    Expired = "expired",
    Revoked = "revoked"
}
/** The type of the subject token. */
export declare enum AuthTokenSubjectTokenType {
    UrnDevrevParamsOauthTokenTypeJwtAuth0 = "urn:devrev:params:oauth:token-type:jwt:auth0",
    UrnDevrevParamsOauthTokenTypeJwtDev = "urn:devrev:params:oauth:token-type:jwt:dev",
    UrnDevrevParamsOauthTokenTypeRevinfo = "urn:devrev:params:oauth:token-type:revinfo",
    UrnDevrevParamsOauthTokenTypeSysu = "urn:devrev:params:oauth:token-type:sysu",
    UrnDevrevParamsOauthTokenTypeUserinfo = "urn:devrev:params:oauth:token-type:userinfo",
    UrnDevrevParamsOauthTokenTypeUserinfoProfile = "urn:devrev:params:oauth:token-type:userinfo:profile",
    UrnIetfParamsOauthTokenTypeJwt = "urn:ietf:params:oauth:token-type:jwt"
}
/** auth-token-summary */
export type AuthTokenSummary = AtomBaseSummary;
/** The type of the issued token. Bearer is the only supported token type. */
export declare enum AuthTokenTokenType {
    Bearer = "bearer"
}
/**
 * auth-tokens-create-request
 * A request to create a new token corresponding to the requested token
 * type.
 */
export interface AuthTokensCreateRequest {
    /** The expected audience values with respect to the token. */
    aud?: string[];
    /**
     * An identifier that represents the application which is requesting
     * the token. If no client_id is present in the request to generate an
     * application access token (AAT), DevRev will generate a client_id.
     * This client_id is only associated with an AAT.
     */
    client_id?: string;
    /**
     * The expected validity lifetime of the token in number of days.
     * @format int64
     */
    expires_in?: number;
    /** Specifies the process of obtaining a token. */
    grant_type?: AuthTokenGrantType;
    /** The type of the requested token. */
    requested_token_type?: AuthTokenRequestedTokenType;
    /**
     * Carries info corresponding to the Rev user to be provisioned and/or
     * issue a Rev session token.
     */
    rev_info?: AuthTokensRevInfo;
    /**
     * The requested set of scopes associated with the issued token. A
     * space-delimited list of values in which the order of values does
     * not matter.
     */
    scope?: string;
    /**
     * Represents the entity that requests the token. Not required when
     * requesting an application access token (AAT).
     */
    subject_token?: string;
    /** The type of the subject token. */
    subject_token_type?: AuthTokenSubjectTokenType;
    /** A hint that identifies the token. */
    token_hint?: string;
}
/**
 * auth-tokens-create-response
 * Response for the request to create a new token corresponding to the
 * requested token type.
 */
export interface AuthTokensCreateResponse {
    /**
     * The issued JSON Web Token (JWT) corresponding to the requested
     * token type.
     */
    access_token: string;
    /**
     * An identifier that represents the application which is requesting
     * the token. Only present in a response corresponding to an
     * application access token (AAT).
     */
    client_id?: string;
    /**
     * The validity lifetime of the token specified in seconds since Unix
     * epoch.
     * @format int64
     */
    expires_in: number;
    /** A token to refresh the issued token. */
    refresh_token?: string;
    /**
     * The scopes associated with the issued token. A space-delimited list
     * of values in which the order of values does not matter.
     */
    scope?: string;
    /** The type of the issued token. Bearer is the only supported token type. */
    token_type: AuthTokenTokenType;
}
/**
 * auth-tokens-delete-request
 * The request to revoke the token.
 */
export interface AuthTokensDeleteRequest {
    /**
     * The unique identifier for the token under a given Dev organization.
     * If no token ID is provided, then the token ID will be set from the
     * JTI claim of the token in the authorization header.
     */
    token_id?: string;
}
/**
 * auth-tokens-get-request
 * The request to get the token metadata.
 */
export interface AuthTokensGetRequest {
    /** The unique identifier of the token under a given Dev organization. */
    token_id: string;
}
/**
 * auth-tokens-get-response
 * The response to get the token metadata.
 */
export interface AuthTokensGetResponse {
    token: AuthToken;
}
/**
 * auth-tokens-list-request
 * A request to list the token metadata.
 */
export interface AuthTokensListRequest {
    /**
     * An identifier that represents the application, which requested the
     * token. Only relevant for application access tokens.
     */
    client_id?: string;
    /** The type of the requested token. */
    requested_token_type?: AuthTokenRequestedTokenType;
    /**
     * The subject associated with the token. In the absence of this
     * parameter, the ID of the authenticated entity is treated as the
     * subject.
     */
    subject?: string;
}
/**
 * auth-tokens-list-response
 * The response to list the token metadata.
 */
export interface AuthTokensListResponse {
    /** The list of token metadata. */
    tokens: AuthToken[];
}
/**
 * auth-tokens-org-traits
 * Carries Rev org info.
 */
export interface AuthTokensOrgTraits {
    /** The display name of the Rev org. */
    display_name?: string;
    /** The domain of the Rev org. */
    domain?: string;
}
/**
 * auth-tokens-rev-info
 * Carries info corresponding to the Rev user to be provisioned and/or
 * issue a Rev session token.
 */
export interface AuthTokensRevInfo {
    /** An identifier which uniquely identifies a Rev org. */
    org_ref?: string;
    /** Carries Rev org info. */
    org_traits?: AuthTokensOrgTraits;
    /** An identifier which uniquely identifies a Rev user. */
    user_ref: string;
    /** Carries Rev user info. */
    user_traits?: AuthTokensUserTraits;
}
/**
 * auth-tokens-self-delete-request
 * The request to delete all the tokens created by the authenticated user,
 * that match with the provided token type.
 */
export interface AuthTokensSelfDeleteRequest {
    /** The type of the requested token. */
    requested_token_type?: AuthTokenRequestedTokenType;
}
/**
 * auth-tokens-update-request
 * A request to update the token metadata.
 */
export interface AuthTokensUpdateRequest {
    /** A hint that identifies the token. */
    token_hint: string;
    /** The unique identifier of the token under a given Dev organization. */
    token_id: string;
}
/**
 * auth-tokens-update-response
 * Response for the request to update the token metadata.
 */
export interface AuthTokensUpdateResponse {
    token: AuthToken;
}
/**
 * auth-tokens-user-traits
 * Carries Rev user info.
 */
export interface AuthTokensUserTraits {
    /** The display name of the Rev user. */
    display_name?: string;
    /** The email address of the Rev user. */
    email?: string;
    /** The full name of the Rev user. */
    full_name?: string;
}
/**
 * auto-suggest-request
 * Autosuggest request.
 */
export interface AutoSuggestRequest {
    /** User action types. */
    action?: UserAction;
    /** Work fields required for recommendation. */
    context: WorkContext;
    /** The fields for which recommendation is required. */
    requested_fields?: AutoSuggestRequestedField[];
}
/** Field types for autosuggest recommendation. */
export declare enum AutoSuggestRequestedField {
    AppliesToPart = "applies_to_part",
    OwnedBy = "owned_by",
    Tag = "tag"
}
/**
 * auto-suggest-response
 * Autosuggest response.
 */
export interface AutoSuggestResponse {
    /** Autosuggest recommendation for given required fields. */
    recommendation: Recommendation;
    /** Version of the autosuggest model. */
    version?: string;
}
/** automation-summary */
export type AutomationSummary = AtomBaseSummary & {
    /** Description of the automation. */
    description?: string;
    /** Name of the automation. */
    name?: string;
};
/**
 * availability-preferences-group
 * Preferences group for Availability.
 */
export interface AvailabilityPreferencesGroup {
    /** Manually set presence to away. */
    manual_away?: boolean;
}
/** batch-apply-request */
export interface BatchApplyRequest {
    /** An individual request item. */
    items: BatchApplyRequestItem[];
}
/** batch-apply-request-item */
export type BatchApplyRequestItem = (AccountsCountRequest | ConversationsCountRequest | ConversationsCreateRequest | ConversationsDeleteRequest | ConversationsGetRequest | ConversationsUpdateRequest | CustomSchemaFragmentsGetRequest | LinksCreateRequest | LinksDeleteRequest | LinksGetRequest | LinksReplaceRequest | PartsCountRequest | PartsCreateRequest | PartsDeleteRequest | PartsGetRequest | PartsUpdateRequest | RevOrgsCountRequest | RevUsersCountRequest | SubtypesListRequest | TagsCreateRequest | TagsDeleteRequest | TagsGetRequest | TagsUpdateRequest | TimelineEntriesCreateRequest | TimelineEntriesDeleteRequest | TimelineEntriesGetRequest | TimelineEntriesListRequest | TimelineEntriesUpdateRequest | WorksCountRequest | WorksCreateRequest | WorksDeleteRequest | WorksGetRequest | WorksUpdateRequest) & {
    batch_type: BatchApplyRequestItemBatchType;
};
export declare enum BatchApplyRequestItemBatchType {
    AccountsCount = "accounts_count",
    ConversationsCount = "conversations_count",
    ConversationsCreate = "conversations_create",
    ConversationsDelete = "conversations_delete",
    ConversationsGet = "conversations_get",
    ConversationsUpdate = "conversations_update",
    CustomSchemaFragmentsGet = "custom_schema_fragments_get",
    LinksCreate = "links_create",
    LinksDelete = "links_delete",
    LinksGet = "links_get",
    LinksReplace = "links_replace",
    PartsCount = "parts_count",
    PartsCreate = "parts_create",
    PartsDelete = "parts_delete",
    PartsGet = "parts_get",
    PartsUpdate = "parts_update",
    RevOrgsCount = "rev_orgs_count",
    RevUsersCount = "rev_users_count",
    SubtypesList = "subtypes_list",
    TagsCreate = "tags_create",
    TagsDelete = "tags_delete",
    TagsGet = "tags_get",
    TagsUpdate = "tags_update",
    TimelineEntriesCreate = "timeline_entries_create",
    TimelineEntriesDelete = "timeline_entries_delete",
    TimelineEntriesGet = "timeline_entries_get",
    TimelineEntriesList = "timeline_entries_list",
    TimelineEntriesUpdate = "timeline_entries_update",
    WorksCount = "works_count",
    WorksCreate = "works_create",
    WorksDelete = "works_delete",
    WorksGet = "works_get",
    WorksUpdate = "works_update"
}
/** batch-apply-response */
export interface BatchApplyResponse {
    /**
     * An individual response item. The item will be the response for the
     * corresponding index in the request.
     */
    items: BatchApplyResponseItem[];
}
/** batch-apply-response-item */
export type BatchApplyResponseItem = (AccountsCountResponse | ConversationsCountResponse | ConversationsCreateResponse | ConversationsDeleteResponse | ConversationsGetResponse | ConversationsUpdateResponse | CustomSchemaFragmentsGetResponse | Error | LinksCreateResponse | LinksDeleteResponse | LinksGetResponse | LinksReplaceResponse | PartsCountResponse | PartsCreateResponse | PartsDeleteResponse | PartsGetResponse | PartsUpdateResponse | RevOrgsCountResponse | RevUsersCountResponse | SubtypesListResponse | TagsCreateResponse | TagsDeleteResponse | TagsGetResponse | TagsUpdateResponse | TimelineEntriesCreateResponse | TimelineEntriesDeleteResponse | TimelineEntriesGetResponse | TimelineEntriesListResponse | TimelineEntriesUpdateResponse | WorksCountResponse | WorksCreateResponse | WorksDeleteResponse | WorksGetResponse | WorksUpdateResponse) & {
    batch_type: BatchApplyResponseItemBatchType;
};
export declare enum BatchApplyResponseItemBatchType {
    AccountsCount = "accounts_count",
    ConversationsCount = "conversations_count",
    ConversationsCreate = "conversations_create",
    ConversationsDelete = "conversations_delete",
    ConversationsGet = "conversations_get",
    ConversationsUpdate = "conversations_update",
    CustomSchemaFragmentsGet = "custom_schema_fragments_get",
    Error = "error",
    LinksCreate = "links_create",
    LinksDelete = "links_delete",
    LinksGet = "links_get",
    LinksReplace = "links_replace",
    PartsCount = "parts_count",
    PartsCreate = "parts_create",
    PartsDelete = "parts_delete",
    PartsGet = "parts_get",
    PartsUpdate = "parts_update",
    RevOrgsCount = "rev_orgs_count",
    RevUsersCount = "rev_users_count",
    SubtypesList = "subtypes_list",
    TagsCreate = "tags_create",
    TagsDelete = "tags_delete",
    TagsGet = "tags_get",
    TagsUpdate = "tags_update",
    TimelineEntriesCreate = "timeline_entries_create",
    TimelineEntriesDelete = "timeline_entries_delete",
    TimelineEntriesGet = "timeline_entries_get",
    TimelineEntriesList = "timeline_entries_list",
    TimelineEntriesUpdate = "timeline_entries_update",
    WorksCount = "works_count",
    WorksCreate = "works_create",
    WorksDelete = "works_delete",
    WorksGet = "works_get",
    WorksUpdate = "works_update"
}
/** capabilities-list-request */
export type CapabilitiesListRequest = object;
/** capabilities-list-response */
export interface CapabilitiesListResponse {
    /** List of supported categories. */
    categories: string[];
    /** List of supported external services. */
    external_services: CapabilitiesListResponseExternalService[];
}
/** capabilities-list-response-external-service */
export interface CapabilitiesListResponseExternalService {
    /** Supported keyring categories. */
    categories: string[];
    /** Supported keyring types (connections) to the external service. */
    connections: CapabilitiesListResponseExternalServiceConnection[];
    /** Unique id of the external service. */
    id: string;
    /** User friendly name of the external service. */
    name: string;
}
/** capabilities-list-response-external-service-connection */
export interface CapabilitiesListResponseExternalServiceConnection {
    /** Keyring type defines the external system authentication method. */
    add_new_org_keyring_type?: KeyringType;
    /** Can user create a new keyring of this type. */
    can_create: boolean;
    /** Can user trigger a reauthorization. */
    can_reauthorize: boolean;
    /** An array of fields to render to the user. */
    fields?: CapabilitiesListResponseExternalServiceConnectionField[];
    /** Keyring type defines the external system authentication method. */
    keyring_type: KeyringType;
}
/** capabilities-list-response-external-service-connection-field */
export interface CapabilitiesListResponseExternalServiceConnectionField {
    /** Is a property name that will be used to store the data in JSON */
    name: string;
    /**
     * If true, the user will not be able to create a connection until the
     * user has provided data inside this input.
     */
    required: boolean;
}
/** capability */
export type Capability = PartBase & {
    /** IDs of the runnables that fulfill this capability. */
    fulfilled_by?: PartSummary[];
    part_of_part?: PartSummary;
    pm_owner?: UserSummary;
};
/** capability-summary */
export type CapabilitySummary = PartBaseSummary;
/** client-frame */
export interface ClientFrame {
    recent_frame: RecentFrame;
    view_frame: ViewFrame;
}
/** command */
export type Command = AtomBase & {
    /** Action defines some logic to run. */
    action?: CommandAction;
    /** Description of the command. */
    description?: string;
    /** Name of the command. */
    name?: string;
    /** Namespace of the command. */
    namespace?: string;
    /** Status of the command. */
    status?: CommandStatus;
    /** Surfaces where this command can be invoked. */
    surfaces?: CommandSurface[];
    /**
     * A user friendly description of the parameters which can be passed
     * to the command.
     */
    usage_hint?: string;
};
/**
 * command-action
 * Action defines some logic to run.
 */
export interface CommandAction {
    /**
     * The raw code to execute, defined in the language specified by
     * executor.
     */
    code?: string;
    /** Executor specific config. */
    executor_config?: object;
    /** Specifies how the action is defined. */
    executor_type?: CommandActionExecutorType;
}
/** Specifies how the action is defined. */
export declare enum CommandActionExecutorType {
    Rego = "rego"
}
/** command-create-request */
export interface CommandCreateRequest {
    action?: CreateCommandAction;
    /** Description of the command */
    description?: string;
    /** Name of the command */
    name: string;
    /** Namespace of the command */
    namespace: string;
    /** Status of the command. */
    status?: CommandStatus;
    /** Surfaces where this command can be invoked */
    surfaces?: CreateCommandSurface[];
    /**
     * A user friendly description of the parameters which can be passed
     * to the command
     */
    usage_hint?: string;
}
/** command-create-response */
export interface CommandCreateResponse {
    command: Command;
}
/** command-delete-request */
export interface CommandDeleteRequest {
    /** The command's ID. */
    id: string;
}
/** command-execute-request */
export interface CommandExecuteRequest {
    /** The command's ID. */
    id: string;
    /** Command invocation source like work, part, search, etc. */
    invocation_source: string;
    /** Input parameters of the command. */
    parameters?: string;
    /** ID of the object where command is invoked (work/part/conversation). */
    source_object_id?: string;
}
/** command-execute-response */
export interface CommandExecuteResponse {
    /** The unique id corresponding to command execution. */
    request_id: string;
}
/** command-get-request */
export interface CommandGetRequest {
    /** The command's ID. */
    id: string;
}
/** command-get-response */
export interface CommandGetResponse {
    command: Command;
}
/** Status of the command. */
export declare enum CommandStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}
/** command-summary */
export type CommandSummary = AtomBaseSummary & {
    /** Name of the command. */
    name?: string;
};
/**
 * command-surface
 * Metadata defining which surfaces can this command be executed on.
 */
export interface CommandSurface {
    /** Objects types on which a command can be invoked. */
    object_types?: CommandSurfaceObjectTypes[];
    /**
     * Surfaces from where this command can be invoked. In future this will be
     * extended to add more places like list views and events from where a
     * command can be invoked.
     */
    surface?: CommandSurfaceSurface;
}
/** Objects types on which a command can be invoked. */
export declare enum CommandSurfaceObjectTypes {
    Conversation = "conversation",
    Issue = "issue",
    Part = "part",
    RevOrg = "rev_org",
    RevUser = "rev_user",
    Ticket = "ticket"
}
/**
 * Surfaces from where this command can be invoked. In future this will be
 * extended to add more places like list views and events from where a
 * command can be invoked.
 */
export declare enum CommandSurfaceSurface {
    Discussions = "discussions"
}
/** command-update-request */
export interface CommandUpdateRequest {
    /** Description of the command. */
    description?: string;
    /** The command's ID. */
    id: string;
    /** Status of the command. */
    status?: CommandStatus;
}
/** command-update-response */
export interface CommandUpdateResponse {
    command: Command;
}
/** commands-list-request */
export interface CommandsListRequest {
    /** The cursor to begin iteration from. */
    cursor?: string;
    /** List of fields to sort the commands items by and how to sort them. */
    sort_by?: string[];
}
/** commands-list-response */
export interface CommandsListResponse {
    /** List of commands. */
    commands: Command[];
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     */
    cursor?: string;
}
/**
 * comment-activity
 * A comment activity.
 */
export interface CommentActivity {
    comment?: TimelineComment;
}
/**
 * compensation
 * Describes the compensation to be provided in case of SLA breach. It is
 * not 'self-executing', it is the responsibility of the dev_org to
 * actually provide the promised credit, resource or other payment.
 */
export interface Compensation {
    /**
     * The amount to be provided.
     * @format int32
     */
    amount?: number;
    /**
     * The 'unit' in which it is 'paid'. It can be a real currency, but it
     * needs not to be, can be any type of credit, quota, discount etc.
     */
    unit?: string;
}
/** component */
export type Component = PartBase & {
    development_owner?: UserSummary;
    pm_owner?: UserSummary;
    qa_owner?: UserSummary;
};
/** component-summary */
export type ComponentSummary = PartBaseSummary;
/**
 * composite-schema
 * The schema of a composite type.
 */
export interface CompositeSchema {
    /** Description of this composite type. */
    description?: string;
    /** List of all fields in this schema. */
    fields: FieldDescriptor[];
    /** Name of this composite type. */
    name?: string;
}
/** The operator used to compare the object vals. */
export declare enum ConditionOperator {
    Eq = "eq",
    In = "in",
    NotEq = "not_eq",
    NotIn = "not_in"
}
/**
 * condition-summary
 * Condition.
 */
export interface ConditionSummary {
    /** Key used to fetch the object value. */
    key?: string;
    /** The operator used to compare the object vals. */
    operator?: ConditionOperator;
    /** Values valid for the key. */
    vals: string[];
}
/**
 * condition-v1
 * Condition.
 */
export interface ConditionV1 {
    /** Key used to fetch the object value. */
    key?: string;
    /** The operator used to compare the object vals. */
    operator?: ConditionV1Operator;
    /** Values valid for the key. */
    vals: string[];
}
/** The operator used to compare the object vals. */
export declare enum ConditionV1Operator {
    Eq = "eq",
    In = "in",
    NotEq = "not_eq",
    NotIn = "not_in"
}
/** Object type for which the conditional role is defined. */
export declare enum ConditionalRoleApplicableObjectType {
    Conversation = "conversation",
    Group = "group",
    Issue = "issue",
    Part = "part",
    Ticket = "ticket",
    Token = "token",
    Vista = "vista"
}
/** conditional-role-summary */
export type ConditionalRoleSummary = AtomBaseSummary & {
    access_level?: AccessLevel;
    /** Object type for which the conditional role is defined. */
    applicable_object_type: ConditionalRoleApplicableObjectType[];
    /** Conditions definition which must be met for role. */
    conditions: ConditionSummary[];
    /** Version of the default conditional role. */
    default_version?: string;
    /** Description of the conditional role. */
    description?: string;
    /**
     * Display Name which can be used in the UI for representing the
     * conditional role.
     */
    display_name?: string;
    /** IDs of the conditional role(s) that this conditional role includes. */
    includes?: ConditionalRoleSummary[];
    /** Determines if this is an object member type or not. */
    is_object_member_type?: boolean;
    /** Name of the Conditional Role. */
    name?: string;
    /** Privileges the conditional role includes. */
    privileges: string[];
};
/**
 * conditional-role-v1
 * Conditional role.
 */
export interface ConditionalRoleV1 {
    access_level?: AccessLevel;
    /** Conditions definition which must be met for role. */
    conditions: ConditionV1[];
    role_id?: RoleSummary;
}
/**
 * configuration
 * Settings related to payment, proration, etc. Configurations may or may
 * not be defined by a DevO. 1. If DevO defines configurations then same
 * configurations are copied to RevO also to sub pack (for now, later RevO
 * can also set) 2. If DevO doesn't set anything then these configurations
 * would be set to default by application for which they were being
 * defined (for eg. if DevO doesn't set payment method for it's RevOs then
 * stripe would set it to 'charge_automatically' by default).
 */
export interface Configuration {
    /**
     * Charge collection strategy for the service plan. Defaults to
     * charge_automatically.
     */
    collection_method?: ConfigurationCollectionMethod;
    /**
     * Number of days a customer has to pay invoices generated by this
     * subscription. If collection method is set to send_invoice then this
     * field is mandatory.
     * @format int32
     */
    days_until_due?: number;
    /**
     * Whether to generate invoice immediately if the service plan is
     * cancelled. Defaults to false.
     */
    invoice_now_on_cancel_service_plan?: boolean;
    /**
     * If pending update is allowed or not, this is for those cases where
     * an additional step of authentication or manual approval is required
     * for the payment. Defaults to false. If this is true, then Proration
     * behavior should be always_invoice, and collection method should be
     * charge_automatically.
     */
    pending_update?: boolean;
    /**
     * Whether to prorate if the service plan is cancelled. Defaults to
     * false.
     */
    prorate_on_cancel_service_plan?: boolean;
    /**
     * Determines how to handle prorations resulting from the billing_date. If
     * no value is passed, the default is create_prorations.
     */
    proration_behavior?: ConfigurationProrationBehavior;
}
/**
 * Charge collection strategy for the service plan. Defaults to
 * charge_automatically.
 */
export declare enum ConfigurationCollectionMethod {
    ChargeAutomatically = "charge_automatically",
    SendInvoice = "send_invoice"
}
/**
 * Determines how to handle prorations resulting from the billing_date. If
 * no value is passed, the default is create_prorations.
 */
export declare enum ConfigurationProrationBehavior {
    AlwaysInvoice = "always_invoice",
    CreateProrations = "create_prorations",
    None = "none"
}
/**
 * contact-details
 * Contact Details of the customer.
 */
export interface ContactDetails {
    /** Address details of the customer. */
    address?: Address;
    /** The contact's name. */
    name?: string;
    /** The contact's phone. */
    phone?: string;
}
/**
 * content
 * Content format and text for the news.
 */
export interface Content {
    /** Format of the content. */
    format: string;
    /** The content of the news. */
    text: string;
}
/** conversation */
export type Conversation = AtomBase & {
    /** Details of the parts relevant to the conversation. */
    applies_to_parts?: PartSummary[];
    /** Active channels for the conversation. */
    broadcast_channels?: string[];
    /** Description of the conversation object. */
    description?: string;
    /**
     * Timestamp to track the first response from Dev.
     * @format date-time
     */
    first_response_time?: string;
    /**
     * Timestamp of the last message in the conversation.
     * @format date-time
     */
    last_message_timestamp?: string;
    /** Links associated with the object. */
    links?: ArchetypeLinkSummary[];
    /** The users in the conversation. */
    members: UserSummary[];
    /** The latest messages on the conversation. */
    messages?: TimelineEntry[];
    /** Owner IDs for the conversation. */
    owned_by?: UserSummary[];
    /** Priority of the conversation. */
    priority?: ConversationPriority;
    /** Globally unique IDs of participating orgs. */
    rev_orgs?: OrgSummary[];
    /** SLA summary for the object. */
    sla_summary?: ArchetypeSlaSummary;
    /** Source channel for the conversation. */
    source_channel?: string;
    /** Describes the current stage of a work item. */
    stage?: Stage;
    started_by?: UserSummary;
    /** State of the object based upon the stage. */
    state?: string;
    /** Status of the conversation. */
    status?: string;
    /** Tags associated with the object. */
    tags?: TagWithValue[];
    /** Title of the conversation object. */
    title?: string;
};
/**
 * conversation-assist-recommendation-article
 * An article recommendation item.
 */
export type ConversationAssistRecommendationArticle = ConversationAssistRecommendationBase & {
    article: ArticleSummary;
    artifact: ArtifactSummary;
    /** Suggested text from the article. */
    text?: string;
};
/**
 * conversation-assist-recommendation-base
 * Base for conversation assist recommendation item.
 */
export interface ConversationAssistRecommendationBase {
    /**
     * Confidence score of the recommendation.
     * @format float
     */
    confidence: number;
}
/**
 * conversation-assist-recommendation-conversation
 * A conversation recommendation item.
 */
export type ConversationAssistRecommendationConversation = ConversationAssistRecommendationBase & {
    conversation: ConversationSummary;
};
/**
 * conversation-assist-recommendation-ticket
 * A ticket recommendation item.
 */
export type ConversationAssistRecommendationTicket = ConversationAssistRecommendationBase & {
    ticket: WorkSummary;
};
/**
 * conversation-assist-request
 * Conversations Assist request.
 */
export interface ConversationAssistRequest {
    /** ID of the conversation for which assistance is requested. */
    id: string;
    /** List of requested objects. */
    requested_objects: ConversationAssistRequestedObject[];
}
/** Object for which suggestions are requested. */
export declare enum ConversationAssistRequestedObject {
    Article = "article",
    Conversation = "conversation",
    Ticket = "ticket"
}
/**
 * conversation-assist-response
 * Conversations Assist response.
 */
export interface ConversationAssistResponse {
    /** List of recommended articles. */
    articles?: ConversationAssistRecommendationArticle[];
    /** List of recommended conversations. */
    conversations?: ConversationAssistRecommendationConversation[];
    /** List of recommended tickets. */
    tickets?: ConversationAssistRecommendationTicket[];
}
/** conversation-created-notification */
export type ConversationCreatedNotification = NotificationBase & {
    conversation_id?: AtomSummary;
};
/** conversation-created-notification-summary */
export type ConversationCreatedNotificationSummary = NotificationBaseSummary;
/** conversation-inactivity-reminder */
export type ConversationInactivityReminder = NotificationBase & {
    /**
     * Time of creation of the last message in conversation.
     * @format date-time
     */
    created_at?: string;
};
/** conversation-inactivity-reminder-summary */
export type ConversationInactivityReminderSummary = NotificationBaseSummary;
/** Priority of the conversation. */
export declare enum ConversationPriority {
    P0 = "p0",
    P1 = "p1",
    P2 = "p2"
}
/** conversation-search-summary */
export type ConversationSearchSummary = SearchSummaryBase & {
    conversation: ConversationSummary;
};
/** conversation-summary */
export type ConversationSummary = AtomBaseSummary & {
    /** Title of the conversation object. */
    title?: string;
};
/** conversations-count-request */
export interface ConversationsCountRequest {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    created_date?: DateTimeFilter;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/** conversations-count-response */
export interface ConversationsCountResponse {
    /**
     * Count of conversations matching the filter.
     * @format int32
     */
    count: number;
}
/**
 * conversations-create-request
 * The request to create a new conversation.
 */
export interface ConversationsCreateRequest {
    /**
     * The parts that the conversation applies to.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    /** Description for the conversation. */
    description?: string;
    /**
     * The users in the conversation.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    /** Initial messages on the conversation. */
    messages?: ConversationsCreateRequestMessage[];
    /** The users that own the conversation. */
    owned_by?: string[];
    /** Sets an object's initial stage. */
    stage?: StageInit;
    /** Tags associated with the conversation. */
    tags?: SetTagWithValue[];
    /** The title for the conversation. */
    title?: string;
    type: ConversationsCreateRequestTypeValue;
}
/** conversations-create-request-message */
export interface ConversationsCreateRequestMessage {
    /**
     * The IDs of the artifacts to the message.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifact_ids?: string[];
    /**
     * The IDs of the artifacts to the message.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifacts?: string[];
    /** The message's body. */
    body?: string;
}
export declare enum ConversationsCreateRequestTypeValue {
    Support = "support"
}
/**
 * conversations-create-response
 * The response to creating a new conversation.
 */
export interface ConversationsCreateResponse {
    conversation: Conversation;
}
/**
 * conversations-delete-request
 * The request to delete a conversation.
 */
export interface ConversationsDeleteRequest {
    /** The ID of the conversation to delete. */
    id: string;
}
/**
 * conversations-delete-response
 * The response for deleting a conversation.
 */
export type ConversationsDeleteResponse = object;
/** conversations-export-request */
export interface ConversationsExportRequest {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    created_date?: DateTimeFilter;
    /**
     * The number of conversation items to return. The default is '50',
     * the maximum is '5000'.
     * @format int32
     */
    first?: number;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /**
     * Fields to sort the conversation items by and the direction to sort
     * them.
     */
    sort_by?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/** conversations-export-response */
export interface ConversationsExportResponse {
    /** The resulting collection of conversation items. */
    conversations: Conversation[];
}
/**
 * conversations-get-request
 * The request to get a conversation's information.
 */
export interface ConversationsGetRequest {
    /** The requested conversation's ID. */
    id: string;
}
/**
 * conversations-get-response
 * The response to getting a conversation's information.
 */
export interface ConversationsGetResponse {
    conversation: Conversation;
}
/** conversations-group */
export interface ConversationsGroup {
    /** The group of conversations. */
    conversations: Conversation[];
    /** Unique key according to which the items are grouped. */
    key: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** conversations-group-request */
export interface ConversationsGroupRequest {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /** The field to group the conversations by. */
    group_by: string;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of conversations to return for an individual
     * group. The default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Comma-separated fields to sort the conversations by. */
    sort_by?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/** conversations-group-response */
export interface ConversationsGroupResponse {
    /** The list of groups. */
    groups: ConversationsGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * conversations-list-request
 * The request to get information about a list of conversations.
 */
export interface ConversationsListRequest {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of conversations to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Fields to sort the conversations by and the direction to sort them. */
    sort_by?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/**
 * conversations-list-response
 * The response to listing the conversations.
 */
export interface ConversationsListResponse {
    /** The list of conversations. */
    conversations: Conversation[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * conversations-update-request
 * The request to update a conversation.
 */
export interface ConversationsUpdateRequest {
    applies_to_parts?: ConversationsUpdateRequestAppliesToParts;
    /** The updated description for the conversation. */
    description?: string;
    /** The ID of the conversation to update. */
    id: string;
    member_ids?: ConversationsUpdateRequestMemberIds;
    owned_by_ids?: ConversationsUpdateRequestOwnedByIds;
    /** Updates an object's stage. */
    stage?: StageUpdate;
    /** The updated status of the conversation. */
    status?: string;
    tags?: ConversationsUpdateRequestTags;
    /** The updated title of the conversation. */
    title?: string;
}
/** conversations-update-request-applies-to-parts */
export interface ConversationsUpdateRequestAppliesToParts {
    /**
     * Updates the parts that the conversation applies to.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    set?: string[];
}
/** conversations-update-request-member-ids */
export interface ConversationsUpdateRequestMemberIds {
    /**
     * Sets the member IDs to the provided user IDs.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** conversations-update-request-owned-by-ids */
export interface ConversationsUpdateRequestOwnedByIds {
    /**
     * Sets the owner IDs to the provided user IDs. This must not be
     * empty.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** conversations-update-request-tags */
export interface ConversationsUpdateRequestTags {
    /** Sets the tag IDs to the provided tags. */
    set?: SetTagWithValue[];
}
/**
 * conversations-update-response
 * The response for updating a conversation.
 */
export interface ConversationsUpdateResponse {
    conversation: Conversation;
}
/**
 * count-object-member-request
 * A request to count object members.
 */
export interface CountObjectMemberRequest {
    /**
     * The ID of the users or groups that must be a member of one of the
     * specified objects. If empty, then the result sums the total number
     * of members for each object.
     */
    member_ids?: string[];
    /**
     * The ID of the objects to count the members for. If empty, then the
     * result sums the total number of objects that each member is a part
     * of.
     */
    object_ids?: string[];
}
/** count-object-member-response */
export interface CountObjectMemberResponse {
    /**
     * Count of object members satisfying the request parameters.
     * @format int32
     */
    count: number;
}
/** create-command-action */
export interface CreateCommandAction {
    /**
     * The raw code to execute, defined in the language specified by
     * executor
     */
    code: string;
    /** Executor specific config */
    executor_config?: object;
    /** Specifies how the action is defined. */
    executor_type: CommandActionExecutorType;
}
/** create-command-surface */
export interface CreateCommandSurface {
    /** Objects types on which a command can be invoked */
    object_types?: CommandSurfaceObjectTypes[];
    /**
     * Surfaces from where this command can be invoked. In future this will be
     * extended to add more places like list views and events from where a
     * command can be invoked.
     */
    surface: CommandSurfaceSurface;
}
/** create-discovery-profile-request */
export interface CreateDiscoveryProfileRequest {
    /** Configuration knobs for extractors. */
    extractors?: Extractors;
    /** Configuration knobs for partitioners and partition mergers. */
    mergers: DevRevPartitionerMerger;
    /**
     * Discovery other data source Dev org id.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_data_source_dev_org?: string;
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
    /** Configuration knobs for partitioners and partition mergers. */
    partitioners: DevRevPartitionerMerger;
    /** Discovery Profile name. */
    profile_name: string;
}
/** create-discovery-profile-response */
export interface CreateDiscoveryProfileResponse {
    discovery_profile: DiscoveryProfile;
}
/** create-discovery-settings-request */
export interface CreateDiscoverySettingsRequest {
    /** Configuration knobs for discovery application per devorg. */
    data_collection_app_settings?: DataCollectionAppSettings;
    /** Configuration knobs for discovery application per devorg. */
    discovery_app_settings?: DiscoveryAppSettings;
    /** Discovery profile id associated with devorg. */
    discovery_profile_id?: string;
    /** Discovery GitHub repositories settings for devorg. */
    github_repos?: DiscoveryGithubReposSettings[];
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** create-discovery-settings-response */
export interface CreateDiscoverySettingsResponse {
    discovery_settings: DiscoverySettings;
}
/** create-event-source-setup-instructions */
export interface CreateEventSourceSetupInstructions {
    /** Instructions content */
    content?: string;
    /** Format in which content is defined. */
    format: InstructionsFormat;
}
/** create-function-definition */
export interface CreateFunctionDefinition {
    config_policy?: CreatePolicyInstance;
    /** Name of the function. */
    function_name?: string;
    /** Namespace of the function */
    namespace: string;
}
/** create-keyring */
export interface CreateKeyring {
    /** Categories associated with the keyring */
    categories?: string[];
    /** Description of the keyring. */
    description?: string;
    /** External organization ID of the keyring. */
    external_org_id?: string;
    /** Secret key. */
    key?: string;
    /** Name of the keyring. */
    name: string;
    /** Scope of keyring. */
    scope?: KeyringScope;
    /** Keyring type defines the external system authentication method. */
    type: KeyringType;
}
/** create-microflow-definition */
export interface CreateMicroflowDefinition {
    /** JSON defining how microflow is categorized for object type */
    categorization_fields_json: string;
    /** Object type on which the microflow is defined on. */
    defined_on_object_type: MicroflowDefinitionDefinedOnObjectType;
    /** Description of the microflow */
    description?: string;
    /** Name of the microflow */
    name?: string;
    /** Publish status of the microflow. */
    publish_status?: MicroflowDefinitionPublishStatus;
    /** Path of the state field (in dotted notation) */
    state_field_path: string;
    /** Possible states of the object on which microflow is defined */
    states?: CreateMicroflowTargetObjectState[];
    /** Possible transitions in the microflow */
    transitions?: CreateMicroflowTargetObjectTransition[];
}
/** create-microflow-target-object-state */
export interface CreateMicroflowTargetObjectState {
    /** Description of the state */
    description?: string;
    /** Name of the state */
    name: string;
}
/** create-microflow-target-object-transition */
export interface CreateMicroflowTargetObjectTransition {
    /** Set of triggers which could execute this transition */
    allowed_triggers?: CreateMicroflowTriggerDefinition[];
    conditions?: CreatePolicyInstance;
    /** Description of the transition */
    description?: string;
    /** Set of source states for the transition */
    from_states?: string[];
    /** Whether this is a global transition */
    global?: boolean;
    /** Whether this is an initial transition */
    initial?: boolean;
    /** Whether a button is displayed for the transition */
    is_ui_action?: boolean;
    /** The name of the transition, unique within a microflow */
    name: string;
    /** Functions executed asynchronously, on transition success */
    post_function_definitions_ids?: string[];
    /** Functions executed synchronously with state change */
    pre_function_definitions_ids?: string[];
    /** The destination state of the transition */
    to_state?: string;
    validations?: CreatePolicyInstance;
}
/** create-microflow-trigger-definition */
export interface CreateMicroflowTriggerDefinition {
    /** Configuration defining applicable events from the source */
    config?: string;
    /** ID of the event source being subscribed */
    event_source_id?: string;
}
/**
 * create-object-member-request
 * A request to create a new object member.
 */
export interface CreateObjectMemberRequest {
    /** ID of the user or group. */
    member_id: string;
    /**
     * Globally unique DevRev Object Name (DON) for the object where the
     * member is being added.
     */
    object_id: string;
    /**
     * Timestamp when this membership is valid.
     * @format date-time
     */
    valid_from_date?: string;
    /**
     * Timestamp when this membership expires.
     * @format date-time
     */
    valid_to_date?: string;
}
/** create-object-member-response */
export interface CreateObjectMemberResponse {
    object_member: ObjectMember;
}
/** create-one-time-line-items */
export interface CreateOneTimeLineItems {
    /** Pricing at which SKU is to be added in the service plan. */
    pricing_id: string;
    /**
     * Quantity of SKU to be added in the service plan.
     * @format int32
     */
    quantity?: number;
    /** SKU to be added in the service plan. */
    sku_id: string;
}
/**
 * create-phone-number
 * Create object for phone_number.
 */
export interface CreatePhoneNumber {
    /** The phone number in e164 format. */
    e164_number: string;
    /** An optional extension. */
    extension?: string;
}
/** create-policy-instance */
export interface CreatePolicyInstance {
    /** Name of the policy */
    name?: string;
    /** JSON string storing values for each templated variable. */
    parameters?: string;
    /** Rego policy string */
    policy?: string;
    /** Whether the policy is system generated */
    system_parseable?: boolean;
}
/**
 * create-postal-address
 * Create object for postal_address.
 */
export interface CreatePostalAddress {
    /** Country name component. */
    country?: string;
    /**
     * Full mailing address, formatted for display or use on a mailing
     * label.
     */
    formatted?: string;
    /** Town, city. */
    locality?: string;
    /** Zip code of the address. */
    postal_code?: string;
    /** State, province, prefecture, or region component. */
    region?: string;
    /** Full street address component. */
    street_address?: string;
}
/** create-recurring-line-items */
export interface CreateRecurringLineItems {
    /** Pricing at which SKU is to be added in the service plan. */
    pricing_id: string;
    /**
     * Quantity of SKU to be added in the service plan.
     * @format int32
     */
    quantity?: number;
    /** SKU to be added in the service plan. */
    sku_id: string;
}
/** create-sla-policy */
export interface CreateSlaPolicy {
    /** Metrics to apply to the selected items. */
    metrics?: CreateSupportMetricTarget[];
    /** Human-readable name. */
    name: string;
    selector: CreateSlaSelector;
}
/** create-sla-selector */
export interface CreateSlaSelector {
    /** The item type for which the SLA policy applies. */
    applies_to: SlaSelectorAppliesTo;
    /**
     * The SLA policy applies to the tickets of these parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    parts?: string[];
    /** The SLA policy applies to conversations with these priorities. */
    priority?: SlaSelectorPriority[];
    /** The SLA policy applies to tickets with these severities. */
    severity?: SlaSelectorSeverity[];
    /** The SLA policy applies to conversations with these sources. */
    source_channel?: string[];
    /**
     * Specifies the logical operation to perform between the presence of the
     * specified tags, whether all or any are needed.
     */
    tag_operation?: SlaSelectorTagOperation;
    /**
     * The SLA policy applies to items with these tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/** create-support-metric-target */
export interface CreateSupportMetricTarget {
    /** The metric to apply. */
    metric: string;
    /**
     * The percentage of instances for which this metric's target must not
     * be breached, in order to avoid breaching the overall SLA policy.
     * @format double
     */
    performance: number;
    /**
     * The target value to be achieved, for example the time in which to
     * do something, or the maximum allowed number of message pairs. The
     * units and interpretation of the value is controlled by the
     * properties of the referenced metric.
     * @format int32
     */
    target: number;
    /**
     * The threshold in the same units as target where the metric is
     * considered to be 'at risk'.
     * @format int32
     */
    warning_target?: number;
}
/** credit */
export type Credit = AtomBase & {
    /**
     * Amount that was approved for the credit request. Amount approved is
     * a Dev org construct, only Dev org can decide how much credit amount
     * needs to be approved when a Rev Org has made a credit request. Or
     * how much amount they want to disburse when they are offering
     * credits to their Rev Org (customer).
     * @format double
     */
    amount_approved: number;
    /**
     * Amount expired out of the credits offered. Each Credit
     * offered/requested has a expiry date associated with it. If the
     * credits are unused until the expiry hits, then the amount unused
     * (amount_remaining), gets expired and is not usable after the expiry
     * date. For instance, if 200 credits were requested by Rev from their
     * Dev Org. And their Dev decided to approve half (100 credits) of the
     * amount requested by the Rev with a expiry of one month. And during
     * this one month period Rev was able to use 70 credits only. Then
     * their amount remaining (left credits) would change to 0 and the
     * amount expired would be 30 (as 30 credits were un used when the
     * expiry hit). The amount related fields have following values when
     * expiry time hits amount_requested:200, amount_approved:100,
     * amount_used:70, amount_remaining:0, amount=expired:30.
     * @format double
     */
    amount_expired: number;
    /**
     * Amount remaining out of the credits offered.
     * @format double
     */
    amount_remaining?: number;
    /**
     * Amount requested/disbursed in the credit request.
     * @format double
     */
    amount_requested: number;
    /**
     * Amount that is/was used by the Rev Org (customer) out of the
     * credits offered.
     * @format double
     */
    amount_used?: number;
    /** Reason for requesting/disbursing the Credit. */
    description?: string;
    /**
     * Provides date on which the offered credit amount expires. When the
     * expiry time is hit, then the amount unused (amount_remaining)
     * becomes zero and is considered as amount_expired. Expired credit
     * amount cannot be used.
     * @format date-time
     */
    expiry_time: string;
    /** Indicates whether the credit is expired. */
    is_expired?: boolean;
    /**
     * Name of the credit. (For credits being offered via coupons, credit
     * name would be set depending on coupons name/description to help
     * user in source tracking.).
     */
    name: string;
    rev_org?: OrgSummary;
    /**
     * Status of the credit request. A Dev is allowed to update status for the
     * credit request made by their Rev. Once a credit request status is made
     * as 'approved', no updates are allowed to the credit object after that.
     * When a Dev disburses credits to any of it's Revs, then by default the
     * credit object's status is 'approved', hence no updates are allowed.
     * When a Rev requests credits from their Dev Org, the status of requested
     * credit object is 'awaiting approval' (revs cannot modify the status
     * field, it's a Dev's construct). A Dev can update the status of credit
     * request to approved or rejected.
     */
    status: CreditStatus;
    /**
     * Stripe customer balance transaction id corresponding to the credit
     * request.
     */
    stripe_customer_balance_transaction_id?: string;
    /**
     * Detailed information on the credit utilization. It's a kind of
     * statement, corresponding to a credit object. It contains an array
     * of following [reason_for_usage, used_amount, time_of_usage]
     * regarding credit usage for a given credit object.
     */
    usage_details?: CreditUsageDetails[];
};
/** credit-coupon */
export type CreditCoupon = AtomBase & {
    /**
     * User shareable code of the coupon. To apply coupon this code needs
     * to be entered.
     */
    coupon_code: string;
    /**
     * Total credits to be awarded on redemption of the coupon.
     * @format int32
     */
    credit_amount: number;
    /**
     * Number of days after which credits awarded using this coupon would
     * expire.
     * @format int32
     */
    credit_expiry_duration?: number;
    /**
     * If both credit expiry time and credit expiry duration are set, then the
     * max of both will be taken at the time of applying this coupon, if
     * credit expiry method is set to 'latest'. While min of both would be
     * taken in case of 'earliest' credit expiry method.
     */
    credit_expiry_method?: CreditCouponCreditExpiryMethod;
    /**
     * Timestamp when credits awarded using this coupon would expire.
     * @format date-time
     */
    credit_expiry_time?: string;
    /**
     * The timestamp until when the current coupon is valid.
     * @format date-time
     */
    expiry_time: string;
    /**
     * Rules to be applied for validating the coupon. If no rules are set then
     * coupon can be redeemed by anyone on any sku (Default is yes).
     */
    rules?: CreditCouponRules;
};
/**
 * If both credit expiry time and credit expiry duration are set, then the
 * max of both will be taken at the time of applying this coupon, if
 * credit expiry method is set to 'latest'. While min of both would be
 * taken in case of 'earliest' credit expiry method.
 */
export declare enum CreditCouponCreditExpiryMethod {
    Earliest = "earliest",
    Latest = "latest"
}
/**
 * credit-coupon-rules
 * Rules to be applied for validating the coupon. If no rules are set then
 * coupon can be redeemed by anyone on any sku (Default is yes).
 */
export interface CreditCouponRules {
    /** Email of RevUs which can redeem this coupon. */
    emails?: string[];
    /** RevOs which can redeem this coupon. */
    revs?: OrgSummary[];
    /** SKUs for which this coupon can be redeemed. */
    skus?: SkuSummary[];
}
/** credit-coupon-summary */
export type CreditCouponSummary = AtomBaseSummary;
/** credit-coupons-apply-request */
export interface CreditCouponsApplyRequest {
    /** The coupon's code. */
    coupon_code: string;
    /** Email of Rev User which is trying redeem coupon. */
    email?: string;
    /**
     * Rev Org which is trying to redeem coupon.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org?: string;
    /** Sku for which the coupon is being tried to be redeemed. */
    sku?: string;
}
/** credit-coupons-apply-response */
export interface CreditCouponsApplyResponse {
    credit?: Credit;
}
/** credit-coupons-create-request */
export interface CreditCouponsCreateRequest {
    /**
     * User-shareable code of the coupon. To apply coupon this code needs
     * to be entered.
     */
    coupon_code: string;
    /**
     * Total credits to be awarded on redemption of the coupon.
     * @format int64
     */
    credit_amount: number;
    /**
     * Number of days after which credits awarded using this coupon would
     * expire.
     * @format int64
     */
    credit_expiry_duration?: number;
    /**
     * If both credit expiry time and credit expiry duration are set, then the
     * max of both will be taken at the time of applying this coupon, if
     * credit expiry method is set to 'latest'. While min of both would be
     * taken in case of 'earliest' credit expiry method.
     */
    credit_expiry_method?: CreditCouponCreditExpiryMethod;
    /**
     * Timestamp when credits awarded using this coupon would expire.
     * @format date-time
     */
    credit_expiry_time?: string;
    /**
     * The timestamp till when the current coupon is valid.
     * @format date-time
     */
    expiry_time?: string;
    rules?: CreditCouponsCreateRequestRules;
}
/** credit-coupons-create-request-rules */
export interface CreditCouponsCreateRequestRules {
    /** Emails of Rev users which can redeem this coupon. */
    emails?: string[];
    /**
     * Rev orgs which can redeem this coupon.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_orgs?: string[];
    /** SKUs for which this coupon can be redeemed. */
    skus?: string[];
}
/** credit-coupons-create-response */
export interface CreditCouponsCreateResponse {
    credit_coupon: CreditCoupon;
}
/** credit-coupons-delete-request */
export interface CreditCouponsDeleteRequest {
    /** The coupon's code. */
    coupon_code: string;
}
/** credit-coupons-get-request */
export interface CreditCouponsGetRequest {
    /** The coupon's code. */
    coupon_code: string;
}
/** credit-coupons-get-response */
export interface CreditCouponsGetResponse {
    credit_coupon: CreditCoupon;
}
/** credit-coupons-update-request */
export interface CreditCouponsUpdateRequest {
    /** The coupon's code. */
    coupon_code: string;
    /**
     * Total credits to be awarded on redemption of the coupon.
     * @format int64
     */
    credit_amount?: number;
    /**
     * Number of days after which credits awarded using this coupon would
     * expire.
     * @format int64
     */
    credit_expiry_duration?: number;
    /**
     * If both credit expiry time and credit expiry duration are set, then the
     * max of both will be taken at the time of applying this coupon, if
     * credit expiry method is set to 'latest'. While min of both would be
     * taken in case of 'earliest' credit expiry method.
     */
    credit_expiry_method?: CreditCouponCreditExpiryMethod;
    /**
     * Timestamp when credits awarded using this coupon would expire.
     * @format date-time
     */
    credit_expiry_time?: string;
    /**
     * The timestamp until when the current coupon is valid.
     * @format date-time
     */
    expiry_time?: string;
    rules?: CreditCouponsUpdateRequestRules;
}
/** credit-coupons-update-request-rules */
export interface CreditCouponsUpdateRequestRules {
    emails?: CreditCouponsUpdateRequestRulesEmails;
    rev_orgs?: CreditCouponsUpdateRequestRulesRevOrgs;
    skus?: CreditCouponsUpdateRequestRulesSkus;
}
/** credit-coupons-update-request-rules-emails */
export interface CreditCouponsUpdateRequestRulesEmails {
    /**
     * Rev User's emails to be added to the rules, these will be able to
     * redeem the coupon code once the update succeeds.
     */
    add?: string[];
    /**
     * Rev User's emails to be removed from the rules, these will not be
     * able to redeem the coupon code once the update succeeds.
     */
    remove?: string[];
}
/** credit-coupons-update-request-rules-rev-orgs */
export interface CreditCouponsUpdateRequestRulesRevOrgs {
    /**
     * Rev Orgs to be added to the rules, these will be able to redeem the
     * coupon code once the update succeeds.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    add?: string[];
    /**
     * Rev Orgs to be removed from the rules, these will not be able to
     * redeem the coupon code once the update succeeds.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    remove?: string[];
}
/** credit-coupons-update-request-rules-skus */
export interface CreditCouponsUpdateRequestRulesSkus {
    /**
     * Skus to be added to the rules, coupon code can be applied for these
     * skus once the update succeeds.
     */
    add?: string[];
    /**
     * Skus to be removed from the rules, coupon code will not be
     * applicableon these skus once the update succeeds.
     */
    remove?: string[];
}
/** credit-coupons-update-response */
export interface CreditCouponsUpdateResponse {
    credit_coupon: CreditCoupon;
}
/** credit-coupons-validate-request */
export interface CreditCouponsValidateRequest {
    /** The coupon's code. */
    coupon_code: string;
    /** Email of Rev User which is trying redeem coupon. */
    email?: string;
    /**
     * Rev Org which is trying to redeem coupon.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org?: string;
    /** Sku for which the coupon is being tried to be redeemed. */
    sku?: string;
}
/** credit-coupons-validate-response */
export interface CreditCouponsValidateResponse {
    /**
     * If coupon is valid, number of credits points to be awarded.
     * @format int64
     */
    credit_amount?: number;
}
/**
 * Status of the credit request. A Dev is allowed to update status for the
 * credit request made by their Rev. Once a credit request status is made
 * as 'approved', no updates are allowed to the credit object after that.
 * When a Dev disburses credits to any of it's Revs, then by default the
 * credit object's status is 'approved', hence no updates are allowed.
 * When a Rev requests credits from their Dev Org, the status of requested
 * credit object is 'awaiting approval' (revs cannot modify the status
 * field, it's a Dev's construct). A Dev can update the status of credit
 * request to approved or rejected.
 */
export declare enum CreditStatus {
    Approved = "approved",
    AwaitingApproval = "awaiting_approval",
    Rejected = "rejected"
}
/** credit-summary */
export type CreditSummary = AtomBaseSummary;
/**
 * credit-usage-details
 * Usage detail defines the detailed information on how the credit amount
 * is used. For Example, credit amount $X is used on a invoice.
 */
export interface CreditUsageDetails {
    /**
     * Amount applied for this particular usage.
     * @format double
     */
    amount: number;
    /**
     * The time when credits were used.
     * @format date-time
     */
    transaction_time: string;
    /**
     * Credits are consumed by following - 1. Invoice finalized (applied to
     * invoice) 2. other reasons like offset previous balance, credit note
     * created, etc.
     */
    usage_reason: CreditUsageReason;
}
/**
 * credit-usage-reason
 * Credits are consumed by following - 1. Invoice finalized (applied to
 * invoice) 2. other reasons like offset previous balance, credit note
 * created, etc.
 */
export interface CreditUsageReason {
    invoice_id?: InvoiceSummary;
    /**
     * The consumption reason, it can include invoice_number (if credits
     * were used in invoice), or other reasons such as previous balance
     * offset, etc.
     */
    reason: string;
}
/** credits-create-request */
export interface CreditsCreateRequest {
    /**
     * Requested amount for credit.
     * @format double
     */
    amount_requested: number;
    /** Description of the credit. */
    description?: string;
    /**
     * Timestamp when the credits will expire.
     * @format date-time
     */
    expiry_time?: string;
    /**
     * Name of the credit. (For credits being offered via coupons, credit
     * name would be set depending on coupons name/description to help
     * user in source tracking.)
     */
    name: string;
    /**
     * The rev org for which credits are being created (when dev org is
     * initiating the request, this is mandatory). For rev orgs, raising
     * credit request themselves, this is optional.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
}
/** credits-create-response */
export interface CreditsCreateResponse {
    credit: Credit;
}
/** credits-delete-request */
export interface CreditsDeleteRequest {
    /** The credit object's DON. */
    id: string;
}
/** credits-get-request */
export interface CreditsGetRequest {
    /** The credit object's DON */
    id: string;
}
/** credits-get-response */
export interface CreditsGetResponse {
    credit: Credit;
}
/** credits-list-request */
export interface CreditsListRequest {
    /**
     * Filter items which have expiry date after the timestamp provided.
     * @format date-time
     */
    after_expiry_date?: string;
    /**
     * Filter items which have expiry date before the timestamp provided.
     * @format date-time
     */
    before_expiry_date?: string;
    /** The list of credit object DONs which are to be aggregated. */
    ids?: string[];
    /**
     * The list of rev org DONs which are to be aggregated.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org_ids?: string[];
    /**
     * List of fields to sort the credit objects, by and how to sort them.
     * Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /** The list of status values which are to be aggregated. */
    statuses?: CreditStatus[];
}
/** credits-list-response */
export interface CreditsListResponse {
    /** The list of credit objects. */
    credits: Credit[];
}
/** credits-update-request */
export interface CreditsUpdateRequest {
    /**
     * Approved amount for credit.
     * @format double
     */
    amount_approved?: number;
    /**
     * Requested amount for credit.
     * @format double
     */
    amount_requested?: number;
    /** Description of the credit. */
    description?: string;
    /**
     * Timestamp when the credits will expire.
     * @format date-time
     */
    expiry_time?: string;
    /** The credit object's DON. */
    id: string;
    /**
     * Name of the credit. (For credits being offered via coupons, credit
     * name would be set depending on coupons name/description to help
     * user in source tracking.)
     */
    name?: string;
    /**
     * Status of the credit request. A Dev is allowed to update status for the
     * credit request made by their Rev. Once a credit request status is made
     * as 'approved', no updates are allowed to the credit object after that.
     * When a Dev disburses credits to any of it's Revs, then by default the
     * credit object's status is 'approved', hence no updates are allowed.
     * When a Rev requests credits from their Dev Org, the status of requested
     * credit object is 'awaiting approval' (revs cannot modify the status
     * field, it's a Dev's construct). A Dev can update the status of credit
     * request to approved or rejected.
     */
    status?: CreditStatus;
}
/** credits-update-response */
export interface CreditsUpdateResponse {
    credit: Credit;
}
/**
 * curated-vista
 * Static collection of Devrev objects.
 */
export type CuratedVista = VistaBase & {
    /** Item list to store a curated list of DevRev objects. */
    items?: AtomSummary[];
};
/** custom-object-summary */
export type CustomObjectSummary = AtomBaseSummary;
/** custom-part */
export type CustomPart = PartBase;
/** custom-part-summary */
export type CustomPartSummary = PartBaseSummary;
/** custom-schema-fragment */
export type CustomSchemaFragment = (AppFragment | CustomTypeFragment | TenantFragment) & {
    type: CustomSchemaFragmentType;
};
/** custom-schema-fragment-base */
export type CustomSchemaFragmentBase = AtomBase & {
    /** True if this fragment has been deprecated. */
    deprecated?: boolean;
    /** Description of the custom schema fragment. */
    description?: string;
    /** List of all fields in this custom schema fragment. */
    fields?: FieldDescriptor[];
    /** Type of the custom schema fragment. */
    fragment_type?: CustomSchemaFragmentFragmentType;
    /** Leaf type this fragment applies to. */
    leaf_type?: string;
    new_fragment_ref?: AtomSummary;
    old_fragment_ref?: AtomSummary;
};
/** custom-schema-fragment-base-summary */
export type CustomSchemaFragmentBaseSummary = AtomBaseSummary;
/** Type of the custom schema fragment. */
export declare enum CustomSchemaFragmentFragmentType {
    App = "app",
    CustomType = "custom_type",
    Tenant = "tenant"
}
export declare enum CustomSchemaFragmentType {
    AppFragment = "app_fragment",
    CustomTypeFragment = "custom_type_fragment",
    TenantFragment = "tenant_fragment"
}
/** custom-schema-fragments-get-request */
export interface CustomSchemaFragmentsGetRequest {
    /** The ID of the custom schema fragment. */
    id: string;
}
/** custom-schema-fragments-get-response */
export interface CustomSchemaFragmentsGetResponse {
    fragment: CustomSchemaFragment;
}
/** custom-schema-fragments-list-request */
export interface CustomSchemaFragmentsListRequest {
    /** The list of app names. */
    app?: string[];
    /**
     * The cursor to resume iteration from, otherwise if not provided,
     * then iteration starts from the beginning.
     */
    cursor?: string;
    /** The list of leaf types. */
    leaf_type?: string[];
    /**
     * The maximum number of items.
     * @format int32
     */
    limit?: number;
    /** The list of fields to sort the items by and how to sort them. */
    sort_by?: string[];
    /** The list of subtypes. */
    subtype?: string[];
    /** Filters for custom schema fragment of the provided types. */
    types?: CustomSchemaFragmentType[];
}
/** custom-schema-fragments-list-response */
export interface CustomSchemaFragmentsListResponse {
    /**
     * The cursor to resume iteration from, otherwise if not provided,
     * then iteration starts from the beginning.
     */
    cursor?: string;
    /** The custom schema fragments. */
    result: CustomSchemaFragment[];
}
/** custom-schema-fragments-set-request */
export type CustomSchemaFragmentsSetRequest = (CustomSchemaFragmentsSetRequestAppFragment | CustomSchemaFragmentsSetRequestCustomTypeFragment | CustomSchemaFragmentsSetRequestTenantFragment) & {
    /** True if this fragment has been deprecated. */
    deprecated?: boolean;
    /** The description of the custom schema fragment. */
    description: string;
    /** List of all fields in this fragment. */
    fields?: FieldDescriptor[];
    /** The leaf type this fragment applies to. */
    leaf_type: string;
    type: CustomSchemaFragmentsSetRequestType;
};
/** custom-schema-fragments-set-request-app-fragment */
export interface CustomSchemaFragmentsSetRequestAppFragment {
    /** The app this fragment applies to. */
    app: string;
    /** The name of the app fragment. */
    app_fragment_name: string;
}
/** custom-schema-fragments-set-request-custom-type-fragment */
export interface CustomSchemaFragmentsSetRequestCustomTypeFragment {
    /** List of stock field enum overrides. */
    stock_field_enum_overrides?: StockFieldEnumOverride[];
    /** The string used to populate the subtype in the leaf type. */
    subtype: string;
}
/** custom-schema-fragments-set-request-tenant-fragment */
export type CustomSchemaFragmentsSetRequestTenantFragment = object;
export declare enum CustomSchemaFragmentsSetRequestType {
    AppFragment = "app_fragment",
    CustomTypeFragment = "custom_type_fragment",
    TenantFragment = "tenant_fragment"
}
/** custom-schema-fragments-set-response */
export interface CustomSchemaFragmentsSetResponse {
    /** The ID of the custom schema fragment. */
    id: string;
    /** The ID of the custom schema fragment. */
    id_v1?: string;
}
/** custom-stage-summary */
export type CustomStageSummary = AtomBaseSummary;
/** custom-state-summary */
export type CustomStateSummary = AtomBaseSummary;
/** custom-type-fragment */
export type CustomTypeFragment = CustomSchemaFragmentBase & {
    stage_diagram_id?: AtomSummary;
    /** List of stock field enum overrides. */
    stock_field_enum_overrides?: StockFieldEnumOverride[];
    /** The string used to populate the subtype in the leaf type. */
    subtype?: string;
};
/** custom-type-fragment-summary */
export type CustomTypeFragmentSummary = CustomSchemaFragmentBaseSummary;
/** custom-work */
export type CustomWork = WorkBase;
/** custom-work-summary */
export type CustomWorkSummary = WorkBaseSummary;
/**
 * data-collection-app-settings
 * Configuration knobs for discovery application per devorg.
 */
export interface DataCollectionAppSettings {
    /**
     * Optionally set schedule for data collection interval in minutes. If
     * not defined default is used.
     * @format int32
     */
    data_collection_interval_minutes?: number;
    /**
     * Optionally set maximum Git coroutines. If not defined default is
     * used.
     * @format int32
     */
    git_max_coroutines?: number;
    /**
     * Optionally set maximum GitHub coroutine. If not defined default is
     * useds.
     * @format int32
     */
    github_max_coroutines?: number;
    /**
     * Optionally set maximum GitHub repository size in MB. If not defined
     * default is used.
     * @format int32
     */
    max_repo_size_mb?: number;
}
/** dataset-get-request */
export interface DatasetGetRequest {
    /**
     * End date at which to end the dataset.
     * @format date-time
     */
    end_date: string;
    /** Query ID to get the dataset for. */
    query_id: string;
    /**
     * Start date from which to start the dataset.
     * @format date-time
     */
    start_date: string;
}
/** dataset-get-response */
export interface DatasetGetResponse {
    /** The dataset for the request. */
    dataset: object[];
    /**
     * Last updated timestamp for the dataset.
     * @format date-time
     */
    last_updated_at: string;
    /** Metadata for the dataset. */
    metadata: object;
}
/**
 * date-filter
 * Provides ways to specify date ranges on objects.
 */
export type DateFilter = (DateTimeFilter | DateTimePreset) & {
    /** Type of date filter. */
    type: DateFilterType;
};
/** Type of date filter. */
export declare enum DateFilterType {
    Preset = "preset",
    Range = "range"
}
/** date-time-filter */
export interface DateTimeFilter {
    /**
     * Filters for objects created after the provided timestamp
     * (inclusive).
     * @format date-time
     */
    after?: string;
    /**
     * Filters for objects created before the provided timestamp
     * (inclusive).
     * @format date-time
     */
    before?: string;
}
/**
 * date-time-preset
 * Provides preset types for date filter.
 */
export type DateTimePreset = (DateTimePresetLastNDays | DateTimePresetNextNDays) & {
    /** Type of date preset. */
    preset_type: DateTimePresetType;
};
/** date-time-preset-last-n-days */
export interface DateTimePresetLastNDays {
    /**
     * The range starts from the current timestamp and continues for the
     * past n days.
     * @min 0
     * @max 4294967295
     */
    days: number;
}
/** date-time-preset-next-n-days */
export interface DateTimePresetNextNDays {
    /**
     * The range starts from the current timestamp and continues for the
     * next n days.
     * @min 0
     * @max 4294967295
     */
    days: number;
}
/** Type of date preset. */
export declare enum DateTimePresetType {
    LastNDays = "last_n_days",
    NextNDays = "next_n_days"
}
/** delete-discovery-profile-request */
export interface DeleteDiscoveryProfileRequest {
    /** Discovery Profile unique ID. */
    profile_id: string;
}
/** delete-discovery-profile-response */
export type DeleteDiscoveryProfileResponse = object;
/** delete-discovery-settings-request */
export interface DeleteDiscoverySettingsRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** delete-discovery-settings-response */
export type DeleteDiscoverySettingsResponse = object;
/** delete-recurring-line-items */
export interface DeleteRecurringLineItems {
    /** Recurring line item to be deleted from the service plan. */
    recurring_line_item_id: string;
}
/** dev-org */
export type DevOrg = OrgBase & {
    /** Auth0 Org ID of the DevOrg. */
    auth0_org_id?: string;
    /** IDs of Auth0 connection available for this DevOrg. */
    available_org_connections?: string[];
    /** Customer chosen URL slug for the DevOrg. */
    dev_slug: string;
};
/**
 * dev-org-auth-connections-create-request
 * Request to create a new enterprise authentication connection.
 */
export type DevOrgAuthConnectionsCreateRequest = (AuthConnectionOptionsAzureAd | AuthConnectionOptionsGoogleApps | AuthConnectionOptionsOidc | AuthConnectionOptionsSaml) & {
    /**
     * Display name of the authentication connection. This name will be
     * visible to all the users when they sign in to this Dev
     * organization. For example, if the display_name is 'abclogin', then
     * it would appear on the login button as 'Log in to abclogin'.
     */
    display_name?: string;
    /**
     * Defines the type for the authentication connection. Different types of
     * authentication connections have different configuration parameters.
     */
    type: DevOrgAuthConnectionsCreateRequestType;
};
/**
 * Defines the type for the authentication connection. Different types of
 * authentication connections have different configuration parameters.
 */
export declare enum DevOrgAuthConnectionsCreateRequestType {
    GoogleApps = "google_apps",
    Oidc = "oidc",
    Samlp = "samlp",
    Waad = "waad"
}
/**
 * dev-org-auth-connections-create-response
 * Response for the request to create a new enterprise authentication
 * connection.
 */
export interface DevOrgAuthConnectionsCreateResponse {
    /**
     * Connection object that specifies the configuration for an
     * authentication connection that is set up for a Dev organization.
     */
    auth_connection: AuthConnection;
}
/**
 * dev-org-auth-connections-delete-request
 * Request to delete an enterprise authentication connection for a Dev
 * organization. A default connection and a connection which is currently
 * enabled cannot be deleted.
 */
export interface DevOrgAuthConnectionsDeleteRequest {
    /** ID of the authentication connection to be deleted. */
    id: string;
}
/**
 * dev-org-auth-connections-get-request
 * Request to get configuration details of organization's authentication
 * Connection.
 */
export interface DevOrgAuthConnectionsGetRequest {
    /** ID of the authentication connection. */
    id: string;
}
/**
 * dev-org-auth-connections-get-response
 * Response object encapsulating the configuration details of an
 * authentication connection.
 */
export interface DevOrgAuthConnectionsGetResponse {
    /**
     * Connection object that specifies the configuration for an
     * authentication connection that is set up for a Dev organization.
     */
    auth_connection: AuthConnection;
}
/**
 * dev-org-auth-connections-list-response
 * Response object for the request to list all the social and enterprise
 * authentication connections configured for a Dev organization.
 */
export interface DevOrgAuthConnectionsListResponse {
    /**
     * List of all the authentication connections currently configured for
     * a Dev organization.
     */
    auth_connections: AuthConnection[];
}
/**
 * dev-org-auth-connections-toggle-request
 * Request to enable or disable an authentication connection for a Dev
 * organization.
 */
export interface DevOrgAuthConnectionsToggleRequest {
    /** ID of the authentication connection to be toggled. */
    id: string;
    toggle?: AuthConnectionToggle;
}
/**
 * dev-org-auth-connections-update-request
 * Request to update an enterprise authentication connection for a Dev
 * organization.
 */
export type DevOrgAuthConnectionsUpdateRequest = (AuthConnectionOptionsAzureAd | AuthConnectionOptionsGoogleApps | AuthConnectionOptionsOidc | AuthConnectionOptionsSaml) & {
    /**
     * New display name of the authentication connection. This name will
     * be visible to all the users when they sign in to this Dev
     * organization. For example, if the display_name is 'abclogin', then
     * it would appear on the login button as 'Log in to abclogin'.
     */
    display_name?: string;
    /** ID of the authentication connection which is to be updated. */
    id: string;
    /**
     * Specifies the type for the authentication connection. Different types
     * of authentication connections have different configuration parameters
     * that can be updated.
     */
    type: DevOrgAuthConnectionsUpdateRequestType;
};
/**
 * Specifies the type for the authentication connection. Different types
 * of authentication connections have different configuration parameters
 * that can be updated.
 */
export declare enum DevOrgAuthConnectionsUpdateRequestType {
    GoogleApps = "google_apps",
    None = "none",
    Oidc = "oidc",
    Samlp = "samlp",
    Waad = "waad"
}
/**
 * dev-org-auth-connections-update-response
 * Response for the request to update an enterprise authentication
 * connection.
 */
export interface DevOrgAuthConnectionsUpdateResponse {
    /**
     * Connection object that specifies the configuration for an
     * authentication connection that is set up for a Dev organization.
     */
    auth_connection: AuthConnection;
}
/**
 * dev-org-public-info-request
 * Request object to get public information of a Dev organization.
 */
export interface DevOrgPublicInfoRequest {
    /** Slug of the Dev organization. */
    slug: string;
}
/**
 * dev-org-public-info-response
 * Public information of a Dev organization.
 */
export interface DevOrgPublicInfoResponse {
    /** Auth0 org ID of the Dev organization. */
    auth0_org_id: string;
}
/** dev-org-summary */
export type DevOrgSummary = OrgBaseSummary & {
    /** Customer chosen URL slug for the DevOrg. */
    dev_slug: string;
};
/**
 * dev-orgs-create-request
 * A request to create a new Dev organization.
 */
export interface DevOrgsCreateRequest {
    /**
     * The coupon codes to be applied to give credits to the Dev
     * organization.
     */
    credit_coupon_codes?: string[];
    /** Custom prefix for Dev organization ID. */
    dev_org_id_prefix?: string;
    /** Customer chosen URL slug. */
    dev_slug?: string;
    /** Display name of the new Dev organization. */
    display_name?: string;
    /** The environment of the Org. Defaults to 'production' if not specified. */
    environment?: OrgEnvironment;
    /** Whether the Dev organization allows access based on email domain. */
    give_domain_access?: boolean;
    /** Create object for service plan. */
    service_plan?: DevOrgsCreateRequestCreateServicePlan;
    /** UTM parameters for the Dev organization. */
    utm?: DevOrgsCreateRequestUTM;
}
/**
 * dev-orgs-create-request-create-service-plan
 * Create object for service plan.
 */
export interface DevOrgsCreateRequestCreateServicePlan {
    /**
     * Service plan line item details for creating the service plan as
     * part of the Dev organization onboarding.
     */
    service_plan_line_items?: DevOrgsCreateRequestCreateServicePlanCreateServicePlanLineItem[];
}
/**
 * dev-orgs-create-request-create-service-plan-create-service-plan-line-item
 * Create object for service plan line item.
 */
export interface DevOrgsCreateRequestCreateServicePlanCreateServicePlanLineItem {
    /** The sku family name detail to be included in the service plan. */
    sku_family_name: string;
}
/**
 * dev-orgs-create-request-u-t-m
 * UTM parameters for the Dev organization.
 */
export interface DevOrgsCreateRequestUTM {
    /** UTM campaign for the Dev organization. */
    campaign?: string;
    /** UTM content for the Dev organization. */
    content?: string;
    /** UTM medium for the Dev organization. */
    medium?: string;
    /** UTM source for the Dev organization. */
    source?: string;
    /** UTM term for the Dev organization. */
    term?: string;
}
/**
 * dev-orgs-create-response
 * The response to creating a new Dev organization.
 */
export interface DevOrgsCreateResponse {
    dev_org: DevOrg;
    dev_user: DevUser;
}
/**
 * dev-orgs-delete-request
 * A request to delete a Dev organization.
 */
export type DevOrgsDeleteRequest = object;
/**
 * dev-orgs-delete-response
 * The response to delete a Dev organization.
 */
export type DevOrgsDeleteResponse = object;
/**
 * dev-orgs-get-request
 * A request to get a Dev organization's information.
 */
export type DevOrgsGetRequest = object;
/**
 * dev-orgs-get-response
 * The response to get a Dev organization's information.
 */
export interface DevOrgsGetResponse {
    dev_org: DevOrg;
}
/**
 * dev-orgs-invites-create-request
 * A request to create an invitation for a user to the Dev organization.
 */
export interface DevOrgsInvitesCreateRequest {
    /** Email address of the user being invited. */
    email: string;
}
/**
 * dev-orgs-invites-create-response
 * A response to create an invitation for a user to the Dev organization.
 */
export interface DevOrgsInvitesCreateResponse {
    invite: DevuInvite;
}
/**
 * dev-orgs-invites-list-request
 * A request to get the list of invitations for the Dev organization.
 */
export interface DevOrgsInvitesListRequest {
    /** Filters invitations to those created by the specified users. */
    created_by_ids?: string[];
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of invited users to be retrieved.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Fields to sort the invites by and the direction to sort them. */
    sort_by?: string[];
    /** Array of state values to be filtered. */
    state?: DevuInviteState[];
}
/**
 * dev-orgs-invites-list-response
 * The response to listing the Dev organization invitations.
 */
export interface DevOrgsInvitesListResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** The list of invited users. */
    invites: DevuInvite[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * dev-orgs-join-request
 * A request to get the invitation link for joining the Dev organization
 * for which domain-based access is allowed.
 */
export interface DevOrgsJoinRequest {
    /**
     * The globally unique ID of the DevRev organization.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    id: string;
}
/**
 * dev-orgs-join-response
 * The response to get the invitation link for joining the Dev
 * organization.
 */
export interface DevOrgsJoinResponse {
    /** The short-lived invitation link to join the Dev organization. */
    invitation_link: string;
}
/**
 * dev-orgs-list-request
 * A request to get the list of Dev organizations for the authenticated
 * user.
 */
export interface DevOrgsListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Whether to list the Dev organizations available to join without
     * invitation.
     */
    is_available?: boolean;
    /**
     * The number of Dev organizations to be retrieved.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Fields to sort the Dev organizations by and the direction to sort
     * them.
     */
    sort_by?: string[];
}
/**
 * dev-orgs-list-response
 * The response to get the list of Dev organizations for the authenticated
 * user.
 */
export interface DevOrgsListResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** List of Dev organizations. */
    dev_orgs: DevOrg[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * dev-orgs-self-get-request
 * A request to get the authenticated user's Dev organization.
 */
export type DevOrgsSelfGetRequest = object;
/**
 * dev-orgs-self-get-response
 * The response to getting the Dev organization for the authenticated
 * user.
 */
export interface DevOrgsSelfGetResponse {
    dev_org: DevOrg;
}
/**
 * dev-orgs-update-request
 * A request to update a Dev organization's information.
 */
export interface DevOrgsUpdateRequest {
    /** Display name of the new Dev organization. */
    display_name?: string;
    /** The environment of the Org. Defaults to 'production' if not specified. */
    environment?: OrgEnvironment;
    /**
     * Artifact ID of the Dev organization's logo.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    logo_id?: string | null;
}
/**
 * dev-orgs-update-response
 * The response to update a Dev organization's information.
 */
export interface DevOrgsUpdateResponse {
    dev_org: DevOrg;
}
/**
 * dev-rev-partitioner-merger
 * Configuration knobs for partitioners and partition mergers.
 */
export interface DevRevPartitionerMerger {
    /** Discovery partitioner/partition merger configuration. */
    config?: object;
    /** Discovery Dev partitioner/merger. */
    dev?: string;
    /** Discovery Rev partitioner/merger. */
    rev?: string;
}
/** dev-user */
export type DevUser = UserBase & {
    /** A representation of a postal address. */
    address?: PostalAddress;
    /** IDs of the auth0 users this Dev User account is linked with. */
    auth0_user_ids?: string[];
    /** IDs of the Dev User outside the DevRev SOR. */
    external_identities?: ExternalIdentity[];
    /** Job title of the Dev User. */
    job_title?: DevUserJobTitle;
    /** Phone numbers of the Dev User. */
    phone_number?: PhoneNumber[];
    /** Reference of the DevRev Profile this Dev User is linked to. */
    profile_id?: string;
    /** Status of the user. */
    status?: Status;
    /**
     * Time when the terms and conditions were accepted.
     * @format date-time
     */
    terms_conditions_accept_at?: string;
    /** Flag to denote if terms and conditions have been accepted. */
    terms_conditions_accepted?: boolean;
};
/** dev-user-invitation */
export interface DevUserInvitation {
    dev_org: DevOrgSummary;
    /**
     * Time at which the invitation link expires.
     * @format date-time
     */
    expires_at?: string;
    /**
     * Invitation link used to accept the invitation to a Dev
     * organization.
     */
    invitation_link?: string;
    inviter?: UserSummary;
}
/** Job title of the Dev User. */
export declare enum DevUserJobTitle {
    Cxo = "cxo",
    Designer = "designer",
    Developer = "developer",
    Operations = "operations",
    Others = "others",
    ProductManager = "product_manager",
    Qa = "qa",
    Support = "support",
    TechLead = "tech_lead"
}
/** dev-user-summary */
export type DevUserSummary = UserBaseSummary;
/**
 * dev-user-update-display-picture-request
 * A request to update the display picture of a Dev user
 */
export interface DevUserUpdateDisplayPictureRequest {
    /**
     * Artifact ID of the user's uploaded display picture, otherwise if
     * 'null', then the user's display picture is cleared.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture: string | null;
}
/**
 * dev-user-update-display-picture-response
 * The response to update the display picture of a Dev user.
 */
export type DevUserUpdateDisplayPictureResponse = object;
/**
 * dev-users-check-phone-number-code-request
 * A request to check a verification code for a phone number.
 */
export interface DevUsersCheckPhoneNumberCodeRequest {
    /** The phone number to check the verification code for. */
    phone_number: string;
    /** The verification code to check. */
    verification_code: string;
}
/**
 * dev-users-check-phone-number-code-response
 * The response to check a verification code for a phone number.
 */
export interface DevUsersCheckPhoneNumberCodeResponse {
    /** Whether the verification code is valid. */
    is_valid: boolean;
}
/**
 * dev-users-deactivate-request
 * A request to deactivate the Dev user.
 */
export interface DevUsersDeactivateRequest {
    /** The ID for the DevUser. */
    id: string;
}
/**
 * dev-users-deactivate-response
 * The response to deactivate the Dev user.
 */
export type DevUsersDeactivateResponse = object;
/**
 * dev-users-delete-request
 * A request to delete the Dev user.
 */
export interface DevUsersDeleteRequest {
    /** The ID for the DevUser. */
    id: string;
}
/**
 * dev-users-delete-response
 * The response to delete the Dev user.
 */
export type DevUsersDeleteResponse = object;
/**
 * dev-users-get-request
 * A request to get a Dev user's information.
 */
export interface DevUsersGetRequest {
    /** User ID of the requested Dev user. */
    id: string;
}
/**
 * dev-users-get-response
 * The response to getting the information for the Dev user.
 */
export interface DevUsersGetResponse {
    dev_user: DevUser;
}
/**
 * dev-users-identities-link-request
 * Request to link external identity to a Dev user.
 */
export interface DevUsersIdentitiesLinkRequest {
    /**
     * Signed JWT token containing verified identity of the user on
     * external identity source.
     */
    secondary_identity_token: string;
}
/**
 * dev-users-identities-link-response
 * Response for the request to link an external identity to a Dev user.
 */
export interface DevUsersIdentitiesLinkResponse {
    dev_user: DevUser;
}
/**
 * dev-users-is-display-handle-available-request
 * A request to check if a display handle is available for the
 * authenticated user or not.
 */
export interface DevUsersIsDisplayHandleAvailableRequest {
    /** Display handle to be checked for availability. */
    display_handle: string;
}
/**
 * dev-users-is-display-handle-available-response
 * Response object to display handle availability check request.
 */
export interface DevUsersIsDisplayHandleAvailableResponse {
    /** Whether the display handle is available. */
    is_available: boolean;
}
/**
 * dev-users-list-request
 * A request to get the list of Dev user's information.
 */
export interface DevUsersListRequest {
    /**
     * Filters list of Dev users which are created by specified list of
     * Dev user IDs.
     */
    created_by?: string[];
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /** Filters Dev users based on email addresses. */
    email?: string[];
    /** Filters Dev users based on job titles. */
    job_title?: DevUserJobTitle[];
    /**
     * The maximum number of Dev users to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Fields to sort the Dev users by and the direction to sort them. */
    sort_by?: string[];
    /** Filters Dev users based on state. */
    state?: UserState[];
}
/**
 * dev-users-list-response
 * The response to listing the Dev users.
 */
export interface DevUsersListResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** The list of Dev users. */
    dev_users: DevUser[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * dev-users-logout-request
 * The request to logout from a Dev organization.It unregisters the device
 * for notifications and deletes the token from STS.
 */
export interface DevUsersLogoutRequest {
    /** The unique identifier for the token under a given Dev organization. */
    auth_token_id?: string;
    /** The unique identifier of the device. */
    device_id: string;
}
/**
 * dev-users-merge-request
 * Request object for DevUsersMerge call.
 */
export interface DevUsersMergeRequest {
    /** The unique ID of the primary user. */
    primary_user: string;
    /** The unique ID of the secondary user. */
    secondary_user: string;
}
/**
 * dev-users-merge-response
 * The response to DevUsersMerge call.
 */
export type DevUsersMergeResponse = object;
/**
 * dev-users-post-login-request
 * Request object for DevUsersPostLogin call.
 */
export type DevUsersPostLoginRequest = object;
/**
 * dev-users-post-login-response
 * Response object for post-login request.
 */
export interface DevUsersPostLoginResponse {
    /** Whether a new access token is to be fetched. */
    refetch_id_token: boolean;
}
/**
 * dev-users-self-delete-request
 * A request to delete the authenticated user.
 */
export type DevUsersSelfDeleteRequest = object;
/**
 * dev-users-self-delete-response
 * The response to delete the authenticated user.
 */
export type DevUsersSelfDeleteResponse = object;
/**
 * dev-users-self-request
 * A request to get the authenticated user's information.
 */
export type DevUsersSelfRequest = object;
/**
 * dev-users-self-response
 * The response to getting the information for the authenticated user.
 */
export interface DevUsersSelfResponse {
    dev_user: DevUser;
}
/**
 * dev-users-self-update-request
 * A request to update the user's information for the authenticated Dev
 * user.
 */
export interface DevUsersSelfUpdateRequest {
    /**
     * The updated display handle of the Dev user.
     * @deprecated
     */
    display_handle?: string;
    /** The updated display name of the Dev user. */
    display_name?: string;
    /**
     * Artifact ID of a Dev user's display picture.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture_id?: string | null;
    /** The updated full name of the Dev user. */
    full_name?: string;
    /** Job title of the Dev User. */
    job_title?: DevUserJobTitle;
    /** Status of the user. */
    status?: Status;
    /** If the Dev user has accepted terms and conditions. */
    terms_conditions_accepted?: boolean;
}
/**
 * dev-users-send-phone-number-code-request
 * A request to send a verification code to a phone number.
 */
export interface DevUsersSendPhoneNumberCodeRequest {
    /** The phone number to send the verification code to. */
    phone_number: string;
}
/**
 * dev-users-send-phone-number-code-response
 * The response to send a verification code to a phone number.
 */
export type DevUsersSendPhoneNumberCodeResponse = object;
/**
 * dev-users-update-request
 * A request to update the user's information corresponding to input Dev
 * user ID.
 */
export interface DevUsersUpdateRequest {
    /**
     * The updated display handle of the Dev user.
     * @deprecated
     */
    display_handle?: string;
    /** The updated display name of the Dev user. */
    display_name?: string;
    /**
     * Artifact ID of a Dev user's display picture.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture_id?: string | null;
    /** The updated full name of the Dev user. */
    full_name?: string;
    /** The ID for the DevUser to be updated. */
    id: string;
    /** Job title of the Dev User. */
    job_title?: DevUserJobTitle;
    /** Status of the user. */
    status?: Status;
}
/**
 * dev-users-update-response
 * The response to update a Dev user.
 */
export interface DevUsersUpdateResponse {
    dev_user: DevUser;
}
/**
 * devrev-enum-group
 * Enum group information.
 */
export interface DevrevEnumGroup {
    /** enum group key. */
    group_key?: string;
    /** true if header is visible. */
    is_header_visible?: boolean;
    /** label of the field. */
    label?: string;
}
/** devrev-profile */
export type DevrevProfile = UserBase & {
    /** Professional biography of the user. */
    bio?: string;
    /**
     * Brief description of the user's professional experience or
     * interests.
     */
    headline?: string;
    /** Visibility of the profile to other users. */
    visibility?: DevrevProfileVisibility;
};
/** devrev-profile-summary */
export type DevrevProfileSummary = UserBaseSummary;
/** Visibility of the profile to other users. */
export declare enum DevrevProfileVisibility {
    Private = "private",
    Public = "public"
}
/** devrev-reminder */
export type DevrevReminder = NotificationBase & {
    /**
     * Time at which reminder was created.
     * @format date-time
     */
    created_at?: string;
    /** Message included with reminder. */
    message?: string;
    /** The objects referenced in the message. */
    references?: AtomSummary[];
};
/** devrev-reminder-summary */
export type DevrevReminderSummary = NotificationBaseSummary;
/** devu-invite */
export type DevuInvite = AtomBase & {
    /** Email address of the user. */
    email?: string;
    /**
     * Time at which invite link expires.
     * @format date-time
     */
    expires_at?: string;
    /** Invitation Id of the invite sent to user. */
    invitation_id?: string;
    /** Invitaion link associated with given email. */
    invitation_link?: string;
    /** State of the invite. */
    state?: DevuInviteState;
};
/** State of the invite. */
export declare enum DevuInviteState {
    Accepted = "accepted",
    Deleted = "deleted",
    Expired = "expired",
    Pending = "pending"
}
/** devu-invite-summary */
export type DevuInviteSummary = AtomBaseSummary;
/**
 * discovery-app-settings
 * Configuration knobs for discovery application per devorg.
 */
export interface DiscoveryAppSettings {
    /**
     * Optionally set schedule for discovery run interval in minutes. If
     * not defined default is used.
     * @format int32
     */
    discovery_run_interval_minutes?: number;
    /**
     * Optionally set rate limit count in window. If not defined default
     * is used.
     * @format int32
     */
    rate_limit_count_in_window?: number;
}
/** discovery-event-base-summary */
export type DiscoveryEventBaseSummary = AtomBaseSummary;
/** discovery-git-commit-summary */
export type DiscoveryGitCommitSummary = DiscoveryEventBaseSummary;
/** discovery-git-event-summary */
export type DiscoveryGitEventSummary = DiscoveryEventBaseSummary;
/**
 * discovery-github-repos-settings
 * Configuration knobs for GitHub repositories for devorg.
 */
export interface DiscoveryGithubReposSettings {
    /** Repos that are excluded are part of this list. */
    exclude?: string[];
    /** Repos that are included are part of this list. */
    include?: string[];
    /** Name of the organization for GitHub repository. */
    organization?: string;
    /** Enum for repositories status for inclusion and exclusion. */
    repos_status?: DiscoveryGithubReposSettingsReposStatus;
}
/** Enum for repositories status for inclusion and exclusion. */
export declare enum DiscoveryGithubReposSettingsReposStatus {
    All = "all",
    Exclude = "exclude",
    Include = "include"
}
/** discovery-profile */
export type DiscoveryProfile = AtomBase & {
    /** Configuration knobs for extractors. */
    extractors?: Extractors;
    /** Configuration knobs for partitioners and partition mergers. */
    mergers?: DevRevPartitionerMerger;
    /**
     * Optionally allow to specify a different devorg's data as source. If
     * missing current devorg is used.
     */
    other_data_source_devorg?: string;
    /**
     * Optionally allow to specify a different devorg's data as source. If
     * missing current devorg is used.
     */
    other_data_source_devorg_v1?: string;
    /** Configuration knobs for partitioners and partition mergers. */
    partitioners?: DevRevPartitionerMerger;
    /** Name of the Discovery profile. */
    profile_name?: string;
};
/** discovery-profile-summary */
export type DiscoveryProfileSummary = AtomBaseSummary;
/** discovery-run */
export type DiscoveryRun = AtomBase & {
    /**
     * Set discovery run end time.
     * @format date-time
     */
    completed_at?: string;
    /** Optionally set failure information if discovery run fail. */
    failure_info?: string;
    /** Optionally set if discovery is scheduled. */
    is_scheduled?: boolean;
    /**
     * Optionally set next status time. This would be helpful for client
     * to decide when next get status call should be made.
     * @format date-time
     */
    next_status_at?: string;
    /** Discovery profile summary. */
    profile?: ProfileSummary;
    /**
     * Limit the use of the sources defined in the default profile to the
     * ones specified in this list. If this field is not provided, attempt
     * to use every source defined in the default profile.
     */
    selected_sources?: string[];
    /** Discovery sources information. */
    sources_status?: SourceDetails[];
    /**
     * Set discovery run start time.
     * @format date-time
     */
    started_at?: string;
    /** Enum for discovery run status. */
    status?: DiscoveryRunStatus;
    /** Set discovery run triggered by User. */
    triggered_by?: string;
    /** Set discovery run triggered by User. */
    triggered_by_v1?: string;
};
/** Enum for discovery run status. */
export declare enum DiscoveryRunStatus {
    Failed = "failed",
    Running = "running",
    Started = "started",
    Success = "success"
}
/** discovery-run-summary */
export type DiscoveryRunSummary = AtomBaseSummary;
/** discovery-settings */
export type DiscoverySettings = AtomBase & {
    /** Configuration knobs for discovery application per devorg. */
    data_collection_app_settings?: DataCollectionAppSettings;
    /** Configuration knobs for discovery application per devorg. */
    discovery_app_settings?: DiscoveryAppSettings;
    /** Optionally allow to specify profile Id associated with the devorg. */
    discovery_profile_id?: string;
    /** Optionally allow to specify profile Id associated with the devorg. */
    discovery_profile_id_v1?: string;
    /** Discovery GitHub repositories settings for devorg. */
    github_repos?: DiscoveryGithubReposSettings[];
};
/** discovery-settings-summary */
export type DiscoverySettingsSummary = AtomBaseSummary;
/** discovery-source */
export interface DiscoverySource {
    /**
     * Timestamp at which the data was last captured for this source.
     * @format date-time
     */
    last_captured_timestamp: string;
    /**
     * Size of the data, in bytes, that was collected for this source.
     * @format int64
     */
    size_bytes?: number;
    /** Name of the source used for parts discovery. */
    source_name: PartsDiscoverySourceName;
}
/**
 * dns-record
 * DNS record.
 */
export interface DnsRecord {
    /** Name of the DNS record. */
    name?: string;
    /** Type of DNS record. */
    type?: DnsRecordType;
    /** Value of the DNS record. */
    value?: string;
}
/** Type of DNS record. */
export declare enum DnsRecordType {
    Cname = "cname",
    Txt = "txt"
}
/**
 * doc-field
 * Docs Field details.
 */
export interface DocField {
    /** Type of doc. */
    doc_type?: string;
    /** Title text for the url. */
    title?: string;
    /** URL for the field. */
    url?: string;
}
/**
 * domain-identities-create-request
 * The request for creating domain identity.
 */
export interface DomainIdentitiesCreateRequest {
    /** Domain for which identity needs to be created. */
    domain: string;
    /** The ID of the keyring to be used for storing domain identities. */
    keyring: string;
}
/**
 * domain-identities-create-response
 * The response for create domain identity.
 */
export interface DomainIdentitiesCreateResponse {
    /** DNS Records for domain identity verification. */
    dns_records: DnsRecord[];
}
/**
 * domain-identities-sync-request
 * The request for syncing the domain identity information.
 */
export interface DomainIdentitiesSyncRequest {
    /** Domain for which identity information needs to be synced. */
    domain: string;
    /** The ID of the keyring having domain identity information. */
    keyring: string;
}
/**
 * domain-identities-sync-response
 * The response for sync domain identity.
 */
export interface DomainIdentitiesSyncResponse {
    /** Domain Verification status. */
    status: DomainVerificationStatus;
}
/**
 * domain-verification-status
 * Domain Verification status.
 */
export interface DomainVerificationStatus {
    /** Status of the identity. */
    value?: DomainVerificationStatusValue;
}
/** Status of the identity. */
export declare enum DomainVerificationStatusValue {
    Failed = "failed",
    NotStarted = "not_started",
    Pending = "pending",
    Success = "success",
    TemporaryFailure = "temporary_failure"
}
/**
 * duration
 * Duration encapsulates the value of the duration and the type of the
 * duration. For example, 1 day where value is '1' and type is 'day'.
 */
export interface Duration {
    /** Type defines the type of the duration. */
    type?: DurationType;
    /**
     * Value defines the value of the duration.
     * @format int32
     */
    value?: number;
}
/** Type defines the type of the duration. */
export declare enum DurationType {
    Day = "day",
    Hour = "hour",
    Minute = "minute",
    Month = "month",
    OneTime = "one_time",
    Year = "year"
}
/**
 * dynamic-vista
 * Dynamic collection of Devrev objects, all adhering to a specific
 * filter.
 */
export type DynamicVista = VistaBase & (DynamicVistaConversationsVista | DynamicVistaPartsVista | DynamicVistaRevOrgsVista | DynamicVistaWorksVista) & {
    /** Type of DevRev object for which the vista is applicable. */
    filter_type: DynamicVistaFilterType;
};
/** dynamic-vista-conversations-vista */
export interface DynamicVistaConversationsVista {
    filter: DynamicVistaConversationsVistaFilter;
    /** Pinned items associated with the vista. */
    items?: DynamicVistaConversationsVistaItemValue[];
}
/** dynamic-vista-conversations-vista-filter */
export interface DynamicVistaConversationsVistaFilter {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    /** Filters for conversations belonging to any of the provided parts. */
    applies_to_parts_v1?: string;
    created_date?: DateTimeFilter;
    /** The field to group the collection by. */
    group_by?: string;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    /** Filters for conversations where these users are participants. */
    members_v1?: string;
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /** Filters for conversations owned by any of these users. */
    owned_by_v1?: string;
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     */
    rev_org_v1?: string;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /** Filters for conversations with any of the provided tags. */
    tags_v1?: string;
}
/** dynamic-vista-conversations-vista-item-value */
export interface DynamicVistaConversationsVistaItemValue {
    item: ConversationSummary;
}
/** Type of DevRev object for which the vista is applicable. */
export declare enum DynamicVistaFilterType {
    Conversations = "conversations",
    Parts = "parts",
    RevOrgs = "rev_orgs",
    Works = "works"
}
/** dynamic-vista-parts-vista */
export interface DynamicVistaPartsVista {
    filter: DynamicVistaPartsVistaFilter;
    /** Pinned items associated with the vista. */
    items?: DynamicVistaPartsVistaItemValue[];
}
/** dynamic-vista-parts-vista-filter */
export interface DynamicVistaPartsVistaFilter {
    /** Filters for parts of the provided categories. */
    categories?: PartCategory[];
    created_date?: DateTimeFilter;
    enhancement?: PartsFilterEnhancement;
    /** The field to group the collection by. */
    group_by?: string;
    modified_date?: DateTimeFilter;
    /** Filters for parts of the provided name(s). */
    name?: string[];
    /**
     * Filters for parts owned by any of the provided users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Filters for parts owned by any of the provided users. */
    owned_by_ids_v1?: string;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for part with any of the provided states. */
    state?: string[];
    /**
     * Filters for parts with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /** Filters for parts with any of the provided tags. */
    tag_ids_v1?: string;
    /** Filters for parts of the provided type(s). */
    type?: PartType[];
    /**
     * Filters for parts of the provided type(s).
     * @deprecated
     */
    types?: PartType[];
}
/** dynamic-vista-parts-vista-item-value */
export interface DynamicVistaPartsVistaItemValue {
    item: PartSummary;
}
/** dynamic-vista-rev-orgs-vista */
export interface DynamicVistaRevOrgsVista {
    filter: DynamicVistaRevOrgsVistaFilter;
    /** Pinned items associated with the vista. */
    items?: DynamicVistaRevOrgsVistaItemValue[];
}
/** dynamic-vista-rev-orgs-vista-filter */
export interface DynamicVistaRevOrgsVistaFilter {
    /** Filters by account. */
    account?: string[];
    /** Filters by account. */
    account_v1?: string;
    /** Filters by creator. */
    created_by?: string[];
    /** Filters by creator. */
    created_by_v1?: string;
    created_date?: DateTimeFilter;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    /** The field to group the collection by. */
    group_by?: string;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** Filters by owners. */
    owned_by_ids_v1?: string;
    /** Filters by owners. */
    owned_by_v1?: string;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/** dynamic-vista-rev-orgs-vista-item-value */
export interface DynamicVistaRevOrgsVistaItemValue {
    item: RevOrgSummary;
}
/** dynamic-vista-works-vista */
export interface DynamicVistaWorksVista {
    filter: DynamicVistaWorksVistaFilter;
    /** Pinned items associated with the vista. */
    items?: DynamicVistaWorksVistaItemValue[];
}
/** dynamic-vista-works-vista-filter */
export interface DynamicVistaWorksVistaFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     */
    ancestor_part_ids_v1?: string;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     */
    ancestor_part_v1?: string;
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /** Filters for work belonging to any of the provided parts. */
    applies_to_part_ids_v1?: string;
    /** Filters for work belonging to any of the provided parts. */
    applies_to_part_v1?: string;
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    /** Filters for work created by any of these users. */
    created_by_ids_v1?: string;
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Filters for work created by any of these users. */
    created_by_v1?: string;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /** Filters for work excluding the provided work IDs. */
    exclude_v1?: string;
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Filters for work excluding the provided work IDs. */
    exclude_work_ids_v1?: string;
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Filters for work owned by any of these users. */
    owned_by_ids_v1?: string;
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Filters for work owned by any of these users. */
    owned_by_v1?: string;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /** Filters for work with any of the provided tags. */
    tag_ids_v1?: string;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /** Filters for work with any of the provided tags. */
    tags_v1?: string;
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** dynamic-vista-works-vista-item-value */
export interface DynamicVistaWorksVistaItemValue {
    item: WorkSummary;
}
/** edge-v2 */
export interface EdgeV2 {
    /** ID of the link. Currently a mocked one. */
    link_id: string;
    /** Type of link used to define the relationship. */
    link_type: LinkType;
    /** ID of the source object. */
    source_id: string;
    /** ID of the source object. */
    source_id_v1?: string;
    /** Type of source object. */
    source_object_type: string;
    /** ID of target object. */
    target_id: string;
    /** ID of target object. */
    target_id_v1?: string;
    /** Type of target object. */
    target_object_type: string;
}
/**
 * embed-links-create-request
 * The request to create a new link embedded inside another create
 * request.
 */
export interface EmbedLinksCreateRequest {
    /** The ID of the source object. */
    source_id?: string;
    /** The ID of the target object. */
    target_id?: string;
    /** Type of link used to define the relationship. */
    type: LinkType;
}
/** empty */
export type Empty = object;
/** engagement-base-summary */
export type EngagementBaseSummary = AtomBaseSummary;
/** enhancement */
export type Enhancement = PartBase & {
    /** Mutation purpose and related metadata. */
    mutation_info?: MutationInfoField;
    /**
     * Timestamp when the enhancement is expected to be closed.
     * @format date-time
     */
    target_close_date?: string;
};
/** enhancement-summary */
export type EnhancementSummary = PartBaseSummary;
/**
 * entitlement
 * Every SKU, will contain a list of entitlements defined under it.
 * Entitlement encapsulates 'HOW MUCH and HOW LONG' aspect of the given
 * UOM ID under specified SKU.
 */
export interface Entitlement {
    /**
     * Duration encapsulates the value of the duration and the type of the
     * duration. For example, 1 day where value is '1' and type is 'day'.
     */
    duration?: Duration;
    /**
     * Quantity, that the entitlement is entitled to use for the specified
     * UOM ID. In case of UOM being a boolean type (like
     * inline_compression, SAML, OAUTH) then quantity will simply be 0/1.
     * @format int32
     */
    quantity?: number;
    /**
     * Scope defines whether the entitlement is at org level or at each user
     * level. Knowing this will help on enforcing them for the given SKU at
     * rev, or at rev user level.
     */
    scope: EntitlementScope;
    uom: UomSummary;
}
/**
 * Scope defines whether the entitlement is at org level or at each user
 * level. Knowing this will help on enforcing them for the given SKU at
 * rev, or at rev user level.
 */
export declare enum EntitlementScope {
    Org = "org",
    User = "user"
}
/** error */
export interface Error {
    /** The debug error message. */
    debug_message?: string;
    /** Information about the error. */
    message: string;
    /** ID that can be used to reference the error occurrence. */
    reference_id?: string;
    /**
     * The corresponding HTTP status code.
     * @format int32
     */
    status: number;
    /** The error type. */
    type?: string;
}
/** error-bad-request */
export type ErrorBadRequest = ErrorBase & (ErrorBadRequestBadRequest | ErrorBadRequestMissingRequiredField | ErrorBadRequestParseError) & {
    type: ErrorBadRequestType;
};
/** error-bad-request-bad-request */
export type ErrorBadRequestBadRequest = object;
/** error-bad-request-missing-required-field */
export interface ErrorBadRequestMissingRequiredField {
    /** The missing field's name. */
    field_name: string;
}
/** error-bad-request-parse-error */
export type ErrorBadRequestParseError = object;
export declare enum ErrorBadRequestType {
    BadRequest = "bad_request",
    MissingRequiredField = "missing_required_field",
    ParseError = "parse_error"
}
/** error-base */
export interface ErrorBase {
    /** The debug message associated with the error. */
    debug_message?: string;
    /** The message associated with the error. */
    message?: string;
}
/** error-conflict */
export type ErrorConflict = ErrorBase & ErrorConflictConflict & {
    type: ErrorConflictType;
};
/** error-conflict-conflict */
export type ErrorConflictConflict = object;
export declare enum ErrorConflictType {
    Conflict = "conflict"
}
/** error-forbidden */
export type ErrorForbidden = ErrorBase & ErrorForbiddenForbidden & {
    type: ErrorForbiddenType;
};
/** error-forbidden-forbidden */
export type ErrorForbiddenForbidden = object;
export declare enum ErrorForbiddenType {
    Forbidden = "forbidden"
}
/** error-internal-server-error */
export type ErrorInternalServerError = ErrorBase & ErrorInternalServerErrorInternalError & {
    /**
     * A unique ID that's generated for the error that can be used for
     * inquiry.
     */
    reference_id?: string;
    /**
     * The stack trace at error creation, otherwise empty if not captured.
     * @format byte
     */
    stack_trace?: string;
    type: ErrorInternalServerErrorType;
};
/** error-internal-server-error-internal-error */
export type ErrorInternalServerErrorInternalError = object;
export declare enum ErrorInternalServerErrorType {
    InternalError = "internal_error"
}
/** error-not-found */
export type ErrorNotFound = ErrorBase & ErrorNotFoundNotFound & {
    type: ErrorNotFoundType;
};
/** error-not-found-not-found */
export type ErrorNotFoundNotFound = object;
export declare enum ErrorNotFoundType {
    NotFound = "not_found"
}
/** error-service-unavailable */
export type ErrorServiceUnavailable = ErrorBase & ErrorServiceUnavailableServiceUnavailable & {
    type: ErrorServiceUnavailableType;
};
/** error-service-unavailable-service-unavailable */
export type ErrorServiceUnavailableServiceUnavailable = object;
export declare enum ErrorServiceUnavailableType {
    ServiceUnavailable = "service_unavailable"
}
/** error-too-many-requests */
export type ErrorTooManyRequests = ErrorBase & ErrorTooManyRequestsTooManyRequests & {
    /**
     * The number of seconds after which the client should retry.
     * @format int64
     */
    retry_after?: number;
    type: ErrorTooManyRequestsType;
};
/** error-too-many-requests-too-many-requests */
export type ErrorTooManyRequestsTooManyRequests = object;
export declare enum ErrorTooManyRequestsType {
    TooManyRequests = "too_many_requests"
}
/** error-unauthorized */
export type ErrorUnauthorized = ErrorBase & ErrorUnauthorizedUnauthenticated & {
    type: ErrorUnauthorizedType;
};
export declare enum ErrorUnauthorizedType {
    Unauthenticated = "unauthenticated"
}
/** error-unauthorized-unauthenticated */
export type ErrorUnauthorizedUnauthenticated = object;
/**
 * event-activity
 * An event activity.
 */
export interface EventActivity {
    change_event?: TimelineChangeEvent;
}
/**
 * event-annotated
 * Base event for annotated type event.
 */
export interface EventAnnotated {
    /** Microflow action external annotated event. */
    microflow_action?: MicroflowActionEvent;
    /** Event for part merging. */
    part_merge?: PartMergeEvent;
    /** Event for part promotion. */
    part_promote?: PartPromoteEvent;
    /** The type of the annotated event. */
    type?: string;
}
/** event-article-created */
export interface EventArticleCreated {
    article: Article;
}
/** event-article-deleted */
export interface EventArticleDeleted {
    /** The ID of the article that was deleted. */
    id: string;
    /** The ID of the article that was deleted. */
    id_v1?: string;
}
/** event-article-updated */
export interface EventArticleUpdated {
    article: Article;
    old_article?: Article;
}
/** event-artifact-created */
export interface EventArtifactCreated {
    artifact: Artifact;
}
/** event-artifact-deleted */
export interface EventArtifactDeleted {
    /**
     * The ID of the artifact that was deleted.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    id: string;
    /** The ID of the artifact that was deleted. */
    id_v1?: string;
}
/** event-artifact-updated */
export interface EventArtifactUpdated {
    artifact: Artifact;
    old_artifact?: Artifact;
}
/** event-conversation-created */
export interface EventConversationCreated {
    conversation: Conversation;
}
/** event-conversation-deleted */
export interface EventConversationDeleted {
    /** The ID of the conversation that was deleted. */
    id: string;
    /** The ID of the conversation that was deleted. */
    id_v1?: string;
}
/** event-conversation-updated */
export interface EventConversationUpdated {
    conversation: Conversation;
    old_conversation?: Conversation;
}
/**
 * event-created
 * A creation event.
 */
export interface EventCreated {
    object?: AtomSummary;
}
/**
 * event-deleted
 * A deletion event.
 */
export interface EventDeleted {
    /** The ID correspending to the deleted object. */
    object_id?: string;
    /** The ID correspending to the deleted object. */
    object_id_v1?: string;
}
/** event-dev-user-created */
export interface EventDevUserCreated {
    dev_user: DevUser;
}
/** event-dev-user-deleted */
export interface EventDevUserDeleted {
    /** The ID of the Dev user that was deleted. */
    id: string;
    /** The ID of the Dev user that was deleted. */
    id_v1?: string;
}
/** event-dev-user-updated */
export interface EventDevUserUpdated {
    dev_user: DevUser;
    old_dev_user?: DevUser;
}
/** event-flow-created */
export interface EventFlowCreated {
    flow: Flow;
}
/** event-flow-deleted */
export interface EventFlowDeleted {
    /** The ID of the flow that was deleted. */
    id: string;
    /** The ID of the flow that was deleted. */
    id_v1?: string;
}
/** event-flow-updated */
export interface EventFlowUpdated {
    flow: Flow;
    old_flow?: Flow;
}
/** event-link-created */
export interface EventLinkCreated {
    link: Link;
}
/** event-link-deleted */
export interface EventLinkDeleted {
    /** The ID of the link that was deleted. */
    id: string;
    /** The ID of the link that was deleted. */
    id_v1?: string;
}
/** event-link-updated */
export interface EventLinkUpdated {
    link: Link;
    old_link?: Link;
}
/**
 * event-linked
 * A linking event.
 */
export interface EventLinked {
    link?: LinkSummary;
}
/** event-part-created */
export interface EventPartCreated {
    part: Part;
}
/** event-part-deleted */
export interface EventPartDeleted {
    /**
     * The ID of the part that was deleted.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    /** The ID of the part that was deleted. */
    id_v1?: string;
}
/** event-part-updated */
export interface EventPartUpdated {
    old_part?: Part;
    part: Part;
}
/** event-rev-org-created */
export interface EventRevOrgCreated {
    rev_org: RevOrg;
}
/** event-rev-org-deleted */
export interface EventRevOrgDeleted {
    /**
     * The ID of the Rev organization that was deleted.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id: string;
    /** The ID of the Rev organization that was deleted. */
    id_v1?: string;
}
/** event-rev-org-updated */
export interface EventRevOrgUpdated {
    old_rev_org?: RevOrg;
    rev_org: RevOrg;
}
/** event-rev-user-created */
export interface EventRevUserCreated {
    rev_user: RevUser;
}
/** event-rev-user-deleted */
export interface EventRevUserDeleted {
    /** The ID of the Rev user that was deleted. */
    id: string;
    /** The ID of the Rev user that was deleted. */
    id_v1?: string;
}
/** event-rev-user-updated */
export interface EventRevUserUpdated {
    old_rev_user?: RevUser;
    rev_user: RevUser;
}
/** event-source */
export type EventSource = AtomBase & {
    /**
     * The nexus connection id storing the auth details for the event
     * source.
     */
    auth_connection_id?: string;
    /**
     * JSON for the configuration of the event source, it would contain
     * which repository, which user, etc.
     */
    config?: object;
    /** Wrapper over rego policy allowing templated re-usable policy. */
    context_policy?: PolicyInstance;
    /**
     * Stores the db for the event source as a JSON string. This db stores
     * things like webhook id, secret etc. and is hidden from user.
     */
    db_string?: string;
    /**
     * Any other metadata associated with the event source we might want
     * to show in UI.
     */
    metadata?: object;
    /** name given to the event source. */
    name?: string;
    /** Wrapper over rego policy allowing templated re-usable policy. */
    run_policy?: PolicyInstance;
    /**
     * The secret corresponding to the event source. Only exposed to user
     * if the user needs it while registration.
     */
    secret?: string;
    /** Instructions. */
    setup_instructions?: EventSourceSetupInstructions;
    /**
     * Status of the event source. Disabled event sources return NotFound
     * error on triggering.
     */
    status?: EventSourceStatus;
    /**
     * id of the ticker task which is responsible for scheduling this
     * event. Relevant for timer-based sources.
     */
    trigger_task_id?: string;
    /** The URL to trigger the event source. */
    trigger_url?: string;
    /**
     * type describes which event source is being instantiated from list
     * of event sources we support. It would contain values like
     * pd/github/new-or-updated-pull-request, etc.
     */
    type?: string;
};
/** event-source-create-request */
export interface EventSourceCreateRequest {
    /**
     * The nexus connection id storing the auth details for the event
     * source.
     */
    auth_connection_id?: string;
    /**
     * JSON for the configuration of the event source, it would contain
     * which repository, which user, etc.
     */
    config?: object;
    context_policy?: CreatePolicyInstance;
    /** name given to the event source. */
    name?: string;
    run_policy?: CreatePolicyInstance;
    setup_instructions?: CreateEventSourceSetupInstructions;
    /**
     * Status of the event source. Disabled event sources return NotFound
     * error on triggering.
     */
    status?: EventSourceStatus;
    /**
     * type describes which event source is being instantiated from list
     * of event sources we support. It would contain values like
     * pd/github/new-or-updated-pull-request, etc.
     */
    type: string;
}
/** event-source-create-response */
export interface EventSourceCreateResponse {
    event_source: EventSource;
}
/** event-source-delete-request */
export interface EventSourceDeleteRequest {
    /** The event source's ID. */
    id: string;
    /** Flag to indicate if the deactivate errors must be ignored. */
    ignore_deactivate_error?: boolean;
}
/** event-source-get-request */
export interface EventSourceGetRequest {
    /** The event source's ID. */
    id: string;
}
/** event-source-get-response */
export interface EventSourceGetResponse {
    event_source: EventSource;
}
/**
 * event-source-setup-instructions
 * Instructions.
 */
export interface EventSourceSetupInstructions {
    /** Instructions content. */
    content?: string;
    /** Format in which content is defined. */
    format?: InstructionsFormat;
}
/**
 * Status of the event source. Disabled event sources return NotFound
 * error on triggering.
 */
export declare enum EventSourceStatus {
    Active = "active",
    Blocked = "blocked",
    Paused = "paused"
}
/** event-source-summary */
export type EventSourceSummary = AtomBaseSummary;
/** event-source-update-request */
export interface EventSourceUpdateRequest {
    /**
     * The nexus connection id storing the auth details for the event
     * source.
     */
    auth_connection_id?: string;
    /**
     * JSON for the configuration of the event source, it would contain
     * which repository, which user, etc.
     */
    config?: object;
    context_policy?: UpdatePolicyInstance;
    /** The event source's ID. */
    id: string;
    /** name given to the event source. */
    name?: string;
    run_policy?: UpdatePolicyInstance;
    setup_instructions?: UpdateEventSourceSetupInstructions;
    /**
     * Status of the event source. Disabled event sources return NotFound
     * error on triggering.
     */
    status?: EventSourceStatus;
}
/** event-source-update-response */
export interface EventSourceUpdateResponse {
    event_source: EventSource;
}
/** event-sources-delete-scheduled-event-request */
export interface EventSourcesDeleteScheduledEventRequest {
    /** The event key for the event which we want to delete. */
    event_key: string;
    /** The event source's ID. */
    id: string;
}
/** event-sources-list-request */
export interface EventSourcesListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Fields to sort the event sources by and the direction to sort them. */
    sort_by?: string[];
    /**
     * type describes which event source is being instantiated from list
     * of event sources we support. It would contain values like
     * pd/github/new-or-updated-pull-request, etc.
     */
    type?: string[];
}
/** event-sources-list-response */
export interface EventSourcesListResponse {
    /** List of the event sources. */
    event_sources: EventSource[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** event-sources-schedule-event-request */
export interface EventSourcesScheduleEventRequest {
    /**
     * A unique key for this event (scoped to an event source) used for
     * updating/getting/deleting scheduled events.
     */
    event_key?: string;
    /** The type of the event. */
    event_type: string;
    /** The event source's ID. */
    id: string;
    /**
     * The raw payload of the event.
     * @format byte
     */
    payload: string;
    /**
     * The timestamp (milliseconds since Unix epoch) at which the event
     * should be published. Event is guaranteed to be published after
     * this. If missing, event is published immediately.
     * @format int64
     */
    publish_timestamp?: number;
    /**
     * Whether or not to update an existing scheduled event with the same
     * event key. If this is false, and an event is already scheduled with
     * the same event key, then HTTP 409 Conflict is returned.
     */
    update_if_exists?: boolean;
}
/** event-sources-schedule-event-response */
export interface EventSourcesScheduleEventResponse {
    /**
     * The event key for this event. Auto-generated if the caller didn't
     * specify the event key. Empty if event was published immediately.
     */
    event_key?: string;
}
/** event-subscribe */
export interface EventSubscribe {
    /** The event subscriptions that were added. */
    add?: string[];
    /** The event subscriptions that were added. */
    add_v1?: string;
    /** The ID provided in the subscribe action. */
    id?: string;
    /** The event subscriptions that were removed. */
    remove?: string[];
    /** The event subscriptions that were removed. */
    remove_v1?: string;
}
/** event-tag-created */
export interface EventTagCreated {
    tag: Tag;
}
/** event-tag-deleted */
export interface EventTagDeleted {
    /**
     * The ID of the tag that was deleted.
     * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
     */
    id: string;
    /** The ID of the tag that was deleted. */
    id_v1?: string;
}
/** event-tag-updated */
export interface EventTagUpdated {
    old_tag?: Tag;
    tag: Tag;
}
/** event-timeline-entry-created */
export interface EventTimelineEntryCreated {
    entry: TimelineEntry;
}
/** event-timeline-entry-deleted */
export interface EventTimelineEntryDeleted {
    /** The ID of the timeline entry that was deleted. */
    id: string;
    /** The ID of the timeline entry that was deleted. */
    id_v1?: string;
}
/** event-timeline-entry-updated */
export interface EventTimelineEntryUpdated {
    entry: TimelineEntry;
    old_entry?: TimelineEntry;
}
/**
 * event-updated
 * An update event.
 */
export interface EventUpdated {
    /** List of field changes. */
    field_deltas?: FieldDelta[];
    /** Type of DevRev object. */
    object_type?: string;
}
/** event-user-typing */
export interface EventUserTyping {
    /** The ID of the object that the user is typing in the context of. */
    object: string;
    /** The ID of the object that the user is typing in the context of. */
    object_v1?: string;
    user: UserSummary;
}
/** event-vista-created */
export interface EventVistaCreated {
    /** Represents a collection of DevRev objects. */
    vista: Vista;
}
/** event-vista-deleted */
export interface EventVistaDeleted {
    /** The ID of the vista that was deleted. */
    id: string;
    /** The ID of the vista that was deleted. */
    id_v1?: string;
}
/** event-vista-updated */
export interface EventVistaUpdated {
    /** Represents a collection of DevRev objects. */
    old_vista?: Vista;
    /** Represents a collection of DevRev objects. */
    vista: Vista;
}
/** event-webhook-created */
export interface EventWebhookCreated {
    webhook: Webhook;
}
/** event-webhook-deleted */
export interface EventWebhookDeleted {
    /**
     * The ID of the webhook that was deleted.
     * @example "don:<partition>:integration:devo/<dev-org-id>:webhook/<webhook-id>"
     */
    id: string;
    /** The ID of the webhook that was deleted. */
    id_v1?: string;
}
/** event-webhook-updated */
export interface EventWebhookUpdated {
    old_webhook?: Webhook;
    webhook: Webhook;
}
/** event-work-created */
export interface EventWorkCreated {
    work: Work;
}
/** event-work-deleted */
export interface EventWorkDeleted {
    /**
     * The ID of the work that was deleted.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
    /** The ID of the work that was deleted. */
    id_v1?: string;
}
/** event-work-updated */
export interface EventWorkUpdated {
    old_work?: Work;
    work: Work;
}
/** execute-snap-kit-action-request */
export interface ExecuteSnapKitActionRequest {
    /** List of actions triggered in the request. */
    actions: SnapKitActionRequest[];
    /** Parent ID to which snap kit body belongs to. */
    parent: string;
    /** The SnapKit body. */
    snap_kit_body: object;
}
/** execute-snap-kit-action-response */
export type ExecuteSnapKitActionResponse = object;
/** experience-flags-get-request */
export type ExperienceFlagsGetRequest = object;
/** experience-flags-get-response */
export interface ExperienceFlagsGetResponse {
    /** Whether import history is enabled. */
    airdrop_history_enabled?: boolean;
    /**
     * Whether DevOrg on specific environment can create migration units
     * and see airdrop imports tab.
     */
    airdrop_imports_enabled?: boolean;
    /** Whether Linear Airdrop is enabled. */
    airdrop_linear_enabled?: boolean;
    /** Whether Airdrop periodic sync is enabled. */
    airdrop_periodic_sync_enabled?: boolean;
    /**
     * Whether UI should offer for selected source systems the ability to
     * decide between importing as different work types
     */
    airdrop_target_work_type_selection_enabled?: boolean;
    /** Whether the zendesk connection feature is enabled. */
    airdrop_zendesk_enabled?: boolean;
    /** Whether the app id and secret section is enabled */
    app_id_and_secret_section_enabled?: boolean;
    /** Whether the artifacts v2 feature is enabled. */
    artifacts_v2_enabled?: boolean;
    /** Whether creating AWS connections is enabled in the UI. */
    aws_connection_enabled?: boolean;
    /** Weather the billing page is enabled. */
    billing_page_enabled?: boolean;
    /** Whether the bitbucket connection feature is enabled. */
    bitbucket_connection_enabled?: boolean;
    /** Whether capture phone number workflow is enabled. */
    capture_phone_number_enabled?: boolean;
    /** Whether Cellarman's capabilities API uses Archon feature flags */
    cellarman_capabilities_enabled?: boolean;
    /** Whether the clearbit connection feature is enabled. */
    clearbit_connection_enabled?: boolean;
    /** Whether conversation deflection is enabled. */
    conversation_deflection_enabled?: boolean;
    /** Whether conversation translation is enabled. */
    conversation_translation_enabled?: boolean;
    /** Whether creation of default objects during onboarding is enabled. */
    default_objects_creation_enabled?: boolean;
    /** Whether default vistas are enabled or not. */
    default_vista_enabled?: boolean;
    /** Whether to enable deleting a dev-user from a dev-org. */
    delete_dev_user_enabled?: boolean;
    /** Whether Dev organization creation is allowed. */
    dev_org_create_allowed?: boolean;
    /** Whether to use lobby of conversation object type. */
    dev_user_list_params_v2_enabled?: boolean;
    /** Whether the devorg environment can be set. */
    devorg_environment_enabled?: boolean;
    /** Whether the discord connection feature is enabled. */
    discord_connection_enabled?: boolean;
    /**
     * Whether the domain based access option is available to the user on
     * the basis of email.
     */
    domain_based_access_enabled?: boolean;
    /** Whether to enable the domain based join organization workflow. */
    domain_based_join_workflow_enabled?: boolean;
    /** Whether MFZ is enabled. */
    enable_mfz?: boolean;
    /** Whether MFZ permissions are enabled. */
    enable_mfz_permissions?: boolean;
    /** Whether onboarding pricing plan selection enabled. */
    enable_onboarding_pricing_plan?: boolean;
    /** Whether enhancement creaiton is enabled. */
    enhancement_creation_enabled?: boolean;
    /** Whether MFZ is enabled for flows object type. */
    flow_mfz_enabled?: boolean;
    /** Whether the cellarman api for connections is enabled for flows. */
    flows_connections_v2_enabled?: boolean;
    /** Whether flows are enabled or not. */
    flows_enabled?: boolean;
    /** Whether the google connection feature is enabled. */
    google_connection_enabled?: boolean;
    /** Whether to load default profile pic as initials */
    initials_profile_pic_enabled?: boolean;
    /** Whether the intercom connection feature is enabled. */
    intercom_connection_enabled?: boolean;
    /** Whether the invitation workflow is enabled. */
    invitation_enabled?: boolean;
    /** Whether creating Kubernetes connections is enabled in the UI. */
    kubernetes_connection_enabled?: boolean;
    /** Whether the vistas on the left nav on UI are grouped or not. */
    left_nav_vista_grouping_enabled?: boolean;
    /** Whether the link devuser to profile workflow is enabled. */
    link_profile_enabled?: boolean;
    /** Whether to use lobby of conversation object type. */
    lobby_conversation_type_enabled?: boolean;
    /** Lobby work DON */
    lobby_work_don?: string;
    /**
     * Login sequence that's used to force re-logins.
     * @format int64
     */
    login_sequence?: number;
    /** The maintenance message that should be displayed to the user. */
    maintenance_message?: string;
    /** Whether to enable the merge devuser workflow. */
    merge_devuser_enabled?: boolean;
    /** Whether the part hierarchy will be deleted */
    part_archive_hierarchy_enabled?: boolean;
    /** Whether parts discovery is enabled in the UI. */
    parts_discovery_enabled?: boolean;
    /** Whether password-less logins are enabled or not. */
    passwordless_enabled?: boolean;
    /** Whether the search articles feature on plug widget is enabled */
    plug_widget_articles_search_enabled?: boolean;
    /** Whether the rev user notifications on plug widget are enabled */
    plug_widget_rev_user_notifications_enabled?: boolean;
    /** Whether the profile picture is enabled. */
    profile_picture_enabled?: boolean;
    /** Whether to publish post login events to blubox. */
    publish_post_login_event?: boolean;
    /** Whether push notifications are enabled. */
    push_notifications_enabled?: boolean;
    /** Whether the audio-video rooms feature is enabled. */
    rooms_enabled?: boolean;
    /** Whether this devOrg is for sandbox/demo use or not. */
    sandbox_devorg?: boolean;
    /** Whether the sendgrid connection feature is enabled. */
    sendgrid_connection_enabled?: boolean;
    /** Weather the plans page for pricing is enabled. */
    service_plan_details_enabled?: boolean;
    /** Whether masking for the session replay feature is enabled. */
    session_replay_masking_enabled?: boolean;
    /** Whether the session replays feature is enabled. */
    session_replays_enabled?: boolean;
    /** Whether the slack connection feature is enabled. */
    slack_connection_enabled?: boolean;
    /** Whether stage v2 is enabled. */
    stage_v2_enabled?: boolean;
    /** Whether to enable sts token based authentication in api requests. */
    sts_token_enabled?: boolean;
    /** Whether Accounts is enabled */
    ui_accounts_enabled?: boolean;
    /** Whether Analytics is enabled */
    ui_analytics_enabled?: boolean;
    /** Whether the batch work actions are enabled */
    ui_batch_work_actions_enabled?: boolean;
    /** Whether Build Insights is enabled. */
    ui_build_insights_enabled?: boolean;
    /** Whether Bulk Import Revorgs is enabled in the UI. */
    ui_bulk_import_revorgs_enabled?: boolean;
    /**
     * Threshold below which clustering should enabled in UI.
     * @format int64
     */
    ui_clustering_threshold?: number;
    /**
     * Whether connections should use popup for connections requiring
     * redirects.
     */
    ui_connections_popup_enabled?: boolean;
    /** Whether the new connections page is enabled. */
    ui_connections_v2_enabled?: boolean;
    /** Whether new conversation v2 bulk update API is enabled */
    ui_conv_bulk_update_v2_enabled?: boolean;
    /** Whether new conversation v2 create API is enabled */
    ui_conv_create_v2_enabled?: boolean;
    /** Whether new conversation v2 get API is enabled */
    ui_conv_get_v2_enabled?: boolean;
    /** Whether new conversation v2 group_by API is enabled */
    ui_conv_group_by_v2_enabled?: boolean;
    /** Whether new conversation v2 list API is enabled */
    ui_conv_list_v2_enabled?: boolean;
    /** Whether new conversation v2 update API is enabled */
    ui_conv_update_v2_enabled?: boolean;
    /** Whether conversation parts are enabled. */
    ui_conversation_parts_enabled?: boolean;
    /** Whether conversation vista is enabled on the UI. */
    ui_conversation_vista_enabled?: boolean;
    /** Whether the credits dev org workflow is enabled in UI. */
    ui_credits_flow_enabled?: boolean;
    /** Whether custom range filter for date is enabled on the UI */
    ui_custom_range_filter_enabled?: boolean;
    /** Whether customer vistas is enabled */
    ui_customer_vistas_enabled?: boolean;
    /** Whether customization is enabled. */
    ui_customization_enabled?: boolean;
    /** Whether delete connection feature is enabled */
    ui_delete_connection_enabled?: boolean;
    /** Whether delete devOrg feature is enabled. */
    ui_delete_dev_org_enabled?: boolean;
    /** Whether artifacts v2 based dev-org logo enabled. */
    ui_dev_org_logo_v2_enabled?: boolean;
    /** Whether Dev Parts are enabled. */
    ui_dev_parts_enabled?: boolean;
    /** Whether the DevRev PAT connection is enabled. */
    ui_devrev_pat_connection_enabled?: boolean;
    /** Whether discovery page is enabled on the UI */
    ui_discovery_page_enabled?: boolean;
    /** Whether domain verification connection is enabled. */
    ui_domain_verification_connection_enabled?: boolean;
    /**
     * Whether event source selection/creation is enabled in flows
     * configuration on the UI
     */
    ui_flows_config_event_source_enabled?: boolean;
    /** Whether the Flows editor feature is enabled. */
    ui_flows_editor_enabled?: boolean;
    /** Whether event source V2 API is enabled on the UI. */
    ui_flows_event_source_v2_enabled?: boolean;
    /** Whether displaying parts hierarchy on grouping by parts is enabled */
    ui_group_by_parts_hierarchy_enabled?: boolean;
    /** Whether grouped work vistas is enabled on the UI. */
    ui_grouped_work_vistas_enabled?: boolean;
    /** Whether GrowthOS is enabled. */
    ui_growth_os_enabled?: boolean;
    /** Whether the huddle feature is enabled in UI. */
    ui_huddle_enabled?: boolean;
    /** Whether the kb-articles page is enabled. */
    ui_kb_articles_page_enabled?: boolean;
    /** Whether knowledge v2 is enabled */
    ui_knowledge_v2_enabled?: boolean;
    /** Whether to enable the light mode. */
    ui_light_mode_enabled?: boolean;
    /** Whether to enable link bitbucket account button in UI. */
    ui_link_bitbucket_account_enabled?: boolean;
    /** Whether to enable link external identities in accounts in UI. */
    ui_link_external_identities_enabled?: boolean;
    /** Whether to enable link github account button in UI. */
    ui_link_github_account_enabled?: boolean;
    /** Whether the UI is locked. */
    ui_lock?: boolean;
    /** Whether Manual creation of revorg is enabled. */
    ui_manual_create_revorgs_enabled?: boolean;
    /** Whether my tasks are enabled. */
    ui_my_task_enabled?: boolean;
    /** Whether to show time element for NNL vistas on the UI */
    ui_nnl_time_element_enabled?: boolean;
    /** Whether Now vista insights page is enabled in UI. */
    ui_now_vista_insights_page_enabled?: boolean;
    /** Whether artifacts v2 based dev-org logo enabled. */
    ui_page_header_v2_enabled?: boolean;
    /**
     * Whether the work items of children parts are also shown on filter
     * by a part.
     */
    ui_part_hierarchy_works_filter_enabled?: boolean;
    /** Whether part insights are enabled. */
    ui_part_insights_enabled?: boolean;
    /** Whether Parts Vista is enabled in UI. */
    ui_part_vista_enabled?: boolean;
    /** Whether the ui payments flow is enabled in billing page. */
    ui_payments_flow_enabled?: boolean;
    /** Whether to use new FieldCell for table for better performance. */
    ui_performance_field_cell_enabled?: boolean;
    /** Whether to enable caching of last used org in the UI */
    ui_remove_cache_last_used_org?: boolean;
    /** Flag to control dev0 specific fields. */
    ui_rev_dev0_fields_enabled?: boolean;
    /** Whether Environment field for revorg is editable. */
    ui_rev_environment_edit_enabled?: boolean;
    /** Whether Environment field for revorg is enabled. */
    ui_rev_environment_enabled?: boolean;
    /** Whether GroupBy is enabled for rev */
    ui_rev_groupby_enabled?: boolean;
    /** Whether tier stock field is enabled for rev orgs in UI. */
    ui_rev_org_tier_stock_field?: boolean;
    /** Whether rev-user global search is enabled. */
    ui_rev_user_global_search_enabled?: boolean;
    /** Whether the SLAs widget is enabled on the UI. */
    ui_slas_enabled?: boolean;
    /** Whether ticket clustering is enabled on the UI */
    ui_ticket_clustering_enabled?: boolean;
    /** Whether trails v2 experience is enabled in the UI */
    ui_trails_v2_enabled?: boolean;
    /** Whether user backend search is enabled. */
    ui_user_backend_search_enabled?: boolean;
    /** Whether User Preferences are enabled on the UI. */
    ui_user_preferences_enabled?: boolean;
    /** Whether to use v2 work components in UI. */
    ui_v2_work_enabled?: boolean;
    /** The current UI version. */
    ui_version?: string;
    /** Whether vistas v2 is enabled on the UI */
    ui_vistas_v2_enabled?: boolean;
    /** Whether web is enabled for mobile */
    ui_web_for_mobile?: boolean;
    /** whether reordering on dynamic vistas is enabled. */
    vista_dynamic_reordering_enabled?: boolean;
    /** Whether MFZ is enabled for vistas object type. */
    vista_mfz_enabled?: boolean;
    /** Whether vista scoping is enabled. */
    vista_scoping_enabled?: boolean;
    /** Whether vista sharing is enabled. */
    vista_sharing_enabled?: boolean;
    /** Whether subscribers are shown in work panel. */
    work_subscribers_field_enabled?: boolean;
}
/**
 * external-identity
 * External identity of a user.
 */
export interface ExternalIdentity {
    /** Display name of the user in the external source. */
    display_name?: string;
    /** Unique ID of the user in the external source. */
    id?: string;
    /** Issuer of the external identity of the user. */
    issuer?: string;
    /** State of the user in the external source. */
    state?: ExternalIdentityState;
}
/** State of the user in the external source. */
export declare enum ExternalIdentityState {
    Active = "active",
    Deleted = "deleted",
    Inactive = "inactive"
}
/** external-orgs-list-request */
export interface ExternalOrgsListRequest {
    /** The keyring's ID. */
    id: string;
}
/** external-orgs-list-response */
export interface ExternalOrgsListResponse {
    external_orgs: ExternalOrgsListResponseExternalOrg[];
}
/** external-orgs-list-response-external-org */
export interface ExternalOrgsListResponseExternalOrg {
    id: string;
    name: string;
}
/**
 * extractors
 * Configuration knobs for extractors.
 */
export interface Extractors {
    /** Discovery clues extractors configuration. */
    config?: object;
    /** Discovery mapping from a source name to a dev clue extractor. */
    dev?: object;
    /** Discovery mapping from a source name to a rev clue extractor. */
    rev?: object;
}
/** feature */
export type Feature = PartBase & {
    /** Associated API endpoints. */
    api_endpoints?: ApiEndpoint[];
    /** Associated API parameters. */
    api_parameters_summary?: string[];
    /** Common Path Denominators of the Api Operations. */
    api_prefix_summary?: string[];
    development_owner?: UserSummary;
    /**
     * A confidence score computed by the inference engine. Currently, the
     * score is not normalized across different part inferences. Until
     * this is improved, this should only be comparable to confidence of
     * same part type.
     * @format double
     */
    discovery_confidence?: number;
    /**
     * A evidences that the inferer were able to find that justify the
     * inference outcome.
     */
    discovery_evidences?: string[];
    /**
     * The time when this inference occurred.
     * @format date-time
     */
    discovery_last_inferred_at?: string;
    /** IDs of the runnables that fulfill this feature. */
    fulfilled_by?: PartSummary[];
    part_of_part?: PartSummary;
    pm_owner?: UserSummary;
    qa_owner?: UserSummary;
    /** Versions of the feature. */
    versions?: string[];
};
/** The HTTP Operations that can be assigned to a Feature's API Operation. */
export declare enum FeatureApiOperationHttpOperation {
    Connect = "connect",
    Delete = "delete",
    Get = "get",
    Head = "head",
    Options = "options",
    Patch = "patch",
    Post = "post",
    Put = "put",
    Trace = "trace",
    Unknown = "unknown"
}
/** feature-pin-summary */
export type FeaturePinSummary = PartPinBaseSummary;
/** feature-summary */
export type FeatureSummary = PartBaseSummary;
/**
 * field-delta
 * A field change.
 */
export interface FieldDelta {
    /** The name of the field. */
    name?: string;
    new_value?: FieldValue;
    old_value?: FieldValue;
}
/**
 * field-descriptor
 * Set of field attributes.
 */
export interface FieldDescriptor {
    /** The default value for this field. */
    default_value?: object;
    /** Description of the field. */
    description?: string;
    /** Composite type. */
    devrev_composite_type?: string;
    /** Allowed values for a string or []string type. */
    devrev_enum?: string[];
    /** DevRev field type. */
    devrev_field_type?: string;
    /** Object ID types. */
    devrev_id_type?: string[];
    /** The schema of gateway specific fields. */
    gateway?: FieldGatewayMetadata;
    /** Whether this field is filterable, groupable and sortable. */
    is_filterable?: boolean;
    /** Whether this field can hold PII. */
    is_pii?: boolean;
    /** Whether this field is required or not. */
    is_required?: boolean;
    /** Whether this field is a system field or not. */
    is_system?: boolean;
    /** Name of the field. */
    name?: string;
    /** The schema of ui specific fields. */
    ui?: FieldUiMetadata;
    /** Validation annotations. */
    validation?: FieldValidation;
}
/**
 * field-devrev-enum-group
 * Enum group information.
 */
export interface FieldDevrevEnumGroup {
    /** enum group key. */
    group_key?: string;
    /** true if header is visible. */
    is_header_visible?: boolean;
    /** label of the field. */
    label?: string;
}
/**
 * field-gateway-metadata
 * The schema of gateway specific fields.
 */
export interface FieldGatewayMetadata {
    /** Gateway api name of the field. */
    api_name?: string;
}
/**
 * field-ui-metadata
 * The schema of ui specific fields.
 */
export interface FieldUiMetadata {
    /** Allowed values of the field. */
    allowed_values?: string[];
    /** Fields on which this field depends on. */
    dependent_fields?: string[];
    /**
     * Detail view UI hint overrides.
     * @format int32
     */
    detail_view?: number;
    /** enum groups. */
    devrev_enum_groups?: DevrevEnumGroup[];
    /** display name of the field. */
    display_name?: string;
    /** Whether field is active in detail view. */
    is_active_in_detail_view?: boolean;
    /** Whether stock field is rendered at top. */
    is_base_field?: boolean;
    /** Whether field supports bulk action. */
    is_bulk_action_enabled?: boolean;
    /** Indicates if the field holds a currency value in USD. */
    is_currency_field?: boolean;
    /** Whether field is groupable. */
    is_groupable?: boolean;
    /** Whether field is hidden in UI. */
    is_hidden?: boolean;
    /** Whether field is hidden in UI during creation. */
    is_hidden_during_create?: boolean;
    /** Whether field is read-only in UI. */
    is_read_only?: boolean;
    /** Whether field is shown in summary. */
    is_shown_in_summary?: boolean;
    /** Whether field is sortable. */
    is_sortable?: boolean;
    /**
     * List view UI hint overrides.
     * @format int32
     */
    list_view?: number;
    /**
     * Order in which field is shown.
     * @format int32
     */
    order?: number;
    /** Placeholder for the field. */
    placeholder?: string;
    /** Tooltip for field. */
    tooltip?: string;
    /** Unit of measurment. */
    unit?: string;
}
/**
 * field-validation
 * Validation annotations.
 */
export interface FieldValidation {
    /** string contains. */
    contains?: string;
    /** disables validations for this field. */
    disabled?: boolean;
    /**
     * exact array length.
     * @format int32
     */
    eq_items?: number;
    /**
     * exact string length.
     * @format int32
     */
    eq_len?: number;
    /**
     * int must be greater than this.
     * @format int32
     */
    gt?: number;
    /**
     * int must be greater or equal than this.
     * @format int32
     */
    gte?: number;
    /**
     * int must be less than this.
     * @format int32
     */
    lt?: number;
    /**
     * int must be less or equal than this.
     * @format int32
     */
    lte?: number;
    /**
     * maximum array length.
     * @format int32
     */
    max_items?: number;
    /**
     * maximum string length.
     * @format int32
     */
    max_len?: number;
    /**
     * minimum array length.
     * @format int32
     */
    min_items?: number;
    /**
     * minimum string length.
     * @format int32
     */
    min_len?: number;
    /** string pattern (re). */
    pattern?: string;
    /** string prefix. */
    prefix?: string;
    /** string suffix. */
    suffix?: string;
}
/** field-value */
export type FieldValue = (FieldValueBool | FieldValueBoolList | FieldValueDateList | FieldValueDateTimeList | FieldValueDateTimeValue | FieldValueDateValue | FieldValueDouble | FieldValueDoubleList | FieldValueId | FieldValueIdList | FieldValueInt64 | FieldValueInt64List | FieldValueString | FieldValueStringList) & {
    placeholder?: string;
    type: FieldValueType;
};
/** field-value-bool */
export interface FieldValueBool {
    value: boolean;
}
/** field-value-bool-list */
export interface FieldValueBoolList {
    values: boolean[];
}
/** field-value-date-list */
export interface FieldValueDateList {
    values: string[];
}
/** field-value-date-time-list */
export interface FieldValueDateTimeList {
    values: string[];
}
/** field-value-date-time-value */
export interface FieldValueDateTimeValue {
    /** @format date-time */
    value: string;
}
/** field-value-date-value */
export interface FieldValueDateValue {
    /** @format date */
    value: string;
}
/** field-value-double */
export interface FieldValueDouble {
    /** @format double */
    value: number;
}
/** field-value-double-list */
export interface FieldValueDoubleList {
    values: number[];
}
/** field-value-id */
export interface FieldValueId {
    value: string;
    value_v1?: string;
}
/** field-value-id-list */
export interface FieldValueIdList {
    values: string[];
    values_v1?: string;
}
/** field-value-int64 */
export interface FieldValueInt64 {
    /** @format int64 */
    value: number;
}
/** field-value-int64-list */
export interface FieldValueInt64List {
    values: number[];
}
/** field-value-string */
export interface FieldValueString {
    value: string;
}
/** field-value-string-list */
export interface FieldValueStringList {
    values: string[];
}
export declare enum FieldValueType {
    Bool = "bool",
    BoolList = "bool_list",
    Date = "date",
    DateList = "date_list",
    DateTime = "date_time",
    DateTimeList = "date_time_list",
    Double = "double",
    DoubleList = "double_list",
    Id = "id",
    IdList = "id_list",
    Int = "int",
    IntList = "int_list",
    String = "string",
    StringList = "string_list"
}
/**
 * file
 * Defines a file object.
 */
export interface File {
    /** S3 key for the file. */
    key?: string;
    /** Name of the file. */
    name?: string;
    /**
     * Size of the file in bytes.
     * @format int32
     */
    size?: number;
    /** Type of the file. */
    type?: string;
}
/** flow */
export type Flow = AtomBase & {
    /** List of automations used in the flow. */
    automations?: FlowNameReferenceMapping[];
    /** List of commands used in the flow. */
    commands?: FlowNameReferenceMapping[];
    /** List of connections used in the flow. */
    connections?: FlowNameValuePair[];
    /** Description of the flow. */
    description?: string;
    /** List of event sources used in the flow. */
    event_sources?: FlowNameReferenceMapping[];
    flow_config?: FlowConfig;
    /** List of inputs to be provided from the user to be used in the flow. */
    inputs?: GlobalInput[];
    marketplace_item?: MarketplaceItemSummary;
    /**
     * Version of the Marketplace Item template through which this flow
     * was installed.
     */
    marketplace_item_version?: string;
    /** Name of the flow. */
    name?: string;
    /** Raw template which created the flow. */
    raw_template?: string;
    /** List of secrets used in the flow. */
    secrets?: FlowNameReferenceMapping[];
    /** List of resources created as part of the flow. */
    setup_resources?: FlowSetupResource[];
    /**
     * List of snapkit actions used in the flow. An snapkit action is a
     * synchronous code path called when an interactive element on the
     * snap-kit is interacted with. Interactive elements include buttons,
     * checkboxes, date-pickers etc. An snapkit action is defined as
     * change in value of these elements.
     */
    snap_kit_actions?: FlowNameReferenceMapping[];
    /** Deployment status of the flow. */
    status?: FlowStatus;
};
/** flow-config */
export interface FlowConfig {
    /** List of connections in flow definition. */
    connections?: FlowConnection[];
    /** List of event sources in flow definition. */
    event_sources?: FlowEventSource[];
    /** List of inputs in flow definition. */
    global_inputs?: FlowGlobalInput[];
    /** List of secrets in flow definition. */
    secrets?: FlowSecret[];
}
/** flow-connection */
export interface FlowConnection {
    /** Display name of connection in flow definition. */
    display_name?: string;
    /** Name of connection in flow definition. */
    name: string;
    /** List of keyring types this connection can be. */
    types: string[];
}
/** flow-delete-request */
export interface FlowDeleteRequest {
    /** The flow's ID. */
    id: string;
}
/** flow-event-source */
export interface FlowEventSource {
    /** Display name of event source in flow definition. */
    display_name?: string;
    /** Name of event source in flow definition. */
    name: string;
    /** Type of event source in flow definition. */
    type: string;
}
/** flow-get-request */
export interface FlowGetRequest {
    /** The flow's ID. */
    id: string;
}
/** flow-get-response */
export interface FlowGetResponse {
    flow: Flow;
}
/** flow-global-input */
export interface FlowGlobalInput {
    /** Allowed values for the input. */
    allowed_values?: string[];
    /** Default value for the input. */
    default_value?: string;
    /** Description of the input value. */
    description?: string;
    /** Display name for the input. */
    display_name?: string;
    /** Name of input in the flow definition. */
    name: string;
    /** Type of the input. */
    type: FlowGlobalInputType;
}
/** Type of the input. */
export declare enum FlowGlobalInputType {
    Bool = "bool",
    EmailAddress = "email_address",
    Enum = "enum",
    EnumList = "enum_list",
    Float = "float",
    FloatList = "float_list",
    Integer = "integer",
    IntegerList = "integer_list",
    Json = "json",
    KeyValues = "key_values",
    Part = "part",
    String = "string",
    StringList = "string_list",
    User = "user"
}
/**
 * flow-name-reference-mapping
 * Stores mapping from template defined name to corresponding ID.
 */
export interface FlowNameReferenceMapping {
    /**
     * Name by which the object is being referred in the flow. May be
     * different from the value of the `name` field (if present) of the
     * object.
     */
    name: string;
    reference?: AtomSummary;
}
/**
 * flow-name-value-pair
 * Stores a string name to string value mapping.
 */
export interface FlowNameValuePair {
    /** Name. */
    name: string;
    /** Value. */
    value?: string;
}
/** flow-secret */
export interface FlowSecret {
    /** Description of secret in flow definition. */
    description?: string;
    /** Display name of secret in flow definition. */
    display_name?: string;
    /** Name of secret in flow definition. */
    name: string;
}
/**
 * flow-setup-resource
 * Resource created as part of setup of a flow.
 */
export interface FlowSetupResource {
    /** Stores mapping from template defined name to corresponding ID. */
    resource?: FlowNameReferenceMapping;
    /** Type of the created resource. */
    resource_type?: SetupResourceResourceType;
}
/** Deployment status of the flow. */
export declare enum FlowStatus {
    Active = "active",
    Draft = "draft",
    Error = "error",
    Inactive = "inactive"
}
/** flow-summary */
export type FlowSummary = AtomBaseSummary & {
    /** Description of the flow. */
    description?: string;
    /** Name of the flow. */
    name?: string;
};
/** flow-update-request */
export interface FlowUpdateRequest {
    /** List of automations used in the flow */
    automations?: UpdateFlowNameReferenceMapping[];
    /** List of commands used in the flow */
    commands?: UpdateFlowNameReferenceMapping[];
    /** List of connections used in the flow */
    connections?: UpdateFlowNameValuePair[];
    /** Description of the flow */
    description?: string;
    /** List of event sources used in the flow */
    event_sources?: UpdateFlowNameReferenceMapping[];
    /** The flow's ID. */
    id: string;
    /** List of inputs to be provided from the user to be used in the flow */
    inputs?: UpdateGlobalInput[];
    /**
     * Version of the Marketplace Item template through which this flow
     * was installed
     */
    marketplace_item_version?: string;
    /** Name of the flow */
    name?: string;
    /** Raw template which created the flow */
    raw_template?: string;
    /** List of secrets used in the flow */
    secrets?: UpdateFlowNameReferenceMapping[];
    /** List of resources created as part of the flow */
    setup_resources?: UpdateFlowSetupResource[];
    /**
     * List of snapkit actions used in the flow. An snapkit action is a
     * synchronous code path called when an interactive element on the
     * snap-kit is interacted with. Interactive elements include buttons,
     * checkboxes, date-pickers etc. An snapkit action is defined as
     * change in value of these elements.
     */
    snap_kit_actions?: UpdateFlowNameReferenceMapping[];
    /** Deployment status of the flow. */
    status?: FlowStatus;
}
/** flow-update-response */
export interface FlowUpdateResponse {
    flow: Flow;
}
/** flows-github-create-request */
export interface FlowsGithubCreateRequest {
    /** The transitions to enable for the flow. */
    enabled_transitions?: GithubFlowEventTransition[];
    /**
     * ID of the GitHub event source. If provided, this event source is
     * used instead of creating a new one.
     */
    event_source_id?: string;
    /**
     * The default part ID to use for the autonomous works created via
     * this flow.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    new_branch_works_part_id?: string;
}
/** flows-github-create-response */
export interface FlowsGithubCreateResponse {
    flow: Flow;
    /** Secret value to use while configuring the webhook on GitHub. */
    webhook_secret: string;
    /** Webhook URL to be configured manually on GitHub webhooks page. */
    webhook_url: string;
}
/** flows-list-request */
export interface FlowsListRequest {
    /** The cursor to begin iteration from. */
    cursor?: string;
    /** ID of Marketplace Item which installed this flow. */
    marketplace_item?: string[];
    /** Parameter to indicate if the response must omit the raw_template. */
    omit_raw_template?: boolean;
    /** Fields to sort the flows by and the direction to sort them. */
    sort_by?: string[];
    /** Deployment status of the flow. */
    status?: FlowStatus[];
}
/** flows-list-response */
export interface FlowsListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     */
    cursor?: string;
    /** List of flows. */
    flows: Flow[];
}
/** function-definition */
export type FunctionDefinition = AtomBase & {
    /** Wrapper over rego policy allowing templated re-usable policy. */
    config_policy?: PolicyInstance;
    /** Name of the function. */
    function_name?: string;
    /** Namespace of the function. */
    namespace?: string;
};
/** function-definition-summary */
export type FunctionDefinitionSummary = AtomBaseSummary;
/** function-definitions-create-request */
export interface FunctionDefinitionsCreateRequest {
    function_definition: CreateFunctionDefinition;
}
/** function-definitions-create-response */
export interface FunctionDefinitionsCreateResponse {
    function_definition: FunctionDefinition;
}
/** function-definitions-delete-request */
export interface FunctionDefinitionsDeleteRequest {
    /** The function definition's DON. */
    id: string;
}
/** function-definitions-get-request */
export interface FunctionDefinitionsGetRequest {
    /** The function definition's DON. */
    id: string;
}
/** function-definitions-get-response */
export interface FunctionDefinitionsGetResponse {
    function_definition: FunctionDefinition;
}
/** function-definitions-list-request */
export interface FunctionDefinitionsListRequest {
    /**
     * Page number for paginated function definition items.
     * @format int32
     */
    page?: number;
    /**
     * Number of function definition items to return per page. Default is
     * 50.
     * @format int32
     */
    per_page?: number;
    /**
     * List of fields to sort the function definition items by and how to
     * sort them. Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
}
/** function-definitions-list-response */
export interface FunctionDefinitionsListResponse {
    /** List of function definitions. */
    function_definitions: FunctionDefinition[];
    /**
     * Total number of function definition items for the request. The
     * function definition items in the response correspond to just one
     * page of results which makes up a portion of the total.
     * @format int32
     */
    total: number;
}
/** function-definitions-update-request */
export interface FunctionDefinitionsUpdateRequest {
    function_definition: UpdateFunctionDefinition;
    /** The function definition's DON. */
    id: string;
}
/** function-definitions-update-response */
export interface FunctionDefinitionsUpdateResponse {
    function_definition: FunctionDefinition;
}
/**
 * general-preferences-group
 * Preferences group for General settings.
 */
export interface GeneralPreferencesGroup {
    /** Preferences group for Availability. */
    availabilty?: AvailabilityPreferencesGroup;
}
/** get-discovery-profile-request */
export interface GetDiscoveryProfileRequest {
    /** Discovery Profile unique ID. */
    profile_id: string;
}
/** get-discovery-profile-response */
export interface GetDiscoveryProfileResponse {
    discovery_profile: DiscoveryProfile;
}
/** get-discovery-run-request */
export interface GetDiscoveryRunRequest {
    /** Discovery run unique ID. */
    id: string;
}
/** get-discovery-run-response */
export interface GetDiscoveryRunResponse {
    run: DiscoveryRun;
}
/** get-discovery-settings-request */
export interface GetDiscoverySettingsRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** get-discovery-settings-response */
export interface GetDiscoverySettingsResponse {
    discovery_settings: DiscoverySettings;
}
/**
 * get-object-member-request
 * A request to get an object member by its DON.
 */
export interface GetObjectMemberRequest {
    /** Globally unique DevRev Object Name (DON) for the Object Member. */
    object_member_id: string;
}
/** get-object-member-response */
export interface GetObjectMemberResponse {
    object_member: ObjectMember;
}
/** Github flow event transition. */
export declare enum GithubFlowEventTransition {
    NewBranchTransition = "new_branch_transition",
    NewBranchWorkCreateTransition = "new_branch_work_create_transition",
    NewCommitTransition = "new_commit_transition",
    PrMergedInprogressToClosedTransition = "pr_merged_inprogress_to_closed_transition",
    PrMergedOpenToClosedTransition = "pr_merged_open_to_closed_transition",
    PrOpenedTransition = "pr_opened_transition"
}
/**
 * global-input
 * global_input defines the schema for input to get from user deploying
 * the flows.
 */
export interface GlobalInput {
    /**
     * Allowed values for this input, applicable only for enum and
     * enum_list types.
     */
    allowed_values?: string[];
    /** Default value to be used if value is not provided. */
    default_value?: string;
    /**
     * Description of the input to be provided by flow author to help the
     * flow user to provide value.
     */
    description?: string;
    /** Display Name. */
    display_name?: string;
    /** The type of input expected from the user. */
    input_type?: GlobalInputInputType;
    /** Name. */
    name: string;
    /** JSON Schema object. */
    schema?: string;
    /** Value. */
    value?: string;
}
/** The type of input expected from the user. */
export declare enum GlobalInputInputType {
    Bool = "bool",
    EmailAddress = "email_address",
    Enum = "enum",
    EnumList = "enum_list",
    Float = "float",
    FloatList = "float_list",
    Integer = "integer",
    IntegerList = "integer_list",
    Json = "json",
    KeyValues = "key_values",
    Part = "part",
    String = "string",
    StringList = "string_list",
    User = "user"
}
/** graphql-request */
export interface GraphqlRequest {
    /** The GraphQL request query. */
    query: string;
    /** The variables to substitute into the query. */
    variables?: object;
}
/** graphql-response */
export interface GraphqlResponse {
    /** The response data. */
    data: object;
    /** The resulting errors. */
    errors?: object[];
    /** Extensions for the response data. */
    extensions?: object;
}
/** group */
export type Group = AtomBase & {
    /** Types of the members allowed in the group. */
    allowed_member_type?: GroupAllowedMemberType;
    /** Conditional roles the membership includes. */
    conditional_roles?: ConditionalRoleSummary[];
    /** Version of the default group. */
    default_version?: string;
    /** Description of the group. */
    description?: string;
    /** IDs of the group(s) that the group includes. */
    includes?: GroupSummary[];
    /** Whether it is a default group. */
    is_default?: boolean;
    /** Name of the group. */
    name?: string;
};
/** Types of the members allowed in the group. */
export declare enum GroupAllowedMemberType {
    DevUser = "dev_user",
    RevUser = "rev_user",
    SysUser = "sys_user"
}
/** group-base */
export interface GroupBase {
    /** Description of the group. */
    description?: string;
    /** Icon associated with the group in the UI. */
    icon_type?: string;
    /** Name of the group. */
    name: string;
}
/** group-summary */
export type GroupSummary = AtomBaseSummary & {
    /** Name of the group. */
    name?: string;
};
/**
 * grouped-vista
 * Represents a group of multiple vistas as a single unit.
 */
export type GroupedVista = VistaBase & GroupedVistaWorksVista & {
    /** Type of DevRev object for which the grouped vista is applicable. */
    filter_type: GroupedVistaFilterType;
    /** Denotes the use case of the grouped vista. */
    flavor?: GroupedVistaFlavor;
};
/** Type of DevRev object for which the grouped vista is applicable. */
export declare enum GroupedVistaFilterType {
    Works = "works"
}
/** Denotes the use case of the grouped vista. */
export declare enum GroupedVistaFlavor {
    Nnl = "nnl",
    SprintBoard = "sprint_board"
}
/** grouped-vista-works-vista */
export interface GroupedVistaWorksVista {
    filter?: GroupedVistaWorksVistaFilter;
    /** The list of vista groups. */
    groups?: WorksVistaGroupItem[];
}
/** grouped-vista-works-vista-filter */
export interface GroupedVistaWorksVistaFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     */
    ancestor_part_ids_v1?: string;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     */
    ancestor_part_v1?: string;
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /** Filters for work belonging to any of the provided parts. */
    applies_to_part_ids_v1?: string;
    /** Filters for work belonging to any of the provided parts. */
    applies_to_part_v1?: string;
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    /** Filters for work created by any of these users. */
    created_by_ids_v1?: string;
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Filters for work created by any of these users. */
    created_by_v1?: string;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /** Filters for work excluding the provided work IDs. */
    exclude_v1?: string;
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Filters for work excluding the provided work IDs. */
    exclude_work_ids_v1?: string;
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Filters for work owned by any of these users. */
    owned_by_ids_v1?: string;
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Filters for work owned by any of these users. */
    owned_by_v1?: string;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /** Filters for work with any of the provided tags. */
    tag_ids_v1?: string;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /** Filters for work with any of the provided tags. */
    tags_v1?: string;
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/**
 * groups-create-request
 * A request to create a new group.
 */
export interface GroupsCreateRequest {
    /** Description of the group. */
    description: string;
    /** Unique name of the group. */
    name: string;
}
/**
 * groups-create-response
 * The response to group creation.
 */
export interface GroupsCreateResponse {
    group: Group;
}
/**
 * groups-delete-request
 * A request to delete a group.
 */
export interface GroupsDeleteRequest {
    /** The ID of the group to delete. */
    id: string;
}
/**
 * groups-delete-response
 * The response to deleting a group.
 */
export type GroupsDeleteResponse = object;
/**
 * groups-list-request
 * A request to get information about a list of groups.
 */
export type GroupsListRequest = object;
/**
 * groups-list-response
 * The response to listing the groups.
 */
export interface GroupsListResponse {
    /** The list of groups. */
    groups: Group[];
}
/**
 * groups-update-request
 * A request to update a group.
 */
export interface GroupsUpdateRequest {
    /** The updated group's description. */
    description?: string;
    /** The ID of the group to update. */
    id: string;
    /** The updated group's name. */
    name?: string;
}
/**
 * groups-update-response
 * The response to group update.
 */
export interface GroupsUpdateResponse {
    group: Group;
}
/** insight */
export type Insight = (RealTimeInsight | WindowBasedInsight) & {
    type: InsightType;
};
/** insight-base */
export type InsightBase = AtomBase & {
    /** Description of insight. */
    description?: string;
    insight_type?: InsightType;
    /** If true, a lower value of this insight is better. */
    inverted?: boolean;
    /** Name of the insight. */
    name?: string;
    /** Parents of this insight. */
    parent_ids?: string[];
    /** Parents of this insight. */
    parent_ids_v1?: string;
};
/** insight-base-summary */
export type InsightBaseSummary = AtomBaseSummary;
export declare enum InsightType {
    RealTimeInsight = "real_time_insight",
    WindowBasedInsight = "window_based_insight"
}
/** insight-value */
export type InsightValue = (RealTimeInsightValue | WindowBasedInsightValue) & {
    type: InsightValueType;
};
/** insight-value-base */
export type InsightValueBase = AtomBase & {
    /** Id of the object for which this value corresponds to. */
    for_object_id?: string;
    /** Id of the object for which this value corresponds to. */
    for_object_id_v1?: string;
    /** Id of the insight for which this value corresponds to. */
    insight_id?: string;
    /** Id of the insight for which this value corresponds to. */
    insight_id_v1?: string;
    insight_value_type?: InsightValueType;
};
/** insight-value-base-summary */
export type InsightValueBaseSummary = AtomBaseSummary;
export declare enum InsightValueType {
    RealTimeInsightValue = "real_time_insight_value",
    WindowBasedInsightValue = "window_based_insight_value"
}
/** insights-get-request */
export interface InsightsGetRequest {
    /** The insights's ID. */
    id: string;
}
/** insights-get-response */
export interface InsightsGetResponse {
    insight: Insight;
}
/** insights-list-request */
export interface InsightsListRequest {
    /**
     * The cursor to begin iteration from, otherwise if not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of insights to return. If not set, then the
     * default is '50'.
     * @format int32
     */
    limit?: number;
}
/** insights-list-response */
export interface InsightsListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     */
    cursor?: string;
    /** The list of insights. */
    insights: Insight[];
}
/** insights-values-list-request */
export interface InsightsValuesListRequest {
    /**
     * The cursor to begin iteration from, otherwise if not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filter based on for_object_id.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    for_object_ids?: string[];
    /** Filter based on insight ids. */
    insight_ids?: string[];
    /**
     * The maximum number of insights to return. If not set, then the
     * default is '50'.
     * @format int32
     */
    limit?: number;
}
/** insights-values-list-response */
export interface InsightsValuesListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     */
    cursor?: string;
    /** The list of insight values. */
    insight_values: InsightValue[];
}
/** Format in which content is defined. */
export declare enum InstructionsFormat {
    Markdown = "markdown"
}
/** invoice */
export type Invoice = AtomBase & {
    /**
     * Final amount due at this time for this invoice. If the invoice
     * total is smaller than the minimum charge amount, for example, or if
     * there is account credit that can be applied to the invoice, the
     * amount_due may be 0. If there is a positive starting_balance for
     * the invoice (the customer owes money), the amount_due will also
     * take that into account. The charge that gets generated for the
     * invoice will be for the amount specified in amount_due.
     * @format double
     */
    amount_due: number;
    /**
     * The amount that was paid.
     * @format double
     */
    amount_paid: number;
    /**
     * The amount remaining that is due.
     * @format double
     */
    amount_remaining: number;
    /**
     * Date on which invoice was generated.
     * @format date-time
     */
    billing_date: string;
    /** Contact Details of the customer. */
    billing_details?: ContactDetails;
    /** The billing contact's email. */
    billing_email?: string;
    /**
     * If the invoice is to be paid, this key needs to be used on the
     * frontend side to complete the payment.
     */
    client_key?: string;
    /** The currency for which the invoice is generated. */
    currency: string;
    /**
     * The date on which payment for this invoice is due. This value will
     * be null for invoices where collection_method=charge_automatically.
     * @format date-time
     */
    due_date?: string;
    /** The individual line items that make up the invoice. */
    invoice_items?: InvoiceItem[];
    /**
     * A unique, identifying string that appears on emails sent to the
     * customer for this invoice.
     */
    invoice_number: string;
    /**
     * If the invoice is to be paid, this id needs to be used on the
     * frontend side to complete the payment.
     */
    payment_intent_id?: string;
    /** URL to download the invoice in pdf format. */
    pdf_url?: string;
    /**
     * End of the usage period during which invoice items were added to
     * this invoice.
     * @format date-time
     */
    period_end: string;
    /**
     * Start of the usage period during which invoice items were added to
     * this invoice.
     * @format date-time
     */
    period_start: string;
    rev?: OrgSummary;
    service_plan?: ServicePlanSummary;
    /** Contact Details of the customer. */
    shipping_details?: ContactDetails;
    /** Status of the invoice. */
    status: InvoiceStatus;
    /**
     * Total of all subscriptions, invoice items, and prorations on the
     * invoice before any invoice level discount or tax is applied.
     * @format double
     */
    subtotal: number;
    /**
     * The amount of tax on this invoice. This is the sum of all the tax
     * amounts on this invoice.
     * @format double
     */
    tax: number;
    /**
     * The invoice total is the sum of charges included in the invoice.
     * @format double
     */
    total: number;
};
/**
 * invoice-item
 * Invoice item describes what is being charged. It contains charged
 * specific to a SKU.
 */
export interface InvoiceItem {
    /**
     * Price Details of the invoice item 1. It would contain a single row
     * if the pricing is standard or item is one time. 2. Multiple rows in
     * case of tiered (graduated/volume) pricing.
     */
    invoice_item_price_details: InvoiceItemPriceDetails[];
    /**
     * SKU for which line item is generated (Used as name of invoice line
     * items for better readability. It is against this name, pricing
     * fields such as quantity, unit_amount, amount, etc are shown).
     */
    sku_name: string;
}
/**
 * invoice-item-price-details
 * Price details of the invoice line item.
 */
export interface InvoiceItemPriceDetails {
    /**
     * Total amount for the line item (quantity * unit_price).
     * @format double
     */
    amount: number;
    /** Description of the invoice line item. */
    description: string;
    /**
     * Quantity of the line item.
     * @format int32
     */
    quantity: number;
    /**
     * Per unit price of the subscription item.
     * @format double
     */
    unit_price: number;
}
/** Status of the invoice. */
export declare enum InvoiceStatus {
    Open = "open",
    Paid = "paid",
    Uncollectible = "uncollectible",
    Void = "void"
}
/** invoice-summary */
export type InvoiceSummary = AtomBaseSummary;
/** Collection method type of the invoice. */
export declare enum InvoicesCollectionMethod {
    ChargeAutomatically = "charge_automatically",
    SendInvoice = "send_invoice"
}
/** invoices-get-request */
export interface InvoicesGetRequest {
    /** The invoice object's DON. */
    id: string;
}
/** invoices-get-response */
export interface InvoicesGetResponse {
    invoice: Invoice;
}
/** invoices-list-request */
export interface InvoicesListRequest {
    /**
     * Filter items which have billing date after the timestamp provided.
     * @format date-time
     */
    after_billing_date?: string;
    /**
     * Filter items which have due date after the timestamp provided.
     * @format date-time
     */
    after_due_date?: string;
    /**
     * Filter items which have billing date before the timestamp provided.
     * @format date-time
     */
    before_billing_date?: string;
    /**
     * Filter items which have due date before the timestamp provided.
     * @format date-time
     */
    before_due_date?: string;
    /** Collection method type of the invoice. */
    collection_method?: InvoicesCollectionMethod;
    /** Filter items by doing queries on service plan. */
    service_plan_id?: string;
    /** Filter items by doing queries on invoice status. */
    statuses?: InvoiceStatus[];
}
/** invoices-list-response */
export interface InvoicesListResponse {
    /** List of invoices. */
    invoices: Invoice[];
}
/** issue */
export type Issue = WorkBase & {
    /**
     * Actual effort to complete the issue.
     * @format double
     */
    actual_effort?: number;
    /** Part versions relevant to the work. */
    applies_to_versions?: string[];
    /** Parts associated based on git events. */
    developed_with?: PartSummary[];
    /**
     * Estimated effort to complete the issue.
     * @format double
     */
    estimated_effort?: number;
    /** Priority of the work based upon impact and criticality. */
    priority?: IssuePriority;
    /** Versions that will contain the resolving commit IDs. */
    release_versions?: string[];
};
/** Priority of the work based upon impact and criticality. */
export declare enum IssuePriority {
    P0 = "p0",
    P1 = "p1",
    P2 = "p2",
    P3 = "p3"
}
/** issue-summary */
export type IssueSummary = WorkBaseSummary & {
    /** Priority of the work based upon impact and criticality. */
    priority?: IssuePriority;
};
/**
 * key-value-pair
 * Stores a string key to string value mapping.
 */
export interface KeyValuePair {
    /** Key. */
    key: string;
    /** Value. */
    value?: string;
}
/** keyring */
export type Keyring = AtomBase & {
    /** Categories associated with the keyring. */
    categories?: string[];
    /** Description of the keyring. */
    description?: string;
    /** External organization ID (e.g. id of github org). */
    external_org_id?: string;
    /** External organization (e.g. name of github org). */
    external_org_name?: string;
    /** Does key have expiration time. */
    is_key_expirable?: boolean;
    /**
     * Key expiration time.
     * @format date-time
     */
    key_expiration?: string;
    /** Key type in authorization header (token, Bearer, Basic, ...). */
    key_type?: string;
    /** Name of the keyring. Doesn't have to be unique. */
    name?: string;
    /** Scope of keyring. */
    scope?: KeyringScope;
    /** keyring status. */
    status?: KeyringStatus;
    /** keyring status message. */
    status_message?: string;
    /** Keyring type defines the external system authentication method. */
    type?: KeyringType;
};
/** Scope of keyring. */
export declare enum KeyringScope {
    Org = "org",
    User = "user"
}
/** keyring status. */
export declare enum KeyringStatus {
    Active = "active",
    CollectionPending = "collection_pending",
    Error = "error",
    SelectOrg = "select_org",
    UserActionRequired = "user_action_required",
    Warning = "warning"
}
/** keyring-summary */
export type KeyringSummary = AtomBaseSummary;
/** Keyring type defines the external system authentication method. */
export declare enum KeyringType {
    Aws = "aws",
    Bitbucket = "bitbucket",
    Cci = "cci",
    Clearbit = "clearbit",
    Datadog = "datadog",
    DevrevPat = "devrev_pat",
    Discord = "discord",
    DomainVerification = "domain_verification",
    FlowSecret = "flow_secret",
    Gcp = "gcp",
    GhApp = "gh_app",
    GhOauth = "gh_oauth",
    GhPat = "gh_pat",
    Google = "google",
    Intercom = "intercom",
    Jira = "jira",
    Kubernetes = "kubernetes",
    LinearOauth = "linear_oauth",
    LinearPat = "linear_pat",
    SalesforceSales = "salesforce_sales",
    SalesforceService = "salesforce_service",
    Sendgrid = "sendgrid",
    ServiceAccounts = "service_accounts",
    Servicenow = "servicenow",
    Slack = "slack",
    Stripe = "stripe",
    Zendesk = "zendesk"
}
/** keyrings-create-callback-request */
export interface KeyringsCreateCallbackRequest {
    /** Request for user sign-in authentication */
    authuser?: string;
    /** Code to exchange for an access token */
    code?: string;
    /** OAuth2 short error */
    error?: string;
    /** OAuth2 error description */
    error_description?: string;
    /** Server ID where the application is authorized [for discord] */
    guild_id?: string;
    /** The hosted domain of the user account */
    hd?: string;
    /** Github installation ID */
    installation_id?: string;
    /** OAuth2 permissions for an application */
    permissions?: string;
    /** User consent dialog */
    prompt?: string;
    /** OAuth2 scope */
    scope?: string;
    /** Github action information */
    setup_action?: string;
    /** State value given to the authorization request */
    state?: string;
}
/** keyrings-create-request */
export interface KeyringsCreateRequest {
    keyring: CreateKeyring;
    /**
     * Optional subdomain used for API calls to the external system (for
     * oauth2).
     */
    subdomain?: string;
    /** UI callback (for oauth2). */
    ui_callback_url?: string;
}
/** keyrings-create-response */
export interface KeyringsCreateResponse {
    keyring?: Keyring;
    /** Redirect to. */
    redirect_url?: string;
}
/** keyrings-delete-request */
export interface KeyringsDeleteRequest {
    /** The keyring's ID. */
    id: string;
}
/** keyrings-get-request */
export interface KeyringsGetRequest {
    /** The keyring's ID. */
    id: string;
}
/** keyrings-get-response */
export interface KeyringsGetResponse {
    keyring: Keyring;
}
/** keyrings-list-request */
export interface KeyringsListRequest {
    /** Filters keyrings with associated categories. */
    categories?: string[];
    /** The cursor to begin iteration from */
    cursor?: string;
    /**
     * Comma separated fields to sort the items by and how to sort them
     * (field_name1:[asc/desc],field_name2:[asc/desc]).
     */
    sort_by?: string;
    /** Filters for keyring of the provided types. */
    types?: KeyringType[];
}
/** keyrings-list-response */
export interface KeyringsListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     */
    cursor?: string;
    /** List of keyrings. */
    keyrings: Keyring[];
}
/** keyrings-update-request */
export interface KeyringsUpdateRequest {
    /** The keyring's ID. */
    id: string;
    keyring?: UpdateKeyring;
    /** UI callback (for oauth2). */
    ui_callback_url?: string;
}
/** keyrings-update-response */
export interface KeyringsUpdateResponse {
    keyring?: Keyring;
    /** The updated keyring. */
    redirect_url?: string;
}
/** knowledge-v2-request */
export type KnowledgeV2Request = object;
/** knowledge-v2-response */
export interface KnowledgeV2Response {
    /** List of all the edges in knowledge graph */
    edges: EdgeV2[];
    /** List of all the vertices in knowledge graph */
    vertices: VertexV2[];
}
/** language-resource */
export interface LanguageResource {
    /**
     * Supported language code, generally consisting of its ISO 639-1
     * identifier. (E.g. 'en', 'ja'). In certain cases, BCP-47 codes
     * including language + region identifiers are returned (e.g. 'zh-TW'
     * and 'zh-CH').
     */
    language: string;
    /**
     * Human readable name of the language localized to the target
     * language.
     */
    name: string;
}
/** line-item-base */
export type LineItemBase = AtomBase & {
    /** Tells if the item is added as mandatory to the service plan. */
    is_mandatory: boolean;
    pricing: PricingSummary;
    /**
     * The quantity of units purchased.
     * @format int32
     */
    quantity: number;
    rev: OrgSummary;
    service_plan: ServicePlanSummary;
    sku: SkuSummary;
    /**
     * The used quantity units.
     * @format int32
     */
    used_quantity: number;
};
/** line-item-base-summary */
export type LineItemBaseSummary = AtomBaseSummary & {
    /** Tells if the item is added as mandatory to the service plan. */
    is_mandatory: boolean;
    pricing: PricingSummary;
    sku: SkuSummary;
};
/** link */
export type Link = AtomBase & {
    source: LinkEndpointSummary;
    target: LinkEndpointSummary;
    /** Type of link used to define the relationship. */
    type: LinkType;
};
/** link-endpoint-summary */
export type LinkEndpointSummary = (ArtifactSummary | CapabilitySummary | ConversationSummary | CustomPartSummary | CustomWorkSummary | EnhancementSummary | FeatureSummary | IssueSummary | LinkableSummary | ProductSummary | RunnableSummary | TaskSummary | TicketSummary) & {
    type: LinkEndpointType;
};
export declare enum LinkEndpointType {
    Artifact = "artifact",
    Capability = "capability",
    Conversation = "conversation",
    CustomPart = "custom_part",
    CustomWork = "custom_work",
    Enhancement = "enhancement",
    Feature = "feature",
    Issue = "issue",
    Linkable = "linkable",
    Product = "product",
    Runnable = "runnable",
    Task = "task",
    Ticket = "ticket"
}
/** link-search-summary */
export type LinkSearchSummary = SearchSummaryBase & {
    link: LinkSummary;
};
/** link-summary */
export type LinkSummary = AtomBaseSummary & {
    source: LinkEndpointSummary;
    target: LinkEndpointSummary;
};
/**
 * link-target-request
 * Link target request.
 */
export interface LinkTargetRequest {
    /** Work fields required for recommendation. */
    context: WorkContext;
    /** Type of link used to define the relationship. */
    link_type: LinkType;
    /**
     * Number of results to be returned.
     * @format int32
     */
    num_results?: number;
    /**
     * Boolean to indicate if the work context is source of the link
     * relationship.
     */
    source: boolean;
}
/**
 * link-target-response
 * Link target response.
 */
export interface LinkTargetResponse {
    /** The link target results. */
    results: LinkTargetResult[];
}
/**
 * link-target-result
 * A link target result.
 */
export interface LinkTargetResult {
    part?: PartSummary;
    recommendation?: 'part' | 'work';
    work?: WorkSummary;
}
/** Type of link used to define the relationship. */
export declare enum LinkType {
    DevelopedWith = "developed_with",
    Imports = "imports",
    IsDependentOn = "is_dependent_on",
    IsDuplicateOf = "is_duplicate_of",
    IsParentOf = "is_parent_of",
    IsPartOf = "is_part_of",
    IsRelatedTo = "is_related_to",
    Serves = "serves"
}
/** linkable */
export type Linkable = PartBase & {
    /**
     * Code part surface area is defined as all the source files or file
     * globs that make up this code part. This field lists the surface
     * area of this code part as it was inferred automatically.
     */
    code_inferred_surface_area?: string[];
    /**
     * The details of the last inference of this part.
     * @format int32
     */
    code_last_inference_details?: number;
    /** Paths in the repository for the code part. */
    code_repo_paths?: string;
    /** URL to the server & repo for the code part. */
    code_repo_url?: string;
    /** Versions of the code. */
    code_versions?: number[];
    /**
     * A confidence score computed by the inference engine. Currently, the
     * score is not normalized across different part inferences. Until
     * this is improved, this should only be comparable to confidence of
     * same part type.
     * @format double
     */
    discovery_confidence?: number;
    /**
     * A evidences that the inferer were able to find that justify the
     * inference outcome.
     */
    discovery_evidences?: string[];
    /**
     * The time when this inference occurred.
     * @format date-time
     */
    discovery_last_inferred_at?: string;
    /** The kind of linkable. */
    kind?: LinkableKind;
};
/** The kind of linkable. */
export declare enum LinkableKind {
    Component = "component",
    Library = "library"
}
/** linkable-pin-summary */
export type LinkablePinSummary = PartPinBaseSummary;
/** linkable-summary */
export type LinkableSummary = PartBaseSummary;
/**
 * links-create-request
 * The request to create a new link.
 */
export interface LinksCreateRequest {
    /** The ID of the source object. */
    source_id: string;
    /** The ID of the target object. */
    target_id: string;
    /** Type of link used to define the relationship. */
    type: LinkType;
}
/**
 * links-create-response
 * The response to creating a new link.
 */
export interface LinksCreateResponse {
    link: Link;
}
/**
 * links-delete-request
 * The request to delete a link.
 */
export interface LinksDeleteRequest {
    /** The ID of the link to delete. */
    id: string;
}
/**
 * links-delete-response
 * The response for deleting a link.
 */
export type LinksDeleteResponse = object;
/**
 * The direction of link, which can either be outbound such that the
 * object is the source of the link, otherwise inbound where the object is
 * the target of the link.
 */
export declare enum LinksDirection {
    IsSource = "is_source",
    IsTarget = "is_target"
}
/**
 * links-get-request
 * The request to get a link's information.
 */
export interface LinksGetRequest {
    /** The requested link's ID. */
    id: string;
}
/**
 * links-get-response
 * The response to getting a link's information.
 */
export interface LinksGetResponse {
    link: Link;
}
/** links-group */
export interface LinksGroup {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** Unique key according to which the items are grouped. */
    key: string;
    /** The group of links. */
    links: Link[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** links-group-request */
export interface LinksGroupRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The direction of link, which can either be outbound such that the
     * object is the source of the link, otherwise inbound where the object is
     * the target of the link.
     */
    direction?: LinksDirection;
    /** The field to group the links by. */
    group_by: string;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of links to return for an individual group. If
     * not set, then the default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** The ID of the object to list the link groups for. */
    object_id: string;
    /**
     * The link types to filter for, otherwise if not present, all link
     * types are included.
     */
    types?: LinkType[];
}
/** links-group-response */
export interface LinksGroupResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** The list of groups. */
    groups: LinksGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * links-list-request
 * The request to get information about a list of links.
 */
export interface LinksListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The direction of link, which can either be outbound such that the
     * object is the source of the link, otherwise inbound where the object is
     * the target of the link.
     */
    direction?: LinksDirection;
    /**
     * The maximum number of links to return. If not set, then the default
     * is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** The ID of the object to list the links for. */
    object_id: string;
    /**
     * The link types to filter for, otherwise if not present, all link
     * types are included.
     */
    types?: LinkType[];
}
/**
 * links-list-response
 * The response to listing the links.
 */
export interface LinksListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** The list of links. */
    links: Link[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * links-replace-request
 * The request to replace a link.
 */
export interface LinksReplaceRequest {
    /** The ID of the link object to be replaced. */
    replace_link_id: string;
    /** The ID of the source object. */
    source_id: string;
    /** The ID of the target object. */
    target_id: string;
    /** Type of link used to define the relationship. */
    type: LinkType;
}
/**
 * links-replace-response
 * The response to replacing a link.
 */
export interface LinksReplaceResponse {
    link: Link;
}
/**
 * list-dev-user-invitations-request
 * A request to get the list of Dev organizations that the user is
 * invited.
 */
export type ListDevUserInvitationsRequest = object;
/**
 * list-dev-user-invitations-response
 * The response to get the list of Dev organizations that the user is
 * invited to.
 */
export interface ListDevUserInvitationsResponse {
    /** List of invitations to Dev organizations the user is invited to. */
    invites: DevUserInvitation[];
}
/** list-discovery-profiles-request */
export interface ListDiscoveryProfilesRequest {
    /**
     * Filters for discovery profile created after the timestamp provided.
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for discovery profile created before the timestamp
     * provided.
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for discovery profile created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of discovery profiles to return. If not set,
     * then the default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Filters for discovery profile modified after the provided
     * timestamp.
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for discovery profile modified before the provided
     * timestamp.
     * @format date-time
     */
    modified_before_date?: string;
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
    /** Filters for discovery profile with any of these names. */
    profile_name?: string[];
    /** Fields to sort the works by and the direction to sort them. */
    sort_by?: string[];
}
/** list-discovery-profiles-response */
export interface ListDiscoveryProfilesResponse {
    /** The list of discovery profiles. */
    discovery_profile: DiscoveryProfile[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** list-discovery-sources-request */
export interface ListDiscoverySourcesRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** list-discovery-sources-response */
export interface ListDiscoverySourcesResponse {
    /** List of sources from which data was collected for parts discovery. */
    discovery_sources: DiscoverySource[];
}
/**
 * The iteration mode to use. If "after", then entries after the provided
 * cursor will be returned, or if no cursor is provided, then from the
 * beginning. If "before", then entries before the provided cursor will be
 * returned, or if no cursor is provided, then from the end. Entries will
 * always be returned in the specified sort-by order.
 */
export declare enum ListMode {
    After = "after",
    Before = "before"
}
/**
 * list-object-member-request
 * A request to list object members.
 */
export interface ListObjectMemberRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of object members to return. If not set, then
     * the default is '50'.
     * @format int32
     */
    limit?: number;
    /** ID of the user or group. */
    member_ids?: string[];
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Globally unique DevRev Object Name (DON) for the object where the
     * member is being added.
     */
    object_ids?: string[];
}
/**
 * list-object-member-response
 * List of filtered object members.
 */
export interface ListObjectMemberResponse {
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /** List of filtered object members. */
    object_members: ObjectMember[];
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * lobbies-list-request
 * The request to get information about a list of lobbies.
 */
export interface LobbiesListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of lobbies to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
}
/**
 * lobbies-list-response
 * The response to listing the lobbies.
 */
export interface LobbiesListResponse {
    /** The list of lobbies. */
    lobbies: Conversation[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** marketplace */
export type Marketplace = AtomBase & {
    /** Description of the marketplace. */
    description?: string;
    /** Marketplace type. */
    marketplace_type?: MarketplaceType;
    /** Name of the marketplace. */
    name?: string;
    /** URL slug of the marketplace. */
    slug?: string;
};
/** marketplace-categories-get-request */
export interface MarketplaceCategoriesGetRequest {
    /** The marketplace category ID. */
    id: string;
}
/** marketplace-categories-get-response */
export interface MarketplaceCategoriesGetResponse {
    marketplace_category: MarketplaceCategory;
}
/** marketplace-categories-list-request */
export interface MarketplaceCategoriesListRequest {
    /** The marketplace ID. */
    marketplace_id: string;
}
/** marketplace-categories-list-response */
export interface MarketplaceCategoriesListResponse {
    /** The list of marketplace categories. */
    marketplace_categories: MarketplaceCategory[];
}
/** marketplace-category */
export type MarketplaceCategory = AtomBase & {
    access_level?: AccessLevel;
    /** An informative description for the category. */
    description?: string;
    marketplace?: MarketplaceSummary;
    /** The name of the category. The name is guaranteed to be unique. */
    name: string;
    parent_marketplace_category?: MarketplaceCategorySummary;
};
/** marketplace-category-summary */
export type MarketplaceCategorySummary = AtomBaseSummary & {
    /** The name of the category. The name is guaranteed to be unique. */
    name: string;
};
/** marketplace-item */
export type MarketplaceItem = AtomBase & {
    /**
     * Artifacts relevant to the marketplace item (e.g. screenshots,
     * videos, banner image, icon).
     */
    artifacts?: ArtifactSummary[];
    /** Categories relevant to the marketplace item. */
    categories?: MarketplaceCategorySummary[];
    /**
     * Flag indicating whether marketplace item will be soon available to
     * purchase.
     */
    coming_soon?: boolean;
    /** Description of the marketplace item (Markdown formatted text). */
    description?: string;
    icon_artifact?: ArtifactSummary;
    /** Marketplace item type. */
    item_type?: MarketplaceItemItemType;
    /** Keywords of the marketplace item. */
    keywords?: string;
    marketplace?: MarketplaceSummary;
    /**
     * Meta score of the marketplace item.
     * @format int64
     */
    meta_score?: number;
    /** Name of the marketplace item. */
    name?: string;
    owned_by?: OrgSummary;
    /** URL slug of the marketplace item. */
    slug?: string;
    /** State of the marketplace item. */
    state?: MarketplaceItemState;
    /** Stock keeping units relevant to the marketplace item. */
    stock_keeping_units?: SkuSummary[];
    /** Summary of the marketplace item. */
    summary?: string;
    /** Tagline of the marketplace item. */
    tagline?: string;
    /** Information about the released template. */
    template?: Template;
    type?: MarketplaceItemType;
};
/** marketplace-item-artifact-list-update */
export interface MarketplaceItemArtifactListUpdate {
    /**
     * Artifact IDs to be added to the marketplace item.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    add?: string[];
    /**
     * Artifact IDs to be removed from the marketplace item.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    remove?: string[];
    /**
     * Artifact IDs to be set to the marketplace item.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    set?: string[];
}
/** marketplace-item-category-list-update */
export interface MarketplaceItemCategoryListUpdate {
    /** Categories to be added to the marketplace item. */
    add?: string[];
    /** Categories to be removed from the marketplace item. */
    remove?: string[];
    /** Categories to be set to the marketplace item. */
    set?: string[];
}
/** Marketplace item type. */
export declare enum MarketplaceItemItemType {
    App = "app",
    Flow = "flow",
    Snapin = "snapin"
}
/** marketplace-item-sku-list-update */
export interface MarketplaceItemSkuListUpdate {
    /** SKUs to be added to the marketplace item. */
    add?: string[];
    /** SKUs to be removed from the marketplace item. */
    remove?: string[];
    /** SKUs to be set to the marketplace item. */
    set?: string[];
}
/** State of the marketplace item. */
export declare enum MarketplaceItemState {
    Draft = "draft",
    EndOfLife = "end_of_life",
    EndOfSale = "end_of_sale",
    InReview = "in_review",
    Published = "published"
}
/** marketplace-item-summary */
export type MarketplaceItemSummary = AtomBaseSummary & {
    /** Marketplace item type. */
    item_type?: MarketplaceItemItemType;
    /** Name of the marketplace item. */
    name?: string;
};
export declare enum MarketplaceItemType {
    App = "app",
    Flow = "flow",
    Snapin = "snapin"
}
/** marketplace-item-upsert-template */
export interface MarketplaceItemUpsertTemplate {
    /**
     * Artifact ID relevant to the marketplace item template.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    artifact_id: string;
    /** Version of the latest marketplace item template. */
    version: string;
}
/**
 * marketplace-items-create-request
 * A request to create a new marketplace item.
 */
export interface MarketplaceItemsCreateRequest {
    /**
     * Artifact IDs relevant to the marketplace item.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifact_ids?: string[];
    /**
     * Flag indicating whether marketplace item will be soon available to
     * purchase.
     */
    coming_soon?: boolean;
    /** Description of the marketplace item (Markdown formatted text). */
    description: string;
    /**
     * Artifact ID relevant to the marketplace item icon.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    icon_artifact_id: string;
    /** Marketplace item type. */
    item_type?: MarketplaceItemItemType;
    /** Keywords of the marketplace item. */
    keywords?: string;
    /** Manifest of the marketplace item. */
    manifest?: string;
    /** Marketplace category IDs relevant to the marketplace item. */
    marketplace_category_ids?: string[];
    /** Markteplace where the marketplace item will be created. */
    marketplace_id: string;
    /**
     * Meta score of the marketplace item.
     * @format int64
     */
    meta_score?: number;
    /** The name of the marketplace item. */
    name: string;
    /** Stock keeping unit IDs relevant to the marketplace item. */
    sku_ids?: string[];
    /** URL slug of the marketplace item. */
    slug: string;
    /** Summary of the marketplace item. */
    summary: string;
    /** Tagline of the marketplace item. */
    tagline: string;
    template?: MarketplaceItemUpsertTemplate;
    type?: MarketplaceItemType;
}
/** marketplace-items-create-response */
export interface MarketplaceItemsCreateResponse {
    marketplace_item: MarketplaceItem;
}
/** marketplace-items-delete-request */
export interface MarketplaceItemsDeleteRequest {
    /** The marketplace item's ID. */
    id: string;
}
/** marketplace-items-get-request */
export interface MarketplaceItemsGetRequest {
    /** The marketplace item's ID. */
    id?: string;
    /** Markteplace ID where to search a marketplace item by slug. */
    marketplace_id?: string;
    /** The marketplace item's slug. */
    slug?: string;
}
/** marketplace-items-get-response */
export interface MarketplaceItemsGetResponse {
    marketplace_item: MarketplaceItem;
}
/** marketplace-items-install-request */
export interface MarketplaceItemsInstallRequest {
    /** The marketplace item's ID. */
    id: string;
}
/** marketplace-items-install-response */
export interface MarketplaceItemsInstallResponse {
    created_object: AtomSummary;
}
/** marketplace-items-list-request */
export interface MarketplaceItemsListRequest {
    /**
     * To start listing marketplace items cursor field should not be
     * provided. Set cursor to value returned by the previous call to list
     * items in the next page.
     */
    cursor?: string;
    /**
     * Limit for how many items to be retrieved per page. Default is 50.
     * @format int32
     */
    limit?: number;
    /** Marketplace category where to list marketplace items. */
    marketplace_category_id?: string;
    /** Markteplace ID where to list marketplace items. */
    marketplace_id?: string;
    /**
     * List of fields to sort the marketplace item object, by and how to
     * sort them. Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
}
/** marketplace-items-list-response */
export interface MarketplaceItemsListResponse {
    /**
     * Next cursor to continue listing marketplace items. If cursor is not
     * set you have reached the last page of items.
     */
    cursor?: string;
    /** The list of marketplace items. */
    marketplace_items: MarketplaceItem[];
}
/** marketplace-items-transition-request */
export interface MarketplaceItemsTransitionRequest {
    /** The marketplace item's ID. */
    id: string;
    /** State of the marketplace item. */
    state: MarketplaceItemState;
}
/** marketplace-items-transition-response */
export interface MarketplaceItemsTransitionResponse {
    marketplace_item: MarketplaceItem;
}
/** marketplace-items-update-request */
export interface MarketplaceItemsUpdateRequest {
    artifact_ids?: MarketplaceItemArtifactListUpdate;
    category_ids?: MarketplaceItemCategoryListUpdate;
    /**
     * Flag indicating whether marketplace item will be soon available to
     * purchase.
     */
    coming_soon?: boolean;
    /** Description of the marketplace item. */
    description?: string;
    /**
     * Artifact ID relevant to the marketplace item icon.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    icon_artifact_id?: string;
    /** The marketplace item's ID. */
    id: string;
    /** Marketplace item type. */
    item_type?: MarketplaceItemItemType;
    /** Keywords of the marketplace item. */
    keywords?: string;
    /** Manifest of the marketplace item. */
    manifest?: string;
    /**
     * Meta score of the marketplace item.
     * @format int64
     */
    meta_score?: number;
    /** Name of the marketplace item. */
    name?: string;
    sku_ids?: MarketplaceItemSkuListUpdate;
    /** Summary of the marketplace item. */
    summary?: string;
    /** Tagline of the marketplace item. */
    tagline?: string;
    template?: MarketplaceItemUpsertTemplate;
}
/** marketplace-items-update-response */
export interface MarketplaceItemsUpdateResponse {
    marketplace_item: MarketplaceItem;
}
/** marketplace-summary */
export type MarketplaceSummary = AtomBaseSummary & {
    /** Marketplace type. */
    marketplace_type?: MarketplaceType;
    /** Name of the marketplace. */
    name?: string;
    /** URL slug of the marketplace. */
    slug?: string;
};
/** Marketplace type. */
export declare enum MarketplaceType {
    Organization = "organization",
    Universal = "universal"
}
/** marketplaces-get-request */
export interface MarketplacesGetRequest {
    /** The marketplace DON. */
    id: string;
}
/** marketplaces-get-response */
export interface MarketplacesGetResponse {
    marketplace: Marketplace;
}
/** marketplaces-list-request */
export type MarketplacesListRequest = object;
/** marketplaces-list-response */
export interface MarketplacesListResponse {
    /** The list of marketplaces. */
    marketplaces: Marketplace[];
}
/**
 * media
 * Media object details.
 */
export interface Media {
    artifact?: ArtifactSummary;
    /** Source of the media. */
    source: string;
    /** URL to an external media. */
    url?: string;
}
/** meeting-summary */
export type MeetingSummary = EngagementBaseSummary;
/** metric-data-point */
export interface MetricDataPoint {
    /** Key/Value pairs used for specifying additional attributes. */
    dimensions?: MetricDataPointDimension[];
    /**
     * Timestamp in unix nanoseconds when metric value is captured.
     * @format int64
     */
    timestamp_nsecs: number;
    /**
     * Metric value denoting object usage, object state etc.
     * @format double
     */
    value: number;
}
/** metric-data-point-dimension */
export interface MetricDataPointDimension {
    /** key is used to specify dimension name. */
    name: string;
    /** value is used to specify value for given dimension name. */
    value: string;
}
/** metric-definition-summary */
export type MetricDefinitionSummary = AtomBaseSummary & {
    /** Human readable name of the metric. */
    name?: string;
    /**
     * The type of the metric, differentiating time-based metrics, which
     * actually track real time from other metrics tracking general values.
     */
    type?: MetricDefinitionType;
};
/**
 * The type of the metric, differentiating time-based metrics, which
 * actually track real time from other metrics tracking general values.
 */
export declare enum MetricDefinitionType {
    Time = "time",
    Value = "value"
}
/** metrics-data */
export interface MetricsData {
    /** One or more data points collected for a given metric. */
    data_points: MetricDataPoint[];
    /**
     * Name of metric which is being measured. For eg. #ofAPIcalls,
     * #ofActiveUsers etc.
     */
    name: string;
    /** Rev Org ID or customer org ref for which metric is being published. */
    org_ref?: string;
    /** Rev User ID or user ref for which metric is being published. */
    user_ref?: string;
}
/** metrics-data-ingest-request */
export interface MetricsDataIngestRequest {
    /** Metrics records received from Dev orgs. */
    metrics: MetricsData[];
}
/**
 * mfz-defaults-seed-request
 * A request to seed default groups, conditional roles and group members
 * for the authenticated user's dev organization.
 */
export interface MfzDefaultsSeedRequest {
    /**
     * Whether to fill the existing users into default groups for the
     * authenticated dev organization.
     */
    backfill: boolean;
}
/**
 * mfz-defaults-seed-response
 * Response object for seeding mfz defaults request.
 */
export type MfzDefaultsSeedResponse = object;
/**
 * microflow-action-event
 * Microflow action external annotated event.
 */
export interface MicroflowActionEvent {
    /** The name of source app. */
    app?: string;
    /** The user ID of the user in source app. */
    app_user_id?: string;
    /** The ID of the event. */
    event_id?: string;
    /** The metadata of the event. */
    event_metadata?: KeyValuePair[];
    /** The summary of the event. */
    event_summary?: string;
    /** The type of the event. */
    event_type?: string;
    /** The URL of the event. */
    event_url?: string;
    /** The message in the event. */
    message?: string;
}
/** microflow-definition */
export type MicroflowDefinition = AtomBase & {
    /** JSON defining how microflow is categorized for object type. */
    categorization_fields_json?: string;
    /** Object type on which the microflow is defined on. */
    defined_on_object_type?: MicroflowDefinitionDefinedOnObjectType;
    /** Description of the microflow. */
    description?: string;
    draft_of_microflow_id?: AtomSummary;
    /** Name of the microflow. */
    name?: string;
    /** Publish status of the microflow. */
    publish_status?: MicroflowDefinitionPublishStatus;
    /** Path of the state field (in dotted notation). */
    state_field_path?: string;
    /** Possible states of the object on which microflow is defined. */
    states?: MicroflowTargetObjectState[];
    /** Possible transitions in the microflow. */
    transitions?: MicroflowTargetObjectTransition[];
};
/** Object type on which the microflow is defined on. */
export declare enum MicroflowDefinitionDefinedOnObjectType {
    Part = "part",
    Work = "work"
}
/** Publish status of the microflow. */
export declare enum MicroflowDefinitionPublishStatus {
    Active = "active",
    Deprecated = "deprecated",
    Draft = "draft"
}
/** microflow-definition-summary */
export type MicroflowDefinitionSummary = AtomBaseSummary;
/** microflow-definitions-create-draft-request */
export interface MicroflowDefinitionsCreateDraftRequest {
    /**
     * The DON of the published microflow whose draft is being created.
     * The draft microflow will be created as a copy of the published
     * microflow.
     */
    published_microflow_id: string;
}
/** microflow-definitions-create-draft-response */
export interface MicroflowDefinitionsCreateDraftResponse {
    microflow_definition: MicroflowDefinition;
}
/** microflow-definitions-create-request */
export interface MicroflowDefinitionsCreateRequest {
    microflow_definition: CreateMicroflowDefinition;
}
/** microflow-definitions-create-response */
export interface MicroflowDefinitionsCreateResponse {
    microflow_definition: MicroflowDefinition;
}
/** microflow-definitions-delete-request */
export interface MicroflowDefinitionsDeleteRequest {
    /** The microflow definition's ID. */
    id: string;
}
/** microflow-definitions-get-draft-request */
export interface MicroflowDefinitionsGetDraftRequest {
    /** The published microflow's DON */
    published_microflow_id: string;
}
/** microflow-definitions-get-draft-response */
export interface MicroflowDefinitionsGetDraftResponse {
    microflow_definition: MicroflowDefinition;
}
/** microflow-definitions-get-or-create-draft-request */
export interface MicroflowDefinitionsGetOrCreateDraftRequest {
    /** The published microflow's DON */
    published_microflow_id: string;
}
/** microflow-definitions-get-or-create-draft-response */
export interface MicroflowDefinitionsGetOrCreateDraftResponse {
    microflow_definition: MicroflowDefinition;
}
/** microflow-definitions-get-request */
export interface MicroflowDefinitionsGetRequest {
    /** The microflow definition's ID. */
    id: string;
}
/** microflow-definitions-get-response */
export interface MicroflowDefinitionsGetResponse {
    microflow_definition: MicroflowDefinition;
}
/** microflow-definitions-list-request */
export interface MicroflowDefinitionsListRequest {
    /**
     * Page number for paginated microflow definition items.
     * @format int32
     */
    page?: number;
    /**
     * Number of microflow definition items to return per page. Default is
     * 50.
     * @format int32
     */
    per_page?: number;
    /**
     * List of fields to sort the microflow definition items by and how to
     * sort them. Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
}
/** microflow-definitions-list-response */
export interface MicroflowDefinitionsListResponse {
    /** List of microflow definitions. */
    microflow_definitions: MicroflowDefinition[];
    /**
     * Total number of microflow definition items for the request. The
     * microflow definition items in the response correspond to just one
     * page of results which makes up a portion of the total.
     * @format int32
     */
    total: number;
}
/** microflow-definitions-publish-request */
export interface MicroflowDefinitionsPublishRequest {
    /** The microflow definition's ID. */
    id: string;
}
/** microflow-definitions-update-request */
export interface MicroflowDefinitionsUpdateRequest {
    /** The microflow definition's ID. */
    id: string;
    microflow_definition: UpdateMicroflowDefinition;
}
/** microflow-definitions-update-response */
export interface MicroflowDefinitionsUpdateResponse {
    microflow_definition: MicroflowDefinition;
}
/**
 * microflow-target-object-state
 * Represents state of object on which microflow is defined.
 */
export interface MicroflowTargetObjectState {
    /** Description of the state. */
    description?: string;
    /** System generated ID of the state. */
    id?: string;
    /** Name of the state. */
    name?: string;
}
/**
 * microflow-target-object-transition
 * Defined logic for transition between states.
 */
export interface MicroflowTargetObjectTransition {
    /** Set of triggers which could execute this transition. */
    allowed_triggers?: MicroflowTriggerDefinition[];
    /** Wrapper over rego policy allowing templated re-usable policy. */
    conditions?: PolicyInstance;
    /** Description of the transition. */
    description?: string;
    /** Set of source states for the transition. */
    from_states?: string[];
    /** Whether this is a global transition. */
    global?: boolean;
    /** Identifier for this transition (unique within a microflow). */
    id?: string;
    /** Whether this is an initial transition. */
    initial?: boolean;
    /** Whether a button is displayed for the transition. */
    is_ui_action?: boolean;
    /** The name of the transition, unique within a microflow. */
    name?: string;
    /** Functions executed asynchronously, on transition success. */
    post_function_definitions_ids?: AtomSummary[];
    /** Functions executed synchronously with state change. */
    pre_function_definitions_ids?: AtomSummary[];
    /** The destination state of the transition. */
    to_state?: string;
    /** Wrapper over rego policy allowing templated re-usable policy. */
    validations?: PolicyInstance;
}
/**
 * microflow-trigger-definition
 * Defines a trigger for a microflow.
 */
export interface MicroflowTriggerDefinition {
    /** Configuration defining applicable events from the source. */
    config?: string;
    /** ID of the event source being subscribed. */
    event_source_id?: string;
    /** ID of the event source being subscribed. */
    event_source_id_v1?: string;
}
/** microflows-target-object-states-create-request */
export interface MicroflowsTargetObjectStatesCreateRequest {
    /** The microflow definition's ID. */
    microflow_id: string;
    state: CreateMicroflowTargetObjectState;
}
/** microflows-target-object-states-create-response */
export interface MicroflowsTargetObjectStatesCreateResponse {
    /** Represents state of object on which microflow is defined. */
    state: MicroflowTargetObjectState;
}
/** microflows-target-object-states-delete-request */
export interface MicroflowsTargetObjectStatesDeleteRequest {
    /** The microflow definition's ID. */
    microflow_id: string;
    /** The state's ID. */
    state_id: string;
}
/** microflows-target-object-states-update-request */
export interface MicroflowsTargetObjectStatesUpdateRequest {
    /** The microflow definition's ID. */
    microflow_id: string;
    state: UpdateMicroflowTargetObjectState;
    /** The state's ID. */
    state_id: string;
}
/** microflows-target-object-states-update-response */
export interface MicroflowsTargetObjectStatesUpdateResponse {
    /** Represents state of object on which microflow is defined. */
    state: MicroflowTargetObjectState;
}
/** microflows-target-object-transitions-create-request */
export interface MicroflowsTargetObjectTransitionsCreateRequest {
    /** The microflow definition's ID. */
    microflow_id: string;
    transition: CreateMicroflowTargetObjectTransition;
}
/** microflows-target-object-transitions-create-response */
export interface MicroflowsTargetObjectTransitionsCreateResponse {
    /** Defined logic for transition between states. */
    transition: MicroflowTargetObjectTransition;
}
/** microflows-target-object-transitions-delete-request */
export interface MicroflowsTargetObjectTransitionsDeleteRequest {
    /** The microflow definition's ID. */
    microflow_id: string;
    /** The transition's ID. */
    transition_id: string;
}
/** microflows-target-object-transitions-update-request */
export interface MicroflowsTargetObjectTransitionsUpdateRequest {
    /** The microflow definition's ID. */
    microflow_id: string;
    transition: UpdateMicroflowTargetObjectTransition;
    /** The transition's ID. */
    transition_id: string;
}
/** microflows-target-object-transitions-update-response */
export interface MicroflowsTargetObjectTransitionsUpdateResponse {
    /** Defined logic for transition between states. */
    transition: MicroflowTargetObjectTransition;
}
/** microservice */
export type Microservice = PartBase & {
    development_owner?: UserSummary;
    pm_owner?: UserSummary;
    qa_owner?: UserSummary;
};
/** microservice-summary */
export type MicroserviceSummary = PartBaseSummary;
/**
 * mutation-info-field
 * Mutation purpose and related metadata.
 */
export interface MutationInfoField {
    merged_to_part?: PartSummary;
    /** Parent Ids of the part before mutation. */
    old_parent_parts: PartSummary[];
    promoted_part?: PartSummary;
    /** Purpose of mutation. */
    purpose?: string;
}
/** news */
export type News = AtomBase & {
    access_level?: AccessLevel;
    /** Content format and text for the news. */
    content: Content;
    /** Media that is shown on the cover of the news. */
    cover_media?: Media[];
    /** Keywords associated with the object. */
    keywords?: string[];
    /**
     * Timestamp from when this news will be visible in the feed.
     * @format date-time
     */
    scheduled_from?: string;
    /**
     * Timestamp until when this news will be visible in the feed.
     * @format date-time
     */
    scheduled_until?: string;
    /** Status of the news post. */
    status?: string;
    /** Title of the news. */
    title: string;
};
/**
 * news-create-request
 * The request to create a news item.
 */
export interface NewsCreateRequest {
    content: NewsCreateRequestNewsContent;
    /** Cover media for the news item. */
    cover_media: NewsCreateRequestNewsMedia[];
    /** Keywords that describe the news item. */
    keywords: string[];
    /**
     * The time at which the news item is scheduled.
     * @format date-time
     */
    scheduled_from?: string;
    /**
     * The time until when the news item is scheduled.
     * @format date-time
     */
    scheduled_until?: string;
    status?: NewsCreateRequestStatusValue;
    /** Title of the news item. */
    title: string;
}
/** news-create-request-news-content */
export interface NewsCreateRequestNewsContent {
    /** Body of the news item. */
    body: string;
    /** Format of the content in the new item. */
    format: string;
}
/** news-create-request-news-media */
export interface NewsCreateRequestNewsMedia {
    /**
     * ID of the artifact, otherwise not set if the source type isn't
     * 'artifact'.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    artifact?: string;
    source?: 'artifact' | 'url';
    /**
     * URL of the external media, otherwise not set if the source type
     * isn't 'url'.
     */
    url?: string;
}
export declare enum NewsCreateRequestStatusValue {
    Archived = "archived",
    Draft = "draft",
    Published = "published"
}
/**
 * news-create-response
 * The response for the create news item request.
 */
export interface NewsCreateResponse {
    news: News;
}
/**
 * news-delete-request
 * The request to delete a news item.
 */
export interface NewsDeleteRequest {
    /** The ID of the news item. */
    id: string;
}
/**
 * news-get-request
 * The request to get a news item.
 */
export interface NewsGetRequest {
    /** The ID of the requested news item. */
    id: string;
}
/**
 * news-get-response
 * The response for the get news item request.
 */
export interface NewsGetResponse {
    news: News;
}
/**
 * news-list-request
 * The request to list news items.
 */
export interface NewsListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of news items to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
}
/**
 * news-list-response
 * The response for the list news request.
 */
export interface NewsListResponse {
    /** The news entries matching the request. */
    news: News[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** news-summary */
export type NewsSummary = AtomBaseSummary;
/** notification */
export type Notification = (ConversationCreatedNotification | ConversationInactivityReminder | DevrevReminder | ObjectAssignmentNotification | PrReviewReminder | UserMentionedNotification | UserParticipationNotification | VistaSharedNotification) & {
    type: NotificationType;
};
/** notification-base */
export type NotificationBase = AtomBase & {
    actor?: UserSummary;
    /** Origin of the notification. */
    origin?: string;
    parent?: AtomSummary;
    /** The object type of parent associated with the notification. */
    parent_type?: string;
    /** Priority of the notification. */
    priority?: NotificationPriority;
    /** The state of the notification. */
    state?: NotificationState;
    /**
     * Timestamp of the event that triggered the notification.
     * @format date-time
     */
    timestamp?: string;
    user?: UserSummary;
};
/** notification-base-summary */
export type NotificationBaseSummary = AtomBaseSummary & {
    actor?: UserSummary;
    parent?: AtomSummary;
    /** The state of the notification. */
    state?: NotificationState;
};
/** Notification parent types. */
export declare enum NotificationParentType {
    Conversation = "conversation",
    Issue = "issue",
    Part = "part",
    RevOrg = "rev_org",
    RevUser = "rev_user",
    Ticket = "ticket"
}
/**
 * notification-preferences-group
 * Preferences group for Notifications.
 */
export interface NotificationPreferencesGroup {
    /** Email notifications. */
    email_notifications?: NotificationPreferencesGroupEmailNotifications;
}
/** Email notifications. */
export declare enum NotificationPreferencesGroupEmailNotifications {
    All = "all",
    Important = "important",
    Nothing = "nothing"
}
/** Priority of the notification. */
export declare enum NotificationPriority {
    High = "high",
    Low = "low",
    Medium = "medium"
}
/** The state of the notification. */
export declare enum NotificationState {
    Archived = "archived",
    Read = "read",
    Unread = "unread"
}
export declare enum NotificationType {
    ConversationCreatedNotification = "conversation_created_notification",
    ConversationInactivityReminder = "conversation_inactivity_reminder",
    DevrevReminder = "devrev_reminder",
    ObjectAssignmentNotification = "object_assignment_notification",
    PrReviewReminder = "pr_review_reminder",
    UserMentionedNotification = "user_mentioned_notification",
    UserParticipationNotification = "user_participation_notification",
    VistaSharedNotification = "vista_shared_notification"
}
/** notifications-channel */
export interface NotificationsChannel {
    /** ID of the channel. */
    channel_id: string;
    /** Description of the channel. */
    description?: string;
    /** Name of the channel. */
    name: string;
}
/** notifications-channels-request */
export interface NotificationsChannelsRequest {
    /** The type of mobile device. */
    device_type?: string;
}
/** notifications-channels-response */
export interface NotificationsChannelsResponse {
    /** The list of notification channels. */
    channels: NotificationsChannel[];
}
/** notifications-filter */
export interface NotificationsFilter {
    /**
     * Actor user IDs by which to filter the response.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    actor_ids?: string[];
    /** Notification IDs by which to filter the response. */
    ids?: string[];
    /**
     * Parent IDs by which to filter the response.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    parent_ids?: string[];
    /** Parent object types by which to filter the response. */
    parent_types?: NotificationParentType[];
    /** Notification states by which to filter the response. */
    states?: NotificationState[];
    /** Notification types by which to filter the response. */
    types?: NotificationType[];
}
/** notifications-group */
export interface NotificationsGroup {
    /**
     * The cursor from where to resume iteration. If not provided, then
     * iteration has completed.
     */
    cursor?: string;
    /** Grouping key. */
    key: string;
    /** List of notifications as grouped by the grouping key. */
    notifications: Notification[];
}
/** notifications-group-request */
export interface NotificationsGroupRequest {
    /**
     * Actor user IDs by which to filter the response.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    actor_ids?: string[];
    /**
     * The cursor from where to begin iteration. Start from beginning if
     * not provided.
     */
    cursor?: string;
    /** The field to group the notifications by. */
    group_by: string;
    /** Notification IDs by which to filter the response. */
    ids?: string[];
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of notifications to return for an individual
     * group. Default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * Parent IDs by which to filter the response.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    parent_ids?: string[];
    /** Parent object types by which to filter the response. */
    parent_types?: NotificationParentType[];
    /** Comma-separated fields to sort the notifications by. */
    sort_by?: string[];
    /** Notification states by which to filter the response. */
    states?: NotificationState[];
    /** Notification types by which to filter the response. */
    types?: NotificationType[];
}
/** notifications-group-response */
export interface NotificationsGroupResponse {
    /**
     * The cursor from where to resume iteration for the groups. If not
     * provided, then iteration has completed.
     */
    cursor?: string;
    /** The list of groups. */
    groups: NotificationsGroup[];
    /**
     * The total number of notifications available.
     * @format int32
     */
    total: number;
    /**
     * The total number of groups of notifications available.
     * @format int32
     */
    total_groups: number;
}
/**
 * notifications-list-request
 * Notifications list request.
 */
export interface NotificationsListRequest {
    /**
     * Actor user IDs by which to filter the response.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    actor_ids?: string[];
    /**
     * The cursor from where to begin iteration. Start from beginning if
     * not provided.
     */
    cursor?: string;
    /** Notification IDs by which to filter the response. */
    ids?: string[];
    /**
     * The maximum number of notifications to return. Default is 50.
     * @format int32
     */
    limit?: number;
    /**
     * Parent IDs by which to filter the response.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    parent_ids?: string[];
    /** Parent object types by which to filter the response. */
    parent_types?: NotificationParentType[];
    /** Comma-separated fields to sort the notifications by. */
    sort_by?: string[];
    /** Notification states by which to filter the response. */
    states?: NotificationState[];
    /** Notification types by which to filter the response. */
    types?: NotificationType[];
}
/**
 * notifications-list-response
 * Notifications list response.
 */
export interface NotificationsListResponse {
    /**
     * The cursor from where to resume iteration. If not provided, then
     * iteration has completed.
     */
    cursor?: string;
    /** The list of the notifications. */
    notifications: Notification[];
    /**
     * The total number of notifications available.
     * @format int32
     */
    total: number;
}
/** notifications-mark-request */
export interface NotificationsMarkRequest {
    filter?: NotificationsFilter;
    /** The state of the notification. */
    state?: NotificationState;
}
/** notifications-send-request */
export interface NotificationsSendRequest {
    /** The list of notifications to send. */
    notifications: SendNotification[];
}
/** notifications-send-response */
export type NotificationsSendResponse = object;
/** object-assignment-notification */
export type ObjectAssignmentNotification = NotificationBase & {
    source?: AtomSummary;
};
/** object-assignment-notification-summary */
export type ObjectAssignmentNotificationSummary = NotificationBaseSummary;
/** object-frame */
export interface ObjectFrame {
    action_type: ActionTypeValue;
    id: string;
}
/** object-member */
export type ObjectMember = AtomBase & {
    member?: AtomSummary;
    member_rev_org?: OrgSummary;
    object?: AtomSummary;
    /** Type of target object. */
    target_object_type?: string;
    /**
     * Timestamp when this membership is valid.
     * @format date-time
     */
    valid_from_date?: string;
    /**
     * Timestamp when this membership expires.
     * @format date-time
     */
    valid_to_date?: string;
};
/** object-member-summary */
export type ObjectMemberSummary = AtomBaseSummary;
/**
 * object-member-v1
 * Object member.
 */
export interface ObjectMemberV1 {
    /** Conditional roles the membership includes. */
    conditional_roles: ConditionalRoleV1[];
    member_id?: AtomSummary;
    /** Type of this member. */
    member_type?: ObjectMemberV1MemberType;
    /**
     * Timestamp when this membership is valid.
     * @format date-time
     */
    valid_from_date?: string;
    /**
     * Timestamp when this membership expires.
     * @format date-time
     */
    valid_to_date?: string;
}
/** Type of this member. */
export declare enum ObjectMemberV1MemberType {
    Group = "group",
    User = "user"
}
/**
 * object-reaction
 * Reaction.
 */
export interface ObjectReaction {
    /** ID of the timeline reaction. */
    emoji_id?: string;
    /**
     * Count of reactions.
     * @format int32
     */
    reaction_count?: number;
}
export declare enum ObjectTypeProto {
    Account = "account",
    AddonRule = "addon_rule",
    Alert = "alert",
    ApiOperation = "api_operation",
    ApiParameter = "api_parameter",
    AppFragment = "app_fragment",
    Article = "article",
    Artifact = "artifact",
    Auth0User = "auth0_user",
    Automation = "automation",
    Bug = "bug",
    Capability = "capability",
    ChangeEvent = "change_event",
    Code = "code",
    Collection = "collection",
    Command = "command",
    Comment = "comment",
    CommerceDevoConfig = "commerce_devo_config",
    CommerceRevoConfig = "commerce_revo_config",
    Communication = "communication",
    Component = "component",
    ConditionalRole = "conditional_role",
    Conversation = "conversation",
    ConversationCreated = "conversation_created",
    ConversationInactivityReminder = "conversation_inactivity_reminder",
    Credit = "credit",
    CreditCoupon = "credit_coupon",
    CustomObject = "custom_object",
    CustomPart = "custom_part",
    CustomSchemaFragment = "custom_schema_fragment",
    CustomStage = "custom_stage",
    CustomState = "custom_state",
    CustomType = "custom_type",
    CustomTypeFragment = "custom_type_fragment",
    CustomWork = "custom_work",
    DevOrg = "dev_org",
    DevUser = "dev_user",
    DevrevProfile = "devrev_profile",
    DevrevReminder = "devrev_reminder",
    DevuInvite = "devu_invite",
    DiscoveryGitCommit = "discovery_git_commit",
    DiscoveryGitEvent = "discovery_git_event",
    DiscoveryProfile = "discovery_profile",
    DiscoveryRun = "discovery_run",
    DiscoverySettings = "discovery_settings",
    Emoji = "emoji",
    Enhancement = "enhancement",
    EventSource = "event_source",
    ExternalSyncUnit = "external_sync_unit",
    ExternalSystem = "external_system",
    ExternalSystemType = "external_system_type",
    Feature = "feature",
    FeaturePin = "feature_pin",
    Flow = "flow",
    FunctionDefinition = "function_definition",
    Group = "group",
    GroupMember = "group_member",
    Incident = "incident",
    Invalid = "invalid",
    Invoice = "invoice",
    Issue = "issue",
    Job = "job",
    Keyring = "keyring",
    Link = "link",
    Linkable = "linkable",
    LinkablePin = "linkable_pin",
    Marketplace = "marketplace",
    MarketplaceCategory = "marketplace_category",
    MarketplaceItem = "marketplace_item",
    Meeting = "meeting",
    MetricDefinition = "metric_definition",
    MetricTracker = "metric_tracker",
    MicroflowDefinition = "microflow_definition",
    Microservice = "microservice",
    Namespace = "namespace",
    News = "news",
    ObjectAssignment = "object_assignment",
    ObjectMember = "object_member",
    OneTimeLineItem = "one_time_line_item",
    Opportunity = "opportunity",
    OrgPreferences = "org_preferences",
    PartPin = "part_pin",
    PaymentMethod = "payment_method",
    PrReviewReminder = "pr_review_reminder",
    Pricing = "pricing",
    Problem = "problem",
    Product = "product",
    Project = "project",
    PushDevice = "push_device",
    RealTimeInsight = "real_time_insight",
    RealTimeInsightValue = "real_time_insight_value",
    RecurringLineItem = "recurring_line_item",
    Request = "request",
    RevOrg = "rev_org",
    RevUser = "rev_user",
    Reward = "reward",
    RewardUsageHistory = "reward_usage_history",
    Role = "role",
    Room = "room",
    Runnable = "runnable",
    RunnablePin = "runnable_pin",
    Schedule = "schedule",
    ScheduleFragment = "schedule_fragment",
    Schema = "schema",
    ServicePlan = "service_plan",
    Settings = "settings",
    Sku = "sku",
    Sla = "sla",
    SlaPolicy = "sla_policy",
    SlaTracker = "sla_tracker",
    SnapComponent = "snap_component",
    SnapIn = "snap_in",
    SnapInFunction = "snap_in_function",
    SnapInPackage = "snap_in_package",
    SnapInVersion = "snap_in_version",
    SnapKitAction = "snap_kit_action",
    StageDiagram = "stage_diagram",
    StockSchemaFragment = "stock_schema_fragment",
    SubscriptionRule = "subscription_rule",
    Survey = "survey",
    SvcAcc = "svc_acc",
    SyncHistory = "sync_history",
    SyncUnit = "sync_unit",
    SysUser = "sys_user",
    Tag = "tag",
    Task = "task",
    TenantFragment = "tenant_fragment",
    Ticket = "ticket",
    TimelineEvent = "timeline_event",
    Token = "token",
    Uom = "uom",
    UserMention = "user_mention",
    UserParticipation = "user_participation",
    UserPreferences = "user_preferences",
    Vista = "vista",
    VistaShared = "vista_shared",
    Webhook = "webhook",
    WebhookEvent = "webhook_event",
    WindowBasedInsight = "window_based_insight",
    WindowBasedInsightValue = "window_based_insight_value"
}
/** one-time-items-list-request */
export interface OneTimeItemsListRequest {
    /** The list of one time line item DONs which are to be aggregated. */
    ids?: string[];
    /** Filter, invoiced vs un-invoiced service plan objects. */
    is_invoiced?: boolean;
    /**
     * The list of rev org DONs which are to be aggregated.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org_ids?: string[];
    /** The list of service plan DONs which are to be aggregated. */
    service_plan_ids?: string[];
    /**
     * List of fields to sort the one time line item object, by and how to
     * sort them. Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
}
/** one-time-items-list-response */
export interface OneTimeItemsListResponse {
    /** The list of one time line item objects. */
    one_time_line_items: OneTimeLineItem[];
}
/** one-time-line-item */
export type OneTimeLineItem = LineItemBase & {
    /** Tells if the item is part of any invoice. */
    is_invoiced: boolean;
};
/** one-time-line-item-summary */
export type OneTimeLineItemSummary = LineItemBaseSummary;
export declare enum OperationType {
    Create = "create",
    Delete = "delete",
    Execute = "execute",
    List = "list",
    Read = "read",
    Update = "update"
}
/** opportunity */
export type Opportunity = WorkBase & {
    account?: AtomSummary;
    /**
     * Expected total sale amount.
     * @format double
     */
    amount?: number;
    /** Revuser contacts to follow up with. */
    contacts: UserSummary[];
    /** Currency of Amount. */
    currency?: string;
    /**
     * Budget of the customer.
     * @format double
     */
    customer_budget?: number;
    /**
     * Probability of closing the deal.
     * @format double
     */
    probability?: number;
};
/** opportunity-summary */
export type OpportunitySummary = WorkBaseSummary & {
    account?: AtomSummary;
};
/** org-base */
export type OrgBase = AtomBase & {
    /** A representation of a postal address. */
    address?: PostalAddress;
    /** Name of the Organization. */
    display_name?: string;
    /** The environment of the Org. Defaults to 'production' if not specified. */
    environment?: OrgEnvironment;
    logo_id?: ArtifactSummary;
    /** Phone numbers of the Organization. */
    phone_number?: PhoneNumber[];
    /** Phone numbers of the Organization. */
    phone_numbers?: string[];
    /** State of the Organization. */
    state?: OrgState;
};
/** org-base-summary */
export type OrgBaseSummary = AtomBaseSummary & {
    /** Name of the Organization. */
    display_name?: string;
};
/** The environment of the Org. Defaults to 'production' if not specified. */
export declare enum OrgEnvironment {
    Production = "production",
    Staging = "staging",
    Test = "test"
}
/** org-preferences */
export type OrgPreferences = PreferencesBase & {
    /** Automated initial response message. */
    autoresponse_initial_message?: string;
    /** Users who are notified when a new conversation is created. */
    new_conversation_notified_to?: UserSummary[];
    /** Preferences group for Rev-Portal. */
    rev_portal?: RevPortalGroup;
    /**
     * Groups or users to send the analytics report to. If not specified,
     * send to all users in the organization.
     */
    weekly_analytics_report_recipients?: AtomSummary[];
};
/** org-preferences-summary */
export type OrgPreferencesSummary = PreferencesBaseSummary;
/** org-search-summary */
export type OrgSearchSummary = SearchSummaryBase & {
    org: OrgSummary;
};
/** State of the Organization. */
export declare enum OrgState {
    Active = "active",
    Inactive = "inactive",
    Locked = "locked"
}
/** org-summary */
export type OrgSummary = (AccountSummary | DevOrgSummary | RevOrgSummary) & {
    type: OrgType;
};
export declare enum OrgType {
    Account = "account",
    DevOrg = "dev_org",
    RevOrg = "rev_org"
}
/** part */
export type Part = (Capability | Component | CustomPart | Enhancement | Feature | Linkable | Microservice | Product | Runnable) & {
    type: PartType;
};
/** part-base */
export type PartBase = AtomBase & {
    /** Annotations associated with part object. */
    annotations?: number[];
    /** The attached artifacts. */
    artifacts?: ArtifactSummary[];
    /** IDs of the items attached to a part object. */
    attachments?: ArtifactSummary[];
    /** Designated category of the part. */
    category?: PartCategory;
    /**
     * This field holds a concatenated string of all key fields relevant
     * to a particular part.
     */
    concat_keys?: string;
    /** Methods the product can be delivered as. */
    delivered_as?: PartDeliveredAs[];
    /** Description of the part. */
    description?: string;
    /** Docs associated with the part. */
    docs?: DocField[];
    /** Links associated with the object. */
    links?: ArchetypeLinkSummary[];
    /** Name of the part. */
    name?: string;
    /** The users that own the part. */
    owned_by: UserSummary[];
    /** URL to the part details (git url, website, etc.). */
    ref_url?: string;
    /** Describes the current stage of a work item. */
    stage?: Stage;
    /** State of the object based upon the stage. */
    state?: string;
    /** Tags associated with the object. */
    tags?: TagWithValue[];
};
/** part-base-summary */
export type PartBaseSummary = AtomBaseSummary & {
    /** Name of the part. */
    name?: string;
};
/** Designated category of the part. */
export declare enum PartCategory {
    DevPart = "dev_part",
    General = "general",
    RevPart = "rev_part"
}
/** Methods the product can be delivered as. */
export declare enum PartDeliveredAs {
    Goods = "goods",
    Service = "service",
    Software = "software"
}
/**
 * part-merge-event
 * Event for part merging.
 */
export interface PartMergeEvent {
    merged_to_part?: PartSummary;
    part?: PartSummary;
}
/** part-pin-base-summary */
export type PartPinBaseSummary = AtomBaseSummary;
/**
 * part-promote-event
 * Event for part promotion.
 */
export interface PartPromoteEvent {
    part?: PartSummary;
    promoted_to_part?: PartSummary;
}
/** part-search-summary */
export type PartSearchSummary = SearchSummaryBase & {
    part: PartSummary;
};
/** part-summary */
export type PartSummary = (CapabilitySummary | ComponentSummary | CustomPartSummary | EnhancementSummary | FeatureSummary | LinkableSummary | MicroserviceSummary | ProductSummary | RunnableSummary) & {
    type: PartType;
};
export declare enum PartType {
    Capability = "capability",
    Component = "component",
    CustomPart = "custom_part",
    Enhancement = "enhancement",
    Feature = "feature",
    Linkable = "linkable",
    Microservice = "microservice",
    Product = "product",
    Runnable = "runnable"
}
/** parts-contributors-list-request */
export interface PartsContributorsListRequest {
    /**
     * The part's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    /**
     * The maximum number of contributors to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
}
/** parts-contributors-list-response */
export interface PartsContributorsListResponse {
    /** The users that contribute on the part. */
    contributors: UserSummary[];
    /**
     * Total number of contributors on the part.
     * @format int32
     */
    total: number;
}
/** parts-count-request */
export interface PartsCountRequest {
    /** Filters for parts of the provided categories. */
    categories?: PartCategory[];
    created_date?: DateTimeFilter;
    enhancement?: PartsFilterEnhancement;
    modified_date?: DateTimeFilter;
    /** Filters for parts of the provided name(s). */
    name?: string[];
    /**
     * Filters for parts owned by any of the provided users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for part with any of the provided states. */
    state?: string[];
    /**
     * Filters for parts with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /** Filters for parts of the provided type(s). */
    type?: PartType[];
    /**
     * Filters for parts of the provided type(s).
     * @deprecated
     */
    types?: PartType[];
}
/** parts-count-response */
export interface PartsCountResponse {
    /**
     * Count of parts matching the filter.
     * @format int32
     */
    count: number;
}
/** parts-create-request */
export type PartsCreateRequest = (PartsCreateRequestCapability | PartsCreateRequestCustomPart | PartsCreateRequestEnhancement | PartsCreateRequestFeature | PartsCreateRequestLinkable | PartsCreateRequestProduct | PartsCreateRequestRunnable) & {
    /**
     * The IDs of the new artifact items.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifact_ids?: string[];
    /** Description of the part. */
    description?: string;
    /** Docs associated with the part. */
    docs?: DocField[];
    /** Links associated with the part. */
    links?: EmbedLinksCreateRequest[];
    /** Name of the part. */
    name?: string;
    /**
     * The users that own the part.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * The users that own the part. This is replaced by owned_by
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Sets an object's initial stage. */
    stage?: StageInit;
    /** Tags associated with the part. */
    tags?: SetTagWithValue[];
    type: PartType;
    /**
     * Ids of work items which will be assigned to newly created part
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    work_ids?: string[];
};
/** parts-create-request-capability */
export interface PartsCreateRequestCapability {
    /**
     * IDs of the runnables that fulfill this capability.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    fulfilled_by_ids?: string[];
    /**
     * Product ID of this capability.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    part_of_part_id?: string;
    /**
     * User ID of the PM owner of the part.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    pm_owner_id?: string;
}
/** parts-create-request-custom-part */
export type PartsCreateRequestCustomPart = object;
/** parts-create-request-enhancement */
export interface PartsCreateRequestEnhancement {
    /**
     * Target close date by which enhancement is expected to be closed.
     * @format date-time
     */
    target_close_date?: string;
}
/** parts-create-request-feature */
export interface PartsCreateRequestFeature {
    /**
     * User ID of the development owner of the part.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    development_owner_id?: string;
    /**
     * IDs of the runnables that fulfill the feature.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    fulfilled_by_ids?: string[];
    /**
     * Capability or feature ID of the feature.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    part_of_part_id?: string;
    /**
     * User ID of the PM owner of the part.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    pm_owner_id?: string;
    /**
     * User ID of the QA owner of the part.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    qa_owner_id?: string;
}
/** parts-create-request-linkable */
export interface PartsCreateRequestLinkable {
    /** Code Inferred surface area of the linkable. */
    code_inferred_surface_area?: string[];
    /** Repo Path of the linkable. */
    code_repo_paths?: string;
    /** Repo url of the linkable. */
    code_repo_url?: string;
}
/** parts-create-request-product */
export interface PartsCreateRequestProduct {
    /**
     * IDs of the runnables that fulfill the product.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    fulfilled_by_ids?: string[];
    /**
     * User ID of the PM owner of the part.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    pm_owner_id?: string;
    /**
     * User ID of the QA owner of the part.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    qa_owner_id?: string;
}
/** parts-create-request-runnable */
export interface PartsCreateRequestRunnable {
    /** Code Inferred surface area of the runnable. */
    code_inferred_surface_area?: string[];
    /** Repo Path of the runnable. */
    code_repo_paths?: string;
    /** Repo url of the runnable. */
    code_repo_url?: string;
}
/** parts-create-response */
export interface PartsCreateResponse {
    part: Part;
}
/** parts-customers-list-request */
export interface PartsCustomersListRequest {
    /**
     * The part's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    /**
     * The maximum number of customers to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
}
/** parts-customers-list-response */
export interface PartsCustomersListResponse {
    /** Customers who have tickets associated with this part. */
    customers: RevOrgSummary[];
    /**
     * Total number of customers for the part.
     * @format int32
     */
    total: number;
}
/** parts-delete-hierarchy-params */
export interface PartsDeleteHierarchyParams {
    /**
     * If not set, then all work items are deleted.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    reassign_work_to_part_id?: string;
}
/** parts-delete-request */
export interface PartsDeleteRequest {
    delete_hierarchy_params?: PartsDeleteHierarchyParams;
    /**
     * The ID of the part to delete.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
}
/** parts-delete-response */
export type PartsDeleteResponse = object;
/** parts-descendant-links-traverse-request */
export interface PartsDescendantLinksTraverseRequest {
    /**
     * Cursor to begin iteration from. If empty, iteration will begin from
     * the beginning of the result set
     */
    cursor?: string;
    /**
     * Maximum number of link items to return. Default is 50.
     * @format int32
     */
    limit?: number;
    /**
     * If > 0, the maximum depth of the tree to traverse links from the
     * root.
     * @format int32
     */
    max_depth?: number;
    /**
     * ID of the part tree root to traverse links to descendant nodes
     * from.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    root: string;
}
/** parts-descendant-links-traverse-response */
export interface PartsDescendantLinksTraverseResponse {
    /**
     * List of link objects as part of the descendants link traversal.
     * Link objects at one level are exhausted first before moving to the
     * next level.
     */
    links: Link[];
    /** Cursor to continue iteration */
    next_cursor: string;
}
/** Name of the source used for parts discovery. */
export declare enum PartsDiscoverySourceName {
    AwsApiGw = "aws_api_gw",
    CustomRoutes = "custom_routes",
    DataDog = "data_dog",
    Git = "git",
    Kubernetes = "kubernetes"
}
/** parts-features-api-endpoints-delete-request */
export interface PartsFeaturesApiEndpointsDeleteRequest {
    /** The identifiers specifying the API endpoints to be deleted. */
    api_endpoint_identifiers: ApiEndpointIdentifier[];
    /** Whether or not to not update the resulting feature in the database. */
    dry_run?: boolean;
    /** The feature ID from which the API endpoints are deleted. */
    feature: string;
}
/** parts-features-api-endpoints-delete-response */
export interface PartsFeaturesApiEndpointsDeleteResponse {
    part: Part;
    /**
     * The identifiers of the api enpoints skipped by the delete
     * operation.
     */
    skipped_api_endpoint_identifiers: ApiEndpointIdentifier[];
}
/** parts-features-api-endpoints-merge-request */
export interface PartsFeaturesApiEndpointsMergeRequest {
    /** The identifiers specifying the API endpoints to be merged. */
    api_endpoint_identifiers: ApiEndpointIdentifier[];
    /**
     * Whether or not to delete the merged API endpoints from the
     * from-feature.
     */
    delete_merged_api_endpoints?: boolean;
    /** Whether or not to not update the resulting part in the database. */
    dry_run?: boolean;
    /** The feature ID from which the API endpoints are merged. */
    from_feature: string;
    /** The feature ID into which the API endpoints are merged. */
    to_feature: string;
}
/** parts-features-api-endpoints-merge-response */
export interface PartsFeaturesApiEndpointsMergeResponse {
    from_part: Part;
    merged_part: Part;
    /**
     * The identifiers of the API endpoints skipped by the delete
     * operation.
     */
    skipped_api_endpoint_identifiers: ApiEndpointIdentifier[];
}
/** parts-features-api-operations-delete-request */
export interface PartsFeaturesApiOperationsDeleteRequest {
    api_endpoint_identifier: ApiEndpointIdentifier;
    /** Whether or not to not update the resulting part in the database. */
    dry_run?: boolean;
    /** The feature ID from which the api operations are deleted. */
    feature: string;
    /**
     * The HTTP operations specifying the API operations to be deleted. To
     * specify an empty HTTP operation, use the keyword UNKNOWN.
     */
    http_operations: FeatureApiOperationHttpOperation[];
}
/** parts-features-api-operations-delete-response */
export interface PartsFeaturesApiOperationsDeleteResponse {
    part: Part;
    /**
     * The HTTP operations skipped by the delete operation. The UNKNOWN
     * keyword denotes an empty HTTP operation.
     */
    skipped_http_operations: FeatureApiOperationHttpOperation[];
}
/** parts-features-api-operations-merge-request */
export interface PartsFeaturesApiOperationsMergeRequest {
    api_endpoint_identifier: ApiEndpointIdentifier;
    /**
     * Whether or not to delete the merged API operations from the
     * from-feature.
     */
    delete_merged_api_endpoints?: boolean;
    /** Whether or not to not update the resulting part in the database. */
    dry_run?: boolean;
    /** The feature ID from which the API operations are merged. */
    from_feature: string;
    /**
     * The HTTP operations specifying the API operations to be merged. To
     * specify an empty HTTP operation, use the keyword UNKNOWN.
     */
    http_operations: FeatureApiOperationHttpOperation[];
    /** The feature ID into which the API operations are merged. */
    to_feature: string;
}
/** parts-features-api-operations-merge-response */
export interface PartsFeaturesApiOperationsMergeResponse {
    from_part: Part;
    merged_part: Part;
    /**
     * The HTTP operations skipped by the delete operation. The UNKNOWN
     * keyword denotes an empty HTTP operation.
     */
    skipped_http_operations: FeatureApiOperationHttpOperation[];
}
/** parts-filter-enhancement */
export interface PartsFilterEnhancement {
    target_close_date?: DateTimeFilter;
}
/** parts-get-request */
export interface PartsGetRequest {
    /**
     * The ID of the part to retrieve.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
}
/** parts-get-response */
export interface PartsGetResponse {
    part: Part;
}
/** parts-group */
export interface PartsGroup {
    /** Unique key according to which the items are grouped. */
    key: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /** The group of parts. */
    parts: Part[];
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** parts-group-request */
export interface PartsGroupRequest {
    /** Filters for parts of the provided categories. */
    categories?: PartCategory[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    enhancement?: PartsFilterEnhancement;
    /** The field to group the parts by. */
    group_by: string;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of parts to return for an individual group. If
     * not set, then the default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Filters for parts of the provided name(s). */
    name?: string[];
    /**
     * Filters for parts owned by any of the provided users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Comma-separated fields to sort the parts by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for part with any of the provided states. */
    state?: string[];
    /**
     * Filters for parts with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /** Filters for parts of the provided type(s). */
    type?: PartType[];
    /**
     * Filters for parts of the provided type(s).
     * @deprecated
     */
    types?: PartType[];
}
/** parts-group-response */
export interface PartsGroupResponse {
    /** The list of groups. */
    groups: PartsGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** parts-list-request */
export interface PartsListRequest {
    /** Filters for parts of the provided categories. */
    categories?: PartCategory[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    enhancement?: PartsFilterEnhancement;
    /**
     * The maximum number of parts to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Filters for parts of the provided name(s). */
    name?: string[];
    /**
     * Filters for parts owned by any of the provided users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Fields to sort the parts by and the direction to sort them. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for part with any of the provided states. */
    state?: string[];
    /**
     * Filters for parts with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /** Filters for parts of the provided type(s). */
    type?: PartType[];
    /**
     * Filters for parts of the provided type(s).
     * @deprecated
     */
    types?: PartType[];
}
/** parts-list-response */
export interface PartsListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /** The list of parts. */
    parts: Part[];
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** parts-mutate-request */
export type PartsMutateRequest = (PartsMutateRequestMerge | PartsMutateRequestPromote) & {
    /**
     * ID of the part to be mutated.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    type: PartsMutateRequestType;
};
/** parts-mutate-request-merge */
export type PartsMutateRequestMerge = object;
/** parts-mutate-request-promote */
export interface PartsMutateRequestPromote {
    change_type_to: PartType;
    /**
     * Parent ID of new part.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    parent_id?: string | null;
}
export declare enum PartsMutateRequestType {
    Merge = "merge",
    Promote = "promote"
}
/** parts-mutate-response */
export interface PartsMutateResponse {
    part: Part;
}
/** parts-supporters-list-request */
export interface PartsSupportersListRequest {
    /**
     * The part's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    /**
     * The maximum number of supporters to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
}
/** parts-supporters-list-response */
export interface PartsSupportersListResponse {
    /** The users that provide support on the part. */
    supporters: UserSummary[];
    /**
     * Total number of supporters on the part.
     * @format int32
     */
    total: number;
}
/** parts-update-request */
export type PartsUpdateRequest = (PartsUpdateRequestCapability | PartsUpdateRequestCustomPart | PartsUpdateRequestEnhancement | PartsUpdateRequestFeature | PartsUpdateRequestLinkable | PartsUpdateRequestProduct | PartsUpdateRequestRunnable) & {
    artifact_ids?: PartsUpdateRequestArtifactIds;
    /** The updated description of the part. */
    description?: string;
    docs?: PartsUpdateRequestUpdateDocs;
    /**
     * The ID of the part to update.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    /** The updated name of the part. */
    name?: string;
    owned_by_ids?: PartsUpdateRequestOwnedByIds;
    /** Updates an object's stage. */
    stage?: StageUpdate;
    tags?: PartsUpdateRequestTags;
    type: PartType;
};
/** parts-update-request-artifact-ids */
export interface PartsUpdateRequestArtifactIds {
    /**
     * Sets the artifacts to the provided IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    set?: string[];
}
/** parts-update-request-capability */
export type PartsUpdateRequestCapability = object;
/** parts-update-request-custom-part */
export type PartsUpdateRequestCustomPart = object;
/** parts-update-request-enhancement */
export interface PartsUpdateRequestEnhancement {
    /**
     * Updates the target close date of the enhancement.
     * @format date-time
     */
    target_close_date?: string;
}
/** parts-update-request-feature */
export type PartsUpdateRequestFeature = object;
/** parts-update-request-linkable */
export interface PartsUpdateRequestLinkable {
    /** Code Inferred surface area of the linkable. */
    code_inferred_surface_area?: string[];
    /** Repo Path of the linkable. */
    code_repo_paths?: string;
    /** Repo url of the linkable. */
    code_repo_url?: string;
}
/** parts-update-request-owned-by-ids */
export interface PartsUpdateRequestOwnedByIds {
    /**
     * Sets the owner IDs to the provided user IDs. This must not be
     * empty.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** parts-update-request-product */
export type PartsUpdateRequestProduct = object;
/** parts-update-request-runnable */
export interface PartsUpdateRequestRunnable {
    /** Code Inferred surface area of the runnable. */
    code_inferred_surface_area?: string[];
    /** Repo Path of the runnable. */
    code_repo_paths?: string;
    /** Repo url of the runnable. */
    code_repo_url?: string;
}
/** parts-update-request-tags */
export interface PartsUpdateRequestTags {
    /** Sets the tags to the provided tags. */
    set?: SetTagWithValue[];
}
/** parts-update-request-update-docs */
export interface PartsUpdateRequestUpdateDocs {
    /** Sets the docs to the provided docs. */
    set?: DocField[];
}
/** parts-update-response */
export interface PartsUpdateResponse {
    part: Part;
}
/** payment-intents-update-request */
export interface PaymentIntentsUpdateRequest {
    /** The payment intent id. */
    payment_intent_id: string;
    /**
     * Flag to determine whether to save the methodon successful payment
     * on this payment intent.
     */
    setup_future_usage: boolean;
}
/** payment-method */
export type PaymentMethod = (PaymentMethodBankAccount | PaymentMethodCard) & {
    type: PaymentMethodType;
};
/** payment-method-bank-account */
export type PaymentMethodBankAccount = PaymentMethodBase & {
    /** Account holder type. */
    account_holder_type: PaymentMethodBankAccountAccountHolderType;
    /** Account type. */
    account_type: PaymentMethodBankAccountAccountType;
    /** Bank name. */
    bank_name: string;
    /** Routing number of the bank account. */
    routing_number: string;
};
/** Account holder type. */
export declare enum PaymentMethodBankAccountAccountHolderType {
    Company = "company",
    Individual = "individual"
}
/** Account type. */
export declare enum PaymentMethodBankAccountAccountType {
    Checking = "checking",
    Savings = "savings"
}
/** payment-method-bank-account-summary */
export type PaymentMethodBankAccountSummary = PaymentMethodBaseSummary;
/** payment-method-base */
export type PaymentMethodBase = AtomBase & {
    /** Display number. */
    display_number: string;
    /**
     * Set to true if it is a default payment method for the customer,
     * else false.
     */
    is_default: boolean;
    rev: OrgSummary;
};
/** payment-method-base-summary */
export type PaymentMethodBaseSummary = AtomBaseSummary;
/** payment-method-card */
export type PaymentMethodCard = PaymentMethodBase & {
    /** Brand name the card belongs to. */
    brand: string;
    /**
     * Month on which the card expires.
     * @format int32
     */
    exp_month: number;
    /**
     * Year on which card expires.
     * @format int32
     */
    exp_year: number;
    /** Fund type of the card. */
    fund_type: PaymentMethodCardFundType;
};
/** Fund type of the card. */
export declare enum PaymentMethodCardFundType {
    Credit = "credit",
    Debit = "debit",
    Prepaid = "prepaid"
}
/** payment-method-card-summary */
export type PaymentMethodCardSummary = PaymentMethodBaseSummary;
export declare enum PaymentMethodType {
    PaymentMethodBankAccount = "payment_method_bank_account",
    PaymentMethodCard = "payment_method_card"
}
/** payment-methods-delete-request */
export interface PaymentMethodsDeleteRequest {
    /** The payment method ID which is to be deleted from customer config. */
    id: string;
}
/** payment-methods-get-request */
export interface PaymentMethodsGetRequest {
    /** The payment method's DON */
    id: string;
}
/** payment-methods-get-response */
export interface PaymentMethodsGetResponse {
    payment_method: PaymentMethod;
}
/** payment-methods-list-response */
export interface PaymentMethodsListResponse {
    /** List of payment methods. */
    payment_methods: PaymentMethod[];
}
/** payment-methods-set-default-request */
export interface PaymentMethodsSetDefaultRequest {
    /**
     * The payment method ID which is to be set as default for the
     * customer.
     */
    id: string;
}
/** payment-methods-setup-intent-create-request */
export type PaymentMethodsSetupIntentCreateRequest = object;
/** payment-methods-setup-intent-create-response */
export interface PaymentMethodsSetupIntentCreateResponse {
    /** The client key to be used to save the payment method details. */
    client_key: string;
}
/** personalized-item */
export interface PersonalizedItem {
    work: WorkSummary;
}
/** personalized-list-request */
export type PersonalizedListRequest = object;
/**
 * personalized-list-response
 * Personalized list response.
 */
export interface PersonalizedListResponse {
    /** List of recently accessesed items by the user. */
    recent_items: PersonalizedItem[];
    /** List of recommended items for the user. */
    recommended_items: PersonalizedItem[];
}
/**
 * phone-number
 * A phone number.
 */
export interface PhoneNumber {
    /** The phone number in e164 format. */
    e164_number?: string;
    /** An optional extension. */
    extension?: string;
}
/**
 * policy-instance
 * Wrapper over rego policy allowing templated re-usable policy.
 */
export interface PolicyInstance {
    /** Name of the policy. */
    name?: string;
    /** JSON string storing values for each templated variable. */
    parameters?: string;
    /** Rego policy string. */
    policy?: string;
    /** Whether the policy is system generated. */
    system_parseable?: boolean;
}
/**
 * postal-address
 * A representation of a postal address.
 */
export interface PostalAddress {
    /** Country name component. */
    country?: string;
    /**
     * Full mailing address, formatted for display or use on a mailing
     * label.
     */
    formatted?: string;
    /** Town, city. */
    locality?: string;
    /** Zip code of the address. */
    postal_code?: string;
    /** State, province, prefecture, or region component. */
    region?: string;
    /** Full street address component. */
    street_address?: string;
}
/** pr-review-reminder */
export type PrReviewReminder = NotificationBase & {
    /**
     * Time at which review request was created.
     * @format date-time
     */
    created_at?: string;
    /** A Pull Request object. */
    pull_request?: PullRequest;
};
/** pr-review-reminder-summary */
export type PrReviewReminderSummary = NotificationBaseSummary;
/** preferences */
export type Preferences = (OrgPreferences | UserPreferences) & {
    type: PreferencesType;
};
/** preferences-base */
export type PreferencesBase = AtomBase;
/** preferences-base-summary */
export type PreferencesBaseSummary = AtomBaseSummary;
/** preferences-list-request */
export interface PreferencesListRequest {
    /**
     * The ID of the object for which the preferences are to be listed.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    object: string;
}
/** preferences-list-response */
export interface PreferencesListResponse {
    preferences: Preferences;
}
/** preferences-snap-kit-list-request */
export interface PreferencesSnapKitListRequest {
    /**
     * The ID of the object for which the preferences snap kit is to be
     * fetched.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    object: string;
}
/** preferences-snap-kit-list-response */
export interface PreferencesSnapKitListResponse {
    /** The SnapKit body of the preferences object requested. */
    snap_kit_body: object;
}
export declare enum PreferencesType {
    OrgPreferences = "org_preferences",
    UserPreferences = "user_preferences"
}
/** preferences-update-request */
export type PreferencesUpdateRequest = (UpdateOrgPreferences | UpdateUserPreferences) & {
    /**
     * The ID of the object for which the preferences are to be listed.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    object: string;
    type: PreferencesType;
};
/** preferences-update-response */
export interface PreferencesUpdateResponse {
    preferences: Preferences;
}
/**
 * price-slab
 * Helps in defining the range pricing for cases such as tiered pricing,
 * volume pricing etc. For Example, if the pricing for first 100 api calls
 * per calls is $X and after that its $Y till infinity.
 */
export interface PriceSlab {
    /**
     * The flat price for the complete slab, irrespective of qunatity one
     * uses in this price slab. This can be set only if unit price is set.
     * @format double
     */
    flat_price?: number;
    /**
     * The price for each unit.
     * @format double
     */
    unit_price?: number;
    /**
     * the quantity upto which this price is applicable. You can set this
     * value only if up to infinity is not set to true.
     * @format int32
     */
    up_to?: number;
    /**
     * If true, this price slab is applicable for all the remaining
     * quantities till infinity.
     */
    up_to_inf?: boolean;
}
/**
 * price-slab-summary
 * Helps in defining the range pricing for cases such as tiered pricing,
 * volume pricing etc. For Example, if the pricing for first 100 api calls
 * per calls is $X and after that its $Y till infinity.
 */
export interface PriceSlabSummary {
    /**
     * The flat price for the complete slab, irrespective of qunatity one
     * uses in this price slab. This can be set only if unit price is set.
     * @format double
     */
    flat_price?: number;
    /**
     * The price for each unit.
     * @format double
     */
    unit_price?: number;
    /**
     * the quantity upto which this price is applicable. You can set this
     * value only if up to infinity is not set to true.
     * @format int32
     */
    up_to?: number;
    /**
     * If true, this price slab is applicable for all the remaining
     * quantities till infinity.
     */
    up_to_inf?: boolean;
}
/** pricing */
export type Pricing = AtomBase & {
    /** Billing frequency of the SKU. */
    billing_cycle: PricingBillingCycle;
    /**
     * Number of units in each block. For example, If the metered units is
     * 540 and the block size is 100. Then the quantity will be 5.4. The
     * default value is 1.
     * @format int32
     */
    block_size?: number;
    /**
     * Currency used for the pricing. For example, USD, INR etc. Defaults
     * to USD.
     */
    currency: string;
    /** Description of the pricing. */
    description?: string;
    /**
     * if true then this pricing object can be used for new purchases. If
     * false then no new purchases can be made with this pricing object
     * but existing purchases can still use this pricing object. Defaults
     * to true.
     */
    is_active?: boolean;
    /**
     * Whether the slabs should be priced tiered or flat. The default
     * value is false.
     */
    is_tiered?: boolean;
    /** List of price slabs for the given currency. */
    price_slabs: PriceSlab[];
    rev?: OrgSummary;
    sku: SkuSummary;
};
/** Billing frequency of the SKU. */
export declare enum PricingBillingCycle {
    Monthly = "monthly",
    OneTime = "one_time",
    Yearly = "yearly"
}
/** pricing-summary */
export type PricingSummary = AtomBaseSummary & {
    /** Billing frequency of the SKU. */
    billing_cycle: PricingBillingCycle;
    /**
     * Number of units in each block. For example, If the metered units is
     * 540 and the block size is 100. Then the quantity will be 5.4. The
     * default value is 1.
     * @format int32
     */
    block_size?: number;
    /**
     * Currency used for the pricing. For example, USD, INR etc. Defaults
     * to USD.
     */
    currency: string;
    /**
     * if true then this pricing object can be used for new purchases. If
     * false then no new purchases can be made with this pricing object
     * but existing purchases can still use this pricing object. Defaults
     * to true.
     */
    is_active?: boolean;
    /**
     * Whether the slabs should be priced tiered or flat. The default
     * value is false.
     */
    is_tiered?: boolean;
    /** List of price slabs for the given currency. */
    price_slabs: PriceSlabSummary[];
};
/** pricings-create-request */
export interface PricingsCreateRequest {
    /** Billing frequency of the SKU. */
    billing_cycle: PricingBillingCycle;
    /**
     * Number of units in each block. For example, If the metered units is
     * 540 and the block size is 100. Then the quantity will be 5.4. The
     * default value is 1.
     * @format int32
     */
    block_size?: number;
    /**
     * Currency used for the pricing object. For example: USD, INR etc.
     * Defaults to USD.
     */
    currency: string;
    /** Description of the pricing object. */
    description?: string;
    /**
     * Helps in deciding if a price object can be used for purchasing new
     * items. If set to true then new purchase can be made. If set to
     * false then no new purchase can be made, but quantity of existing
     * items, which were bought with this pricing ID can be updated.
     * Defaults to false.
     */
    is_active?: boolean;
    /**
     * Whether the slabs should be priced tiered or flat. The default
     * value is false.
     */
    is_tiered?: boolean;
    /** List of price slabs for the given currency. */
    price_slabs: PriceSlab[];
    /**
     * The rev org for whom the current pricing object is overridden or is
     * a custom pricing object.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
    /**
     * Helps in determining if the current pricing object is overridden
     * for a specific service plan and for a specific rev org.
     */
    service_plan_id?: string;
    /** The sku ID for which the pricing object is defined. */
    sku_id: string;
}
/** pricings-create-response */
export interface PricingsCreateResponse {
    pricing: Pricing;
}
/** pricings-delete-request */
export interface PricingsDeleteRequest {
    /** The pricing object's DON. */
    id: string;
}
/** pricings-get-request */
export interface PricingsGetRequest {
    /** The pricing object's DON. */
    id: string;
}
/** pricings-get-response */
export interface PricingsGetResponse {
    pricing: Pricing;
}
/** pricings-list-request */
export interface PricingsListRequest {
    /** The list of pricing DONs which are to be aggregated. */
    ids?: string[];
    /** Filter, active vs inactive pricing objects. */
    is_active?: boolean;
    /**
     * The list of rev org DONs which are to be aggregated.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org_ids?: string[];
    /** The list of sku DONs which are to be aggregated. */
    sku_ids?: string[];
    /**
     * List of fields to sort the pricing object, by and how to sort them.
     * Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
}
/** pricings-list-response */
export interface PricingsListResponse {
    /** The list of pricing objects. */
    pricings: Pricing[];
}
/** pricings-update-request */
export interface PricingsUpdateRequest {
    /** The pricing object's DON. */
    id: string;
    /**
     * Helps in deciding if a pricing object can be used for purchasing
     * new items. If set to true then new purchase can be made. If set to
     * false then no new purchase can be made, but quantity of existing
     * items, which were bought with this pricing ID can be updated.
     */
    is_active?: boolean;
    /** Whether the slabs represent graduated or volume based pricing. */
    is_tiered?: boolean;
    /** List of new updated price slabs. */
    price_slabs: PriceSlab[];
}
/** pricings-update-response */
export interface PricingsUpdateResponse {
    pricing: Pricing;
}
/** product */
export type Product = PartBase & {
    /** IDs of the runnables that fulfill this product. */
    fulfilled_by?: PartSummary[];
    pm_owner?: UserSummary;
    /** Product Delivered as. */
    product_delivered_as?: ProductDeliveredAs;
    /** Versions of the product. */
    versions?: string[];
};
/** Product Delivered as. */
export declare enum ProductDeliveredAs {
    Goods = "goods",
    Service = "service"
}
/** product-summary */
export type ProductSummary = PartBaseSummary;
/**
 * profile-summary
 * Discovery profile summary.
 */
export interface ProfileSummary {
    /** Configuration knobs for extractors. */
    extractors?: Extractors;
    /** Configuration knobs for partitioners and partition mergers. */
    mergers?: DevRevPartitionerMerger;
    /**
     * Optionally allow to specify a different devorg's data as source. If
     * missing current devorg is used.
     */
    other_data_source_devorg?: string;
    /**
     * Optionally allow to specify a different devorg's data as source. If
     * missing current devorg is used.
     */
    other_data_source_devorg_v1?: string;
    /** Configuration knobs for partitioners and partition mergers. */
    partitioners?: DevRevPartitionerMerger;
    /** Specify discovery profile Id associated. */
    profile_id?: string;
    /** Specify discovery profile Id associated. */
    profile_id_v1?: string;
    /** Name of the Discovery profile. */
    profile_name?: string;
}
/**
 * profiles-create-request
 * Request to create a new profile.
 */
export interface ProfilesCreateRequest {
    /** Professional biography of the user. */
    bio?: string;
    /** Display handles are used to uniquely identify the users. */
    display_handle?: string;
    /** The user's display name. The name is non-unique and mutable. */
    display_name: string;
    /**
     * Artifact ID of the user's display picture
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture?: string;
    /** Full name of the user. */
    full_name?: string;
    /**
     * Brief description of the user's professional experience or
     * interests.
     */
    headline?: string;
    /** Phone numbers of the user. */
    phone_numbers?: string[];
    /** State of the user. */
    state?: UserState;
    /** Visibility of the profile to other users. */
    visibility?: DevrevProfileVisibility;
}
/**
 * profiles-create-response
 * The response for the request to create a new profile.
 */
export interface ProfilesCreateResponse {
    profile: DevrevProfile;
}
/**
 * profiles-get-by-handle-request
 * A request to get the public information of a profile.
 */
export interface ProfilesGetByHandleRequest {
    /** The display handle of the profile to get. */
    display_handle: string;
}
/**
 * profiles-get-by-handle-response
 * The response for the request to get the public information of a user's
 * profile.
 */
export interface ProfilesGetByHandleResponse {
    /** Professional biography of the user. */
    bio?: string;
    /** Full name of the user. */
    full_name?: string;
    /**
     * Brief description of the user's professional experience or
     * interests.
     */
    headline?: string;
    /** URL of the user's profile picture. */
    profile_picture?: string;
}
/**
 * profiles-is-display-handle-available-request
 * A request to check the availability of the display handle at the time
 * of invocation.
 */
export interface ProfilesIsDisplayHandleAvailableRequest {
    /** Display handles are used to uniquely identify the users. */
    display_handle: string;
}
/**
 * profiles-is-display-handle-available-response
 * The response for the request to check the availability of the display
 * handle.
 */
export interface ProfilesIsDisplayHandleAvailableResponse {
    /** Whether the requested display handle is available or not. */
    is_available: boolean;
}
/** profiles-self-delete-request */
export type ProfilesSelfDeleteRequest = object;
/** profiles-self-delete-response */
export type ProfilesSelfDeleteResponse = object;
/**
 * profiles-self-request
 * The response for the request to get a user's profile information.
 */
export type ProfilesSelfRequest = object;
/**
 * profiles-self-response
 * The response to get a profile's information.
 */
export interface ProfilesSelfResponse {
    profile: DevrevProfile;
}
/**
 * profiles-self-update-request
 * Request to update a user's profile information.
 */
export interface ProfilesSelfUpdateRequest {
    /** Professional biography of the user. */
    bio?: string;
    /** Display handles are used to uniquely identify the users. */
    display_handle?: string;
    /** The user's display name. The name is non-unique and mutable. */
    display_name?: string;
    /**
     * Artifact ID of the user's display picture
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture?: string;
    /** Full name of the user. */
    full_name?: string;
    /**
     * Brief description of the user's professional experience or
     * interests.
     */
    headline?: string;
    /** Phone numbers of the user. */
    phone_numbers?: string[];
    /** State of the user. */
    state?: UserState;
    /** Visibility of the profile to other users. */
    visibility?: DevrevProfileVisibility;
}
/**
 * profiles-self-update-response
 * The response for the request to update a user's profile information.
 */
export interface ProfilesSelfUpdateResponse {
    profile: DevrevProfile;
}
/** project */
export type Project = WorkBase & {
    /** Part versions relevant to the work. */
    applies_to_versions?: string[];
    /** Priority of the work based upon impact and criticality. */
    priority?: ProjectPriority;
    /** Type of project. */
    project_type?: ProjectType;
    /**
     * Timestamp when the project started.
     * @format date-time
     */
    start_date?: string;
};
/** Priority of the work based upon impact and criticality. */
export declare enum ProjectPriority {
    P0 = "p0",
    P1 = "p1",
    P2 = "p2",
    P3 = "p3"
}
/** project-summary */
export type ProjectSummary = WorkBaseSummary;
/** Type of project. */
export declare enum ProjectType {
    DeliverableBased = "deliverable_based",
    TimeBased = "time_based"
}
/**
 * pull-request
 * A Pull Request object.
 */
export interface PullRequest {
    /** PR Description. */
    description?: string;
    /** PR ID. Example - PR-503. */
    id?: string;
    /** PR Title. */
    title?: string;
    /** URL. */
    url?: string;
}
/** push-device */
export type PushDevice = AtomBase & {
    /** The unique identifier associated with the device. */
    device_id?: string;
    /**
     * The last time the device token was updated.
     * @format date-time
     */
    timestamp?: string;
    /** The token associated with the device. */
    token?: string;
    /** The type of the push device. */
    type?: PushDeviceType;
};
/** push-device-summary */
export type PushDeviceSummary = AtomBaseSummary;
/** The type of the push device. */
export declare enum PushDeviceType {
    Android = "android",
    Chrome = "chrome",
    Ios = "ios"
}
/**
 * push-devices-register-request
 * The request to register a push device.
 */
export interface PushDevicesRegisterRequest {
    /** The unique identifier of the device. */
    device_id: string;
    /** The token to associate with the push device. */
    token: string;
    /** The type of the push device. */
    type: PushDeviceType;
}
/**
 * push-devices-register-response
 * The response to registering a push device.
 */
export interface PushDevicesRegisterResponse {
    device: PushDevice;
}
/**
 * push-devices-unregister-request
 * The request to unregister a push device.
 */
export interface PushDevicesUnregisterRequest {
    /** The unique identifier of the device. */
    device_id: string;
    /** The token associated with the push device. */
    token?: string;
}
/**
 * push-devices-update-request
 * The request to update the timestamp on a push device.
 */
export interface PushDevicesUpdateRequest {
    /** The unique identifier of the device. */
    device_id: string;
    /** The token associated with the push device. */
    token?: string;
}
/**
 * push-devices-update-response
 * The response to updating the timestamp on a push device.
 */
export interface PushDevicesUpdateResponse {
    device: PushDevice;
}
/** reactions-add-request */
export interface ReactionsAddRequest {
    /** The reaction emoji to add. */
    emoji: string;
    /**
     * The object to add the reaction to.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    object: string;
}
/** reactions-add-response */
export type ReactionsAddResponse = object;
/** reactions-list-request */
export interface ReactionsListRequest {
    /**
     * The cursor to resume iteration from, otherwise if not provided,
     * then iteration starts from the beginning.
     */
    cursor?: string;
    /** The emoji to list reactions for. */
    emoji: string;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * The ID of the object to list reactions to.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    object: string;
}
/** reactions-list-response */
export interface ReactionsListResponse {
    /**
     * The cursor that should be used to iterate the next sequence of
     * results, otherwise if not set, then no elements exist after.
     */
    next_cursor?: string;
    /**
     * The cursor that should be used to iterate the previous sequence of
     * results, otherwise if not set, then no elements exist before.
     */
    prev_cursor?: string;
    /** The users that have reacted. */
    users: UserSummary[];
}
/** reactions-remove-request */
export interface ReactionsRemoveRequest {
    /** The reaction emoji to remove. */
    emoji: string;
    /**
     * The object to remove the reaction from.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    object: string;
}
/** reactions-remove-response */
export type ReactionsRemoveResponse = object;
/** real-time-insight */
export type RealTimeInsight = InsightBase;
/** real-time-insight-summary */
export type RealTimeInsightSummary = InsightBaseSummary;
/** real-time-insight-value */
export type RealTimeInsightValue = InsightValueBase & {
    /** Current value of the real time insight. */
    value?: object;
};
/** real-time-insight-value-summary */
export type RealTimeInsightValueSummary = InsightValueBaseSummary;
/** recent-frame */
export interface RecentFrame {
    comments: ObjectFrame[];
    conversations: string[];
    dev_users: string[];
    notifications: string[];
    parts: ObjectFrame[];
    rev_users: string[];
    tags: string[];
    vistas: ObjectFrame[];
    works: ObjectFrame[];
}
/**
 * recommendation
 * Autosuggest recommendation for given required fields.
 */
export interface Recommendation {
    /** List of recommended parts. */
    applies_to_part?: RecommendationItem[];
    /** List of recommended owners. */
    owned_by?: RecommendationItem[];
    /** List of recommended tags. */
    tag?: RecommendationItem[];
}
/**
 * recommendation-item
 * An autosuggest suggestion item.
 */
export interface RecommendationItem {
    applies_to_part?: PartSummary;
    /**
     * Confidence score of the recommendation.
     * @format float
     */
    confidence: number;
    /** Explanation for the recommendation. */
    explanation?: string;
    owned_by?: UserSummary;
    tag?: TagSummary;
    value?: 'applies_to_part' | 'owned_by' | 'tag';
}
/** recurring-line-item-summary */
export type RecurringLineItemSummary = LineItemBaseSummary;
/**
 * remove-object-member-request
 * A request to create a new object member.
 */
export interface RemoveObjectMemberRequest {
    /** ID of the user or group. */
    member_id: string;
    /**
     * Globally unique DevRev Object Name (DON) for the object where the
     * member is being added.
     */
    object_id: string;
}
/** remove-object-member-response */
export type RemoveObjectMemberResponse = object;
/**
 * resource
 * Resource details.
 */
export interface Resource {
    /** Ids of the artifacts. */
    artifact_ids?: ArtifactSummary[];
    /** Type of the article resource. */
    type?: ResourceType;
    /** URL of the external article. */
    url?: string;
}
/** Type of the article resource. */
export declare enum ResourceType {
    Artifact = "artifact",
    Url = "url"
}
/**
 * rev-location-summary
 * Rev Part location details.
 */
export interface RevLocationSummary {
    /**
     * The detailed path inside an OpenAPI file where information about
     * this API object and its version were found.
     */
    param_paths?: string[];
    /**
     * The name of the repo where information about this API object and
     * its version were found.
     */
    repo_name?: string;
    /**
     * The repo path where information about this API object and its
     * version were found.
     */
    repo_path?: string;
    /**
     * The source where information about this API object and its version
     * were found.
     */
    source?: string;
}
/** rev-org */
export type RevOrg = OrgBase & {
    account?: AtomSummary;
    /** Custom fields. */
    custom_fields?: object;
    /** Custom schema fragments. */
    custom_schema_fragments?: string[];
    /** Custom schema fragments. */
    custom_schema_fragments_v1?: string;
    /** Description of the Rev organization. */
    description?: string;
    /** Company's domain name. Example - 'devrev.ai'. */
    domain?: string;
    /**
     * External ref is a unique identifier for the Rev (customer)
     * organization from your primary customer system of records. If none
     * is specified, a system-generated identifier will be assigned to the
     * organization.
     */
    external_ref?: string;
    /**
     * External ref issuer is the external system of records from which
     * this Rev organization's data is imported. If external_ref is
     * provided during create and external_ref_issuer isn't, then issuer's
     * value is set to 'devrev:default'.
     */
    external_ref_issuer?: string;
    /** List of Dev user IDs' owning this Rev organization. */
    owned_by: UserSummary[];
    /**
     * Combination of stock and custom schema fragment IDs.
     * @deprecated
     */
    schema_fragment_ids?: string[];
    /** Combination of stock and custom schema fragment IDs. */
    schema_fragment_ids_v1?: string;
    sla?: AtomSummary;
    /** Stock schema fragment. */
    stock_schema_fragment?: string;
    /** Stock schema fragment. */
    stock_schema_fragment_v1?: string;
    /** Subtype corresponding to the custom type fragment. */
    subtype?: string;
    /** Tags associated with an object. */
    tags?: TagWithValue[];
    /** The Tier of the corresponding RevOrg. */
    tier?: string;
    /** The type of the Rev organization. */
    type?: RevOrgType;
};
/**
 * rev-org-commerce-details
 * RevOrg commerce details contains commerce related data for a RevOrg.
 * Stores commerce configurations, billing details, shipping details, etc.
 */
export interface RevOrgCommerceDetails {
    /** The account ID of the dev_org. */
    account_id?: string;
    /** Contact Details of the customer. */
    billing_details?: ContactDetails;
    /** The billing contact's email. */
    billing_email: string;
    /**
     * Settings related to payment, proration, etc. Configurations may or may
     * not be defined by a DevO. 1. If DevO defines configurations then same
     * configurations are copied to RevO also to sub pack (for now, later RevO
     * can also set) 2. If DevO doesn't set anything then these configurations
     * would be set to default by application for which they were being
     * defined (for eg. if DevO doesn't set payment method for it's RevOs then
     * stripe would set it to 'charge_automatically' by default).
     */
    configurations: Configuration;
    /** Contact Details of the customer. */
    shipping_details?: ContactDetails;
}
/**
 * rev-org-membership
 * Rev Org the user belongs to.
 */
export interface RevOrgMembership {
    rev_org_id?: OrgSummary;
}
/** rev-org-summary */
export type RevOrgSummary = OrgBaseSummary;
/** The type of the Rev organization. */
export declare enum RevOrgType {
    B2B = "b2b",
    B2C = "b2c"
}
/**
 * rev-orgs-bulk-create-request
 * Request object to bulk create Rev organizations.
 */
export interface RevOrgsBulkCreateRequest {
    /**
     * Input file bytes of uploaded CSV file.
     * @format binary
     */
    data: File;
    rev_orgs_create_bulk_request_type: RevOrgsBulkRequestEnum;
}
/**
 * rev-orgs-bulk-create-response
 * Response object to create bulk Rev organizations under the given Dev
 * organization.
 */
export interface RevOrgsBulkCreateResponse {
    /**
     * List of all CSV headers which were invalid with stock and custom
     * fields.
     */
    invalid_csv_headers?: string[];
    /** List of all the Rev organization details. */
    rev_orgs: RevOrg[];
    /** List of all the errors occurred in the rows. */
    row_errors?: RowError[];
}
export declare enum RevOrgsBulkRequestEnum {
    Create = "create",
    PreviewHeaders = "preview_headers",
    PreviewRecords = "preview_records"
}
/** rev-orgs-commerce-details-get-request */
export interface RevOrgsCommerceDetailsGetRequest {
    /**
     * The rev org's DON.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id?: string;
}
/** rev-orgs-commerce-details-get-response */
export interface RevOrgsCommerceDetailsGetResponse {
    /**
     * RevOrg commerce details contains commerce related data for a RevOrg.
     * Stores commerce configurations, billing details, shipping details, etc.
     */
    commerce_details: RevOrgCommerceDetails;
}
/** rev-orgs-commerce-details-update-request */
export interface RevOrgsCommerceDetailsUpdateRequest {
    /** Contact Details of the customer. */
    billing_details?: ContactDetails;
    /** Billing email of the rev_org. */
    billing_email?: string;
    /**
     * Settings related to payment, proration, etc. Configurations may or may
     * not be defined by a DevO. 1. If DevO defines configurations then same
     * configurations are copied to RevO also to sub pack (for now, later RevO
     * can also set) 2. If DevO doesn't set anything then these configurations
     * would be set to default by application for which they were being
     * defined (for eg. if DevO doesn't set payment method for it's RevOs then
     * stripe would set it to 'charge_automatically' by default).
     */
    configuration?: Configuration;
    /**
     * The rev org's DON.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id?: string;
    /** Contact Details of the customer. */
    shipping_details?: ContactDetails;
}
/** rev-orgs-commerce-details-update-response */
export interface RevOrgsCommerceDetailsUpdateResponse {
    /**
     * RevOrg commerce details contains commerce related data for a RevOrg.
     * Stores commerce configurations, billing details, shipping details, etc.
     */
    commerce_details: RevOrgCommerceDetails;
}
/** rev-orgs-count-request */
export interface RevOrgsCountRequest {
    /** Filters by account. */
    account?: string[];
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/** rev-orgs-count-response */
export interface RevOrgsCountResponse {
    /**
     * Count of Rev organizations matching the filter.
     * @format int32
     */
    count: number;
}
/**
 * rev-orgs-create-request
 * Request object to create a new Rev organization in the Dev
 * organization.
 */
export interface RevOrgsCreateRequest {
    /** Account Id this Rev organization is to be associated to. */
    account?: string;
    /** Create object for postal_address. */
    address?: CreatePostalAddress;
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** Description of the Rev organization. */
    description?: string;
    /** Name of the Rev organization. */
    display_name: string;
    /** Company's domain name. Example - 'devrev.ai'. */
    domain?: string;
    /** The environment of the Org. Defaults to 'production' if not specified. */
    environment?: OrgEnvironment;
    /**
     * External ref is a custom unique identifier which is a reference to
     * an unique id for this organization's data in some system of
     * records.
     */
    external_ref?: string;
    /**
     * External ref issuer is a reference to an external system of records
     * from which this organization's data is imported. If external_ref is
     * provided during create and external_ref_issuer isn't, then its
     * value is set to 'devrev:default'.
     */
    external_ref_issuer?: string;
    /** List of Dev users owning this Rev organization. */
    owned_by?: string[];
    /**
     * List of Dev users owning this Rev organization.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** Phone numbers for the Rev organization. */
    phone_number?: CreatePhoneNumber[];
    /** Phone numbers for the Rev organization. */
    phone_numbers?: string[];
    /** Schema fragment IDs associated with this Rev organization SOR. */
    schema_fragment_ids?: string[];
    /** State of the Organization. */
    state?: OrgState;
    /** Tags associated with the Rev organization. */
    tags?: SetTagWithValue[];
    /** The tier of the RevOrg. */
    tier?: string;
    /** The type of the Rev organization. */
    type?: RevOrgType;
}
/**
 * rev-orgs-create-response
 * Response object for request to create a new Rev organization.
 */
export interface RevOrgsCreateResponse {
    rev_org: RevOrg;
}
/**
 * rev-orgs-delete-request
 * Request object to delete a Rev organization.
 */
export interface RevOrgsDeleteRequest {
    /**
     * The ID of Rev organization to delete.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id: string;
}
/**
 * rev-orgs-delete-response
 * The response to deleting a Rev organization.
 */
export type RevOrgsDeleteResponse = object;
/** rev-orgs-export-request */
export interface RevOrgsExportRequest {
    /** Filters by account. */
    account?: string[];
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    /**
     * The number of Rev Organisations to return. The default is '50', the
     * maximum is '5000'.
     * @format int32
     */
    first?: number;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /**
     * Fields to sort the Rev Organisations by and the direction to sort
     * them.
     */
    sort_by?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/** rev-orgs-export-response */
export interface RevOrgsExportResponse {
    /** The resulting list of Rev Organisations. */
    rev_orgs: RevOrg[];
}
/**
 * rev-orgs-get-request
 * Request object to get Rev organization's information.
 */
export interface RevOrgsGetRequest {
    /**
     * The ID of the required Rev organization.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id: string;
}
/**
 * rev-orgs-get-response
 * The response to getting a Rev organization's information.
 */
export interface RevOrgsGetResponse {
    rev_org: RevOrg;
}
/**
 * rev-orgs-group
 * Group object for Rev organizations group request.
 */
export interface RevOrgsGroup {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** Unique key according to which the items are grouped. */
    key: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The group of Rev organizations. */
    rev_orgs: RevOrg[];
}
/**
 * rev-orgs-group-request
 * A request to get group list of Rev organizations for the authenticated
 * user's Dev organization.
 */
export interface RevOrgsGroupRequest {
    /** Filters by account. */
    account?: string[];
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    /** The field to group the rev orgs by. */
    group_by: string;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of rev orgs to return for an individual group.
     * If not set, then the default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** Fields to sort the rev orgs by. */
    sort_by?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/**
 * rev-orgs-group-response
 * Response object for Rev organizations group request.
 */
export interface RevOrgsGroupResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** The list of groups. */
    groups: RevOrgsGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * rev-orgs-list-request
 * A request to get the list of Rev organizations for the authenticated
 * user's Dev organization.
 */
export interface RevOrgsListRequest {
    /** Filters by account. */
    account?: string[];
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    /**
     * The maximum number of Rev organizations to be retrieved per page.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /**
     * Fields to sort the Rev organizations by and the direction to sort
     * them.
     */
    sort_by?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/**
 * rev-orgs-list-response
 * The response to getting a list of Rev organizations' information.
 */
export interface RevOrgsListResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** List with all of the Rev organizations' information. */
    rev_orgs: RevOrg[];
    /**
     * Total number of Rev organizations matching the input filter.
     * @deprecated
     * @format int32
     */
    total: number;
}
/**
 * rev-orgs-update-request
 * Request object to update information of the Rev organization.
 */
export interface RevOrgsUpdateRequest {
    /** New account Id this Rev organization is to be associated to. */
    account?: string;
    /** Update object for PostalAddress. */
    address?: UpdatePostalAddress;
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** Description of the Rev organization. */
    description?: string;
    /** Customer chosen name for the Rev organization. */
    display_name?: string;
    /** Company's domain name. Example - 'devrev.ai'. */
    domain?: string;
    /** The environment of the Org. Defaults to 'production' if not specified. */
    environment?: OrgEnvironment;
    /**
     * External ref is a custom unique identifier which is a reference to
     * an unique id for this organization's data in some system of
     * records.
     */
    external_ref?: string;
    /**
     * External ref issuer is a reference to an external system of records
     * from which this organization's data is imported. If external_ref is
     * provided during create and external_ref_issuer isn't, then its
     * value is set to 'devrev:default'.
     */
    external_ref_issuer?: string;
    /**
     * The ID of Rev organization to update.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id: string;
    /**
     * Artifact ID of the Rev organization's logo.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    logo_id?: string | null;
    /** List of Dev users owning this Rev organization. */
    owned_by?: string[];
    /**
     * List of Dev user IDs owning the Rev organization.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** Phone numbers of the Rev organization. */
    phone_number?: UpdatePhoneNumber[];
    /** Phone numbers of the Rev org. */
    phone_numbers?: string[];
    /** Schema fragment IDs associated with this Rev organization SOR. */
    schema_fragment_ids?: string[];
    /** State of the Organization. */
    state?: OrgState;
    /** Tags associated with the Rev organization. */
    tags?: SetTagWithValue[];
    /** The tier of the RevOrg. */
    tier?: string;
    /** The type of the Rev organization. */
    type?: RevOrgType;
}
/**
 * rev-orgs-update-response
 * Response object to updating Rev organization's information.
 */
export interface RevOrgsUpdateResponse {
    rev_org: RevOrg;
}
/**
 * rev-portal-group
 * Preferences group for Rev-Portal.
 */
export interface RevPortalGroup {
    /** Preferences group for Ticket creation. */
    ticket_creation_preferences?: TicketCreationGroup;
}
/** rev-user */
export type RevUser = UserBase & {
    /** Custom fields. */
    custom_fields?: object;
    /** Custom schema fragments. */
    custom_schema_fragments?: string[];
    /** Custom schema fragments. */
    custom_schema_fragments_v1?: string;
    /** Description of the Rev user. */
    description?: string;
    /**
     * External ref is a mutable unique identifier for a user within the
     * Rev organization from your primary customer record. If none is
     * available, a good alternative is the email address/phone number
     * which could uniquely identify the user. If none is specified, a
     * system-generated identifier will be assigned to the user.
     */
    external_ref?: string;
    /**
     * External ref issuer is the external system of records from which
     * this Rev user's data is imported. If external_ref is provided
     * during create and external_ref_issuer isn't, then issuer's value is
     * set to 'devrev:default'.
     */
    external_ref_issuer?: string;
    /**
     * External ref is a unique identifier for a user within the
     * organization from your primary customer record. If none is
     * available, a good alternative is the email address/phone number
     * which could uniquely identify the user. If none is specified, a
     * system-generated identifier will be assigned to the user.
     */
    external_uid?: string;
    /**
     * External ref issuer is the external system of records from which
     * this Rev user's data is imported. If external_ref is provided
     * during create and external_ref_issuer isn't, then issuer's value is
     * set to 'devrev:default'.
     */
    external_uid_issuer?: string;
    /** The display id of the corresponding Rev Organization. */
    rev_oid?: string;
    rev_org?: OrgSummary;
    /** Rev Orgs the user is associated with. */
    rev_orgs?: RevOrgMembership[];
    /**
     * Combination of stock and custom schema fragment IDs.
     * @deprecated
     */
    schema_fragment_ids?: string[];
    /** Combination of stock and custom schema fragment IDs. */
    schema_fragment_ids_v1?: string;
    /** Stock schema fragment. */
    stock_schema_fragment?: string;
    /** Stock schema fragment. */
    stock_schema_fragment_v1?: string;
    /** Subtype corresponding to the custom type fragment. */
    subtype?: string;
    /** Tags associated with the object. */
    tags?: TagWithValue[];
    /** Type of the user. */
    user_type?: RevUserUserType;
};
/** rev-user-summary */
export type RevUserSummary = UserBaseSummary & {
    rev_org?: OrgSummary;
};
/** Type of the user. */
export declare enum RevUserUserType {
    Anonymous = "anonymous",
    Identified = "identified"
}
/** rev-users-count-request */
export interface RevUsersCountRequest {
    /** Filters for Rev users that were created by the specified user(s). */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
     */
    custom_field_filter?: string[];
    /** List of emails of Rev users to be filtered. */
    email?: string[];
    /** List of external ref for Rev users to be filtered. */
    external_ref?: string[];
    /** List of external ref issuers for Rev users to be filtered. */
    external_ref_issuer?: string[];
    modified_date?: DateTimeFilter;
    /**
     * List of Rev organizations IDs for Rev users to be filtered.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** List of state of Rev users to be filtered. */
    state?: UserState[];
    /**
     * List of tags to be filtered. Input will be of the format (tags=<tag
     * id 1>=<value>&tags=<tag id 2>).
     */
    tags?: string[];
}
/** rev-users-count-response */
export interface RevUsersCountResponse {
    /**
     * Count of Rev users matching the filter.
     * @format int32
     */
    count: number;
}
/**
 * rev-users-create-request
 * Request object to create a new Rev user for a Rev organization.
 */
export interface RevUsersCreateRequest {
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** Description of the Rev user. */
    description?: string;
    /**
     * Display handle of the user. This handle will be used for
     * referencing a Rev user. Eg. in conversations.
     * @deprecated
     */
    display_handle?: string;
    /** The user's display name. The name is non-unique and mutable. */
    display_name?: string;
    /** Email address of the Rev user. */
    email?: string;
    /**
     * External ref is a mutable unique identifier for a user within the
     * organization from your primary customer record. If none is
     * available, a good alternative is the email address/phone number
     * which could uniquely identify the user. If none is specified, a
     * system-generated identifier will be assigned to the user.
     */
    external_ref?: string;
    /**
     * External ref issuer is the external system of records from which
     * this Rev user's data is imported. If external_ref is provided
     * during create and external_ref_issuer isn't, then issuer's value is
     * set to 'devrev:default'.
     */
    external_ref_issuer?: string;
    /**
     * External user id is a custom unique identifier which is a reference
     * to an unique id for this user's data in some system of records.
     * @deprecated
     */
    external_uid?: string;
    /**
     * External user id issuer is a reference to an external system of
     * records from which this user's data is imported. If
     * external_user_id is provided during create and
     * external_user_id_issuer isn't, then its value is set to
     * 'devrev:default'.
     * @deprecated
     */
    external_uid_issuer?: string;
    /**
     * The ID of Rev organization for which a Rev user is to be created.
     * This field is deprecated now. User rev_org field instead.
     * @deprecated
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    org_id: string;
    /** Phone numbers of the Rev user. */
    phone_numbers?: string[];
    /**
     * The ID of Rev organization for which a Rev user is to be created.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org?: string;
    /** Schema fragment IDs. */
    schema_fragment_ids?: string[];
    /** State of the user. */
    state?: UserState;
    /** Tags associated with the Rev user. */
    tags?: SetTagWithValue[];
}
/**
 * rev-users-create-response
 * Response object for creating a new Rev user for Rev organization.
 */
export interface RevUsersCreateResponse {
    rev_user: RevUser;
}
/**
 * rev-users-delete-request
 * Request object to delete a Rev user.
 */
export interface RevUsersDeleteRequest {
    /** The ID of Rev user to delete. */
    id: string;
}
/**
 * rev-users-delete-response
 * The response to deleting a Rev user of a Rev organization.
 */
export type RevUsersDeleteResponse = object;
/**
 * rev-users-get-request
 * Request object to get a Rev user.
 */
export interface RevUsersGetRequest {
    /** The ID of Rev user to be retrieved. */
    id: string;
}
/**
 * rev-users-get-response
 * The returned Rev user.
 */
export interface RevUsersGetResponse {
    rev_user: RevUser;
}
/**
 * rev-users-group
 * Group object for RevUsers Group request.
 */
export interface RevUsersGroup {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** Unique key according to which the items are grouped. */
    key: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The group of Rev users. */
    rev_users: RevUser[];
}
/**
 * rev-users-group-request
 * A request to get group list of Rev users for the authenticated user's
 * Dev Organization.
 */
export interface RevUsersGroupRequest {
    /** Filters for Rev users that were created by the specified user(s). */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
     */
    custom_field_filter?: string[];
    /** List of emails of Rev users to be filtered. */
    email?: string[];
    /** List of external ref for Rev users to be filtered. */
    external_ref?: string[];
    /** List of external ref issuers for Rev users to be filtered. */
    external_ref_issuer?: string[];
    /** The field to group the rev users by. */
    group_by: string;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of rev users to return for an individual group.
     * If not set, then the default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /** Array of display id's of Rev organizations to be filtered. */
    rev_oid?: string[];
    /** Fields to sort the Rev users by. */
    sort_by?: string[];
    /** List of state of Rev users to be filtered. */
    state?: UserState[];
    /**
     * List of tags to be filtered. Input will be of the format (tags=<tag
     * id 1>=<value>&tags=<tag id 2>).
     */
    tags?: string[];
}
/**
 * rev-users-group-response
 * Response object for RevUsers Group request.
 */
export interface RevUsersGroupResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /** The list of groups. */
    groups: RevUsersGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/**
 * rev-users-list-all-request
 * A request to list all Rev users' information in a Dev organization.
 */
export interface RevUsersListAllRequest {
    /** Filters for Rev users that were created by the specified user(s). */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
     */
    custom_field_filter?: string[];
    /** List of emails of Rev users to be filtered. */
    email?: string[];
    /** List of external ref for Rev users to be filtered. */
    external_ref?: string[];
    /** List of external ref issuers for Rev users to be filtered. */
    external_ref_issuer?: string[];
    /**
     * The maximum number of Rev users to return per page. The default is
     * '50', the maximum is '100'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /**
     * Array of display id's of Rev orgs to be filtered.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_oid?: string[];
    /**
     * Array of ID's of Rev orgs to be filtered.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Fields to sort the Rev users by and the direction to sort them. */
    sort_by?: string[];
    /** List of state of Rev users to be filtered. */
    state?: UserState[];
    /**
     * List of tags to be filtered. Input will be of the format (tags=<tag
     * id 1>=<value>&tags=<tag id 2>).
     */
    tags?: string[];
}
/**
 * rev-users-list-all-response
 * The response to list all of the Rev users in a Dev organization.
 */
export interface RevUsersListAllResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** List with all of the Rev users' information. */
    rev_users: RevUser[];
    /**
     * Total number of Rev users matching the input filter.
     * @deprecated
     * @format int32
     */
    total: number;
}
/**
 * rev-users-list-request
 * Gets the list of Rev users belonging to the authenticated user's Dev
 * Organization which the user is also authorized to access.
 */
export interface RevUsersListRequest {
    /** Filters for Rev users that were created by the specified user(s). */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
     */
    custom_field_filter?: string[];
    /** List of emails of Rev users to be filtered. */
    email?: string[];
    /** List of external ref for Rev users to be filtered. */
    external_ref?: string[];
    /** List of external ref issuers for Rev users to be filtered. */
    external_ref_issuer?: string[];
    /**
     * The maximum number of Rev users to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    modified_date?: DateTimeFilter;
    /**
     * The ID of Rev organization to list all Rev users of.
     * @deprecated
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    org_id?: string;
    /**
     * List of IDs of Rev organizations to be filtered.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Fields to sort the Rev users by and the direction to sort them. */
    sort_by?: string[];
    /** List of state of Rev users to be filtered. */
    state?: UserState[];
    /**
     * List of tags to be filtered. Input will be of the format (tags=<tag
     * id 1>=<value>&tags=<tag id 2>).
     */
    tags?: string[];
}
/**
 * rev-users-list-response
 * The response to listing all Rev users matching the filter criteria.
 */
export interface RevUsersListResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** List containing all the Rev users. */
    rev_users: RevUser[];
    /**
     * Total number of Rev users matching the input filter.
     * @deprecated
     * @format int32
     */
    total: number;
}
/**
 * rev-users-self-request
 * A request to get the authenticated user's information.
 */
export type RevUsersSelfRequest = object;
/**
 * rev-users-self-response
 * The response to getting the information for the authenticated user.
 */
export interface RevUsersSelfResponse {
    rev_user: RevUser;
}
/**
 * rev-users-self-update-request
 * A request to update the user's information for the authenticated Rev
 * user.
 */
export interface RevUsersSelfUpdateRequest {
    /**
     * The updated display handle of the Rev user.
     * @deprecated
     */
    display_handle?: string;
    /** The updated display name of the Rev user. */
    display_name?: string;
    /** The email address of the Rev user. */
    email?: string;
    /** The updated full name of the Rev user. */
    full_name?: string;
}
/**
 * rev-users-self-update-response
 * The response to update the authenticated Rev user.
 */
export interface RevUsersSelfUpdateResponse {
    rev_user: RevUser;
}
/**
 * rev-users-update-request
 * Request to update details of a Rev user.
 */
export interface RevUsersUpdateRequest {
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** Updated description of the Rev user. */
    description?: string;
    /**
     * Updated display handle of the Rev user.
     * @deprecated
     */
    display_handle?: string;
    /** Updated display name of the Rev user. */
    display_name?: string;
    /**
     * Artifact ID of a Rev user's updated display picture.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture_id?: string | null;
    /** Updated email address of the Rev user. */
    email?: string;
    /** Updated external ref value of the Rev user. */
    external_ref?: string;
    /**
     * External ref issuer is the external system of records from which
     * this Rev user's data is imported. If external_ref is provided
     * during create and external_ref_issuer isn't, then issuer's value is
     * set to 'devrev:default'.
     */
    external_ref_issuer?: string;
    /**
     * External uid is a mutable unique identifier for a user within the
     * Rev organization from your primary customer record. If none is
     * available, a good alternative is the email address/phone number
     * which could uniquely identify the user. If none is specified, a
     * system-generated identifier will be assigned to the user.
     * @deprecated
     */
    external_uid?: string;
    /**
     * External uid issuer is the external system of records from which
     * this Rev user's data is imported. If external_uid is provided
     * during create and external_uid_issuer isn't, then issuer's value is
     * set to 'devrev:default'.
     * @deprecated
     */
    external_uid_issuer?: string;
    /** The ID of Rev user to update. */
    id: string;
    /** Phone numbers of the Rev user. */
    phone_numbers?: string[];
    /** Schema fragment IDs. */
    schema_fragment_ids?: string[];
    /** State of the user. */
    state?: UserState;
    /** Tags associated with the Rev user. */
    tags?: SetTagWithValue[];
}
/**
 * rev-users-update-response
 * Updated Rev user object.
 */
export interface RevUsersUpdateResponse {
    rev_user: RevUser;
}
/** reward */
export type Reward = AtomBase & {
    /**
     * The reward points awarded.
     * @format int32
     */
    amount: number;
    /**
     * The reward amount expired.
     * @format int32
     */
    amount_expired: number;
    /**
     * The reward amount used.
     * @format int32
     */
    amount_used: number;
    /** Description for the Reward. */
    description?: string;
    /**
     * Date on which remaining reward amount expires.
     * @format date-time
     */
    expiry_time: string;
    rev_org: OrgSummary;
    rev_user?: UserSummary;
};
/** reward-summary */
export type RewardSummary = AtomBaseSummary;
/** reward-transaction */
export type RewardTransaction = AtomBase & {
    /**
     * The reward points transferred as part of this transaction.
     * @format int32
     */
    amount_transferred: number;
    /** Details of the Reward Transaction. */
    description?: string;
    rev_org: OrgSummary;
    rev_user?: UserSummary;
    /**
     * Date of the transaction.
     * @format date-time
     */
    transaction_time: string;
};
/** reward-transaction-summary */
export type RewardTransactionSummary = AtomBaseSummary;
/** reward-transactions-list-request */
export interface RewardTransactionsListRequest {
    /**
     * The transaction date from which to aggregate reward transaction
     * objects.
     * @format date-time
     */
    from_transaction_date?: string;
    /**
     * List of fields to sort the reward transaction object, by and how to
     * sort them. Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /**
     * The transaction date till which to aggregate reward transaction
     * objects.
     * @format date-time
     */
    to_transaction_date?: string;
}
/** reward-transactions-list-response */
export interface RewardTransactionsListResponse {
    /** The list of reward transaction objects. */
    reward_transactions: RewardTransaction[];
}
/** rewards-create-request */
export interface RewardsCreateRequest {
    /** Description of the reward object. */
    description?: string;
    /**
     * Timestamp when the rewarded points will expire.
     * @format date-time
     */
    expiry_time?: string;
    /**
     * The rev org for which reward is being created.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
    /**
     * The rev user for which reward is being created (if reward is for a
     * rev user).
     */
    rev_user_id?: string;
    /**
     * The reward points being awarded.
     * @format int64
     */
    reward_points: number;
}
/** rewards-create-response */
export interface RewardsCreateResponse {
    reward: Reward;
}
/** rewards-get-request */
export interface RewardsGetRequest {
    /** The reward object's DON. */
    id: string;
}
/** rewards-get-response */
export interface RewardsGetResponse {
    reward: Reward;
}
/** rewards-list-request */
export interface RewardsListRequest {
    /**
     * The expiry date from which to aggregate reward objects.
     * @format date-time
     */
    from_expiry_date?: string;
    /**
     * List of fields to sort the reward object, by and how to sort them.
     * Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /**
     * The expiry date till which to aggregate reward objects.
     * @format date-time
     */
    to_expiry_date?: string;
}
/** rewards-list-response */
export interface RewardsListResponse {
    /** The list of reward objects. */
    rewards: Reward[];
}
/** rewards-transfer-request */
export interface RewardsTransferRequest {
    /**
     * The recipient rev user for the reward transfer (if any).In case,
     * when 'destination_rev_user_id' is not provided then, by default rev
     * org is the recipient of the transfer.
     */
    destination_rev_user_id?: string;
    /**
     * The reward points to be transferred.
     * @format int64
     */
    transfer_amount: number;
}
/** rewards-transfer-response */
export interface RewardsTransferResponse {
    reward_transaction: RewardTransaction;
}
/** rewards-transfer-to-credits-request */
export interface RewardsTransferToCreditsRequest {
    /**
     * The reward points to be transferred.
     * @format int64
     */
    transfer_amount: number;
}
/** rewards-transfer-to-credits-response */
export interface RewardsTransferToCreditsResponse {
    reward_transaction: RewardTransaction;
}
/** role */
export type Role = AtomBase & {
    /** Description of the role. */
    description?: string;
    /** IDs of the role(s) that include the role. */
    included_in?: RoleSummary[];
    /** IDs of the role(s) that the role includes. */
    includes?: RoleSummary[];
    /** Name of the role. */
    name?: string;
    /** Privileges the role includes. */
    privileges: string[];
};
/** role-summary */
export type RoleSummary = AtomBaseSummary;
/**
 * roles-create-request
 * A request to create a new role.
 */
export interface RolesCreateRequest {
    /** The description of the role. */
    description: string;
    /** The IDs of the roles that are included in this role. */
    includes?: string[];
    /** The name of the role. */
    name: string;
    /** The privileges associated with this role. */
    privileges: string[];
}
/**
 * roles-create-response
 * A response to a request to create a new role.
 */
export interface RolesCreateResponse {
    role: Role;
}
/**
 * roles-delete-request
 * A request to delete a role.
 */
export interface RolesDeleteRequest {
    /** ID for the role. */
    id: string;
}
/**
 * roles-delete-response
 * The response to the request to delete the role.
 */
export type RolesDeleteResponse = object;
/**
 * roles-get-request
 * A request to get a role's information.
 */
export interface RolesGetRequest {
    /** ID for the role. */
    id: string;
}
/**
 * roles-get-response
 * The response to getting the information for the role.
 */
export interface RolesGetResponse {
    role: Role;
}
/**
 * roles-list-request
 * A request to get information about a list of roles.
 */
export type RolesListRequest = object;
/**
 * roles-list-response
 * The response to listing the roles.
 */
export interface RolesListResponse {
    /** The list of roles. */
    roles: Role[];
}
/** room */
export type Room = AtomBase & {
    /** Description of the room. */
    description?: string;
    parent?: AtomSummary;
    /** Unique token for joining the room. */
    token?: string;
};
/** room-summary */
export type RoomSummary = AtomBaseSummary;
/**
 * rooms-create-request
 * A request to create a video-call room.
 */
export interface RoomsCreateRequest {
    /** Description of the room. */
    description?: string;
    /**
     * The users that should be invited to the huddle.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    invite_users?: string[];
    /** The parent object ID in which the room is created. */
    parent_id: string;
}
/**
 * rooms-create-response
 * Create room response.
 */
export interface RoomsCreateResponse {
    room: Room;
}
/**
 * rooms-inform-request
 * A request to inform a room of a user update.
 */
export interface RoomsInformRequest {
    /**
     * The users that should be invited to the huddle.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    invite_users?: string[];
    /** The parent object ID in which the room is informed. */
    parent_id: string;
    status?: RoomsInformRequestStatusValue;
}
export declare enum RoomsInformRequestStatusValue {
    Joined = "joined",
    Left = "left"
}
/** rooms-inform-response */
export type RoomsInformResponse = object;
/** row-error */
export interface RowError {
    /** List of all the errors in a single row. */
    errors: string[];
}
/** run-discovery-request */
export interface RunDiscoveryRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
    /** Optional list of sources which will override discovery profile. */
    sources?: string[];
}
/** run-discovery-response */
export interface RunDiscoveryResponse {
    run: DiscoveryRun;
}
/** runnable */
export type Runnable = PartBase & {
    /**
     * Code part surface area is defined as all the source files or file
     * globs that make up this code part. This field lists the surface
     * area of this code part as it was inferred automatically.
     */
    code_inferred_surface_area?: string[];
    /**
     * The details of the last inference of this part.
     * @format int32
     */
    code_last_inference_details?: number;
    /** Paths in the repository for the code part. */
    code_repo_paths?: string;
    /** URL to the server & repo for the code part. */
    code_repo_url?: string;
    /** Versions of the code. */
    code_versions?: number[];
    /**
     * A confidence score computed by the inference engine. Currently, the
     * score is not normalized across different part inferences. Until
     * this is improved, this should only be comparable to confidence of
     * same part type.
     * @format double
     */
    discovery_confidence?: number;
    /**
     * A evidences that the inferer were able to find that justify the
     * inference outcome.
     */
    discovery_evidences?: string[];
    /**
     * The time when this inference occurred.
     * @format date-time
     */
    discovery_last_inferred_at?: string;
    /** The kind of runnable. */
    kind?: RunnableKind;
};
/** The kind of runnable. */
export declare enum RunnableKind {
    EcrImage = "ecr_image",
    Lambda = "lambda",
    Microservice = "microservice",
    Service = "service"
}
/** runnable-pin-summary */
export type RunnablePinSummary = PartPinBaseSummary;
/** runnable-summary */
export type RunnableSummary = PartBaseSummary;
/** schedule-data-collection-request */
export interface ScheduleDataCollectionRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** schedule-data-collection-response */
export type ScheduleDataCollectionResponse = object;
/** schedule-discovery-request */
export interface ScheduleDiscoveryRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** schedule-discovery-response */
export type ScheduleDiscoveryResponse = object;
/**
 * The status determining mutability. In 'draft' the item can be edited
 * but can't be used, in 'published' it can't be edited, but can be used,
 * and in archived neither is possible.
 */
export declare enum ScheduleFragmentStatus {
    Archived = "archived",
    Draft = "draft",
    Published = "published"
}
/** schedule-fragment-summary */
export type ScheduleFragmentSummary = AtomBaseSummary & {
    /**
     * The date (inclusive) on which the schedule fragment begins.
     * @format date-time
     */
    from?: string;
    /** Human-readable name, describing the purpose of the schedule. */
    name?: string;
    /**
     * The status determining mutability. In 'draft' the item can be edited
     * but can't be used, in 'published' it can't be edited, but can be used,
     * and in archived neither is possible.
     */
    status?: ScheduleFragmentStatus;
    /**
     * The date (exclusive) on which the schedule fragment's validity
     * ends.
     * @format date-time
     */
    to?: string;
};
/**
 * The status determining mutability. In 'draft' the item can be edited
 * but can't be used, in 'published' it can't be edited, but can be used,
 * and in archived neither is possible.
 */
export declare enum ScheduleStatus {
    Archived = "archived",
    Draft = "draft",
    Published = "published"
}
/** schedule-summary */
export type ScheduleSummary = AtomBaseSummary & {
    /** Human-readable name. */
    name?: string;
    /**
     * The status determining mutability. In 'draft' the item can be edited
     * but can't be used, in 'published' it can't be edited, but can be used,
     * and in archived neither is possible.
     */
    status?: ScheduleStatus;
    /**
     * Timezone in which this is defined. Only schedules in the same
     * timezone can be directly combined.
     */
    timezone?: string;
    /**
     * Derived field indicating when a valid schedule will become invalid.
     * If omitted the schedule is already not valid. A schedule is valid
     * if it has a weekly schedule for all named periods for all its
     * schedule fragments, and if it has a schedule fragment for the time
     * period in question.
     * @format date-time
     */
    valid_until?: string;
};
/** schema-bool-field-descriptor */
export type SchemaBoolFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Default value. */
    default_value?: boolean;
};
/** schema-bool-list-field-descriptor */
export type SchemaBoolListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Default value. */
    default_value?: boolean[];
};
/** schema-composite-field-descriptor */
export type SchemaCompositeFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Composite type. Required when field type is composite. */
    composite_type?: string;
};
/** schema-composite-list-field-descriptor */
export type SchemaCompositeListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Composite type. Required when field type is composite. */
    composite_type?: string;
};
/** schema-enum-field-descriptor */
export type SchemaEnumFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Allowed values for the field. */
    allowed_values: string[];
    /** Default value. */
    default_value?: string;
};
/** schema-enum-list-field-descriptor */
export type SchemaEnumListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Allowed values for the field. */
    allowed_values: string[];
    /** Default value. */
    default_value?: string[];
};
/**
 * schema-field-descriptor
 * Set of field attributes.
 */
export type SchemaFieldDescriptor = (SchemaBoolFieldDescriptor | SchemaCompositeFieldDescriptor | SchemaEnumFieldDescriptor | SchemaFieldDescriptorArrayType | SchemaIdFieldDescriptor | SchemaIntFieldDescriptor | SchemaRichTextFieldDescriptor | SchemaTextFieldDescriptor | SchemaTimestampFieldDescriptor | SchemaTokensFieldDescriptor) & {
    field_type: SchemaFieldDescriptorFieldType;
};
/** schema-field-descriptor-array-type */
export type SchemaFieldDescriptorArrayType = (SchemaBoolListFieldDescriptor | SchemaCompositeListFieldDescriptor | SchemaEnumListFieldDescriptor | SchemaIdListFieldDescriptor | SchemaIntListFieldDescriptor | SchemaRichTextListFieldDescriptor | SchemaTextListFieldDescriptor | SchemaTimestampListFieldDescriptor | SchemaTokensListFieldDescriptor) & {
    base_type: SchemaFieldDescriptorArrayTypeBaseType;
    /**
     * The maximum array length.
     * @format int64
     */
    max_items?: number;
    /**
     * The minimum array length.
     * @format int64
     */
    min_items?: number;
};
export declare enum SchemaFieldDescriptorArrayTypeBaseType {
    Bool = "bool",
    Composite = "composite",
    Enum = "enum",
    Id = "id",
    Int = "int",
    RichText = "rich_text",
    Text = "text",
    Timestamp = "timestamp",
    Tokens = "tokens"
}
/** schema-field-descriptor-base */
export interface SchemaFieldDescriptorBase {
    /** Description of the field. */
    description?: string;
    /** Whether this field is filterable, groupable and sortable. */
    is_filterable?: boolean;
    /**
     * Whether this field can hold Personally Identifiable Information
     * (PII).
     */
    is_personally_identifiable_information?: boolean;
    /** Whether this field is required or not. */
    is_required?: boolean;
    /** Whether this field is a system field or not. */
    is_system?: boolean;
    /** Name of the field. */
    name: string;
    /** The schema of ui specific fields. */
    ui?: SchemaFieldUiMetadata;
}
export declare enum SchemaFieldDescriptorFieldType {
    Array = "array",
    Bool = "bool",
    Composite = "composite",
    Enum = "enum",
    Id = "id",
    Int = "int",
    RichText = "rich_text",
    Text = "text",
    Timestamp = "timestamp",
    Tokens = "tokens"
}
/**
 * schema-field-ui-metadata
 * The schema of ui specific fields.
 */
export interface SchemaFieldUiMetadata {
    /** Allowed values of the field. */
    allowed_values?: string[];
    /** Fields on which this field depends on. */
    dependent_fields?: string[];
    /** enum groups. */
    devrev_enum_groups?: FieldDevrevEnumGroup[];
    /** display name of the field. */
    display_name?: string;
    /** Whether field is active in detail view. */
    is_active_in_detail_view?: boolean;
    /** Whether stock field is rendered at top. */
    is_base_field?: boolean;
    /** Whether field supports bulk action. */
    is_bulk_action_enabled?: boolean;
    /** Indicates if the field holds a currency value in USD. */
    is_currency_field?: boolean;
    /** Whether field is groupable. */
    is_groupable?: boolean;
    /** Whether field is hidden in UI. */
    is_hidden?: boolean;
    /** Whether field is hidden in UI during creation. */
    is_hidden_during_create?: boolean;
    /** Whether field is read-only in UI. */
    is_read_only?: boolean;
    /** Whether field is shown in summary. */
    is_shown_in_summary?: boolean;
    /** Whether field is sortable. */
    is_sortable?: boolean;
    /**
     * Order in which field is shown.
     * @format int32
     */
    order?: number;
    /** Placeholder for the field. */
    placeholder?: string;
    /** Tooltip for field. */
    tooltip?: string;
    /** Unit of measurment. */
    unit?: string;
}
/** schema-id-field-descriptor */
export type SchemaIdFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Default value. */
    default_value?: string;
    /** Default value. */
    default_value_v1?: string;
    /** Object ID types. Required when field type is ID. */
    id_type?: string[];
};
/** schema-id-list-field-descriptor */
export type SchemaIdListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Default value. */
    default_value?: string[];
    /** Default value. */
    default_value_v1?: string;
    /** Object ID types. Required when field type is ID. */
    id_type?: string[];
};
/** schema-int-field-descriptor */
export type SchemaIntFieldDescriptor = SchemaFieldDescriptorBase & {
    /**
     * Default value.
     * @format int64
     */
    default_value?: number;
    /**
     * The minimum value for the integer (exclusive).
     * @format int64
     */
    gt?: number;
    /**
     * The minimum value for the integer (inclusive).
     * @format int64
     */
    gte?: number;
    /**
     * The maximum value for the integer (exclusive).
     * @format int64
     */
    lt?: number;
    /**
     * The maximum value for the integer (inclusive).
     * @format int64
     */
    lte?: number;
};
/** schema-int-list-field-descriptor */
export type SchemaIntListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Default value. */
    default_value?: number[];
    /**
     * The minimum value for the integer (exclusive).
     * @format int64
     */
    gt?: number;
    /**
     * The minimum value for the integer (inclusive).
     * @format int64
     */
    gte?: number;
    /**
     * The maximum value for the integer (exclusive).
     * @format int64
     */
    lt?: number;
    /**
     * The maximum value for the integer (inclusive).
     * @format int64
     */
    lte?: number;
};
/** schema-rich-text-field-descriptor */
export type SchemaRichTextFieldDescriptor = SchemaFieldDescriptorBase & {
    /** The contained substring. */
    contains?: string;
    /** Default value. */
    default_value?: string;
    /**
     * The exact string length.
     * @format int64
     */
    eq_len?: number;
    /**
     * The maximum string length.
     * @format int64
     */
    max_len?: number;
    /**
     * The minimum string length.
     * @format int64
     */
    min_len?: number;
    /** The string pattern (regular expression). */
    pattern?: string;
    /** The string prefix. */
    prefix?: string;
    /** The string suffix. */
    suffix?: string;
};
/** schema-rich-text-list-field-descriptor */
export type SchemaRichTextListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** The contained substring. */
    contains?: string;
    /** Default value. */
    default_value?: string[];
    /**
     * The exact string length.
     * @format int64
     */
    eq_len?: number;
    /**
     * The maximum string length.
     * @format int64
     */
    max_len?: number;
    /**
     * The minimum string length.
     * @format int64
     */
    min_len?: number;
    /** The string pattern (regular expression). */
    pattern?: string;
    /** The string prefix. */
    prefix?: string;
    /** The string suffix. */
    suffix?: string;
};
/** schema-text-field-descriptor */
export type SchemaTextFieldDescriptor = SchemaFieldDescriptorBase & {
    /** The contained substring. */
    contains?: string;
    /** Default value. */
    default_value?: string;
    /**
     * The exact string length.
     * @format int64
     */
    eq_len?: number;
    /**
     * The maximum string length.
     * @format int64
     */
    max_len?: number;
    /**
     * The minimum string length.
     * @format int64
     */
    min_len?: number;
    /** The string pattern (regular expression). */
    pattern?: string;
    /** The string prefix. */
    prefix?: string;
    /** The string suffix. */
    suffix?: string;
};
/** schema-text-list-field-descriptor */
export type SchemaTextListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** The contained substring. */
    contains?: string;
    /** Default value. */
    default_value?: string[];
    /**
     * The exact string length.
     * @format int64
     */
    eq_len?: number;
    /**
     * The maximum string length.
     * @format int64
     */
    max_len?: number;
    /**
     * The minimum string length.
     * @format int64
     */
    min_len?: number;
    /** The string pattern (regular expression). */
    pattern?: string;
    /** The string prefix. */
    prefix?: string;
    /** The string suffix. */
    suffix?: string;
};
/** schema-timestamp-field-descriptor */
export type SchemaTimestampFieldDescriptor = SchemaFieldDescriptorBase & {
    /**
     * Default value.
     * @format date-time
     */
    default_value?: string;
};
/** schema-timestamp-list-field-descriptor */
export type SchemaTimestampListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** Default value. */
    default_value?: string[];
};
/** schema-tokens-field-descriptor */
export type SchemaTokensFieldDescriptor = SchemaFieldDescriptorBase & {
    /** The contained substring. */
    contains?: string;
    /** Default value. */
    default_value?: string;
    /**
     * The exact string length.
     * @format int64
     */
    eq_len?: number;
    /**
     * The maximum string length.
     * @format int64
     */
    max_len?: number;
    /**
     * The minimum string length.
     * @format int64
     */
    min_len?: number;
    /** The string pattern (regular expression). */
    pattern?: string;
    /** The string prefix. */
    prefix?: string;
    /** The string suffix. */
    suffix?: string;
};
/** schema-tokens-list-field-descriptor */
export type SchemaTokensListFieldDescriptor = SchemaFieldDescriptorBase & {
    /** The contained substring. */
    contains?: string;
    /** Default value. */
    default_value?: string[];
    /**
     * The exact string length.
     * @format int64
     */
    eq_len?: number;
    /**
     * The maximum string length.
     * @format int64
     */
    max_len?: number;
    /**
     * The minimum string length.
     * @format int64
     */
    min_len?: number;
    /** The string pattern (regular expression). */
    pattern?: string;
    /** The string prefix. */
    prefix?: string;
    /** The string suffix. */
    suffix?: string;
};
/**
 * search-core-request
 * Search request.
 */
export interface SearchCoreRequest {
    /**
     * The cursor from where to begin iteration. Start from beginning if
     * not provided.
     */
    cursor?: string;
    /** The namespaces to search in. */
    namespaces?: string[];
    /** The query string. */
    query: string;
    /** Search sort by parameters. */
    sort_by?: SearchSortByParam;
    /** Search sort order parameters. */
    sort_order?: SearchSortOrderParam;
}
/**
 * search-core-response
 * Search response.
 */
export interface SearchCoreResponse {
    /**
     * The cursor from where to begin iteration. Start from beginning if
     * not provided.
     */
    cursor?: string;
    /** The search results. */
    results: SearchResult[];
}
/** The namespaces to search in. */
export declare enum SearchNamespace {
    Account = "account",
    DevUser = "dev_user",
    Issue = "issue",
    RevOrg = "rev_org",
    RevUser = "rev_user",
    Tag = "tag",
    Ticket = "ticket",
    Unknown = "unknown"
}
/** search-result */
export type SearchResult = (AccountSearchSummary | ArtifactSearchSummary | ConversationSearchSummary | LinkSearchSummary | OrgSearchSummary | PartSearchSummary | TagSearchSummary | UserSearchSummary | WorkSearchSummary) & {
    type: SearchResultType;
};
export declare enum SearchResultType {
    Account = "account",
    Artifact = "artifact",
    Conversation = "conversation",
    Link = "link",
    Org = "org",
    Part = "part",
    Tag = "tag",
    User = "user",
    Work = "work"
}
/** Search sort by parameters. */
export declare enum SearchSortByParam {
    CreatedDate = "created_date",
    ModifiedDate = "modified_date",
    Relevance = "relevance"
}
/** Search sort order parameters. */
export declare enum SearchSortOrderParam {
    Asc = "asc",
    Desc = "desc"
}
/** search-summary-base */
export interface SearchSummaryBase {
    /**
     * Final search score for the object.
     * @format float
     */
    final_score: number;
    /**
     * Timestamp when the object was last modified.
     * @format date-time
     */
    modified_date: string;
    /**
     * Semantic search score for the object.
     * @format float
     */
    semantic_score: number;
    /**
     * Syntactic search score for the object.
     * @format float
     */
    syntactic_score: number;
}
/**
 * search-typeahead-request
 * Typeahead search request.
 */
export interface SearchTypeaheadRequest {
    /**
     * The cursor from where to begin iteration. Start from beginning if
     * not provided.
     */
    cursor?: string;
    /** The fields to search on. */
    fields: string[];
    /** The namespaces to search in. */
    namespaces: SearchNamespace[];
    /** The query string. */
    query: string;
    /** Search sort by parameters. */
    sort_by?: SearchSortByParam;
    /** Search sort order parameters. */
    sort_order?: SearchSortOrderParam;
}
/**
 * search-typeahead-response
 * Typeahead search response.
 */
export interface SearchTypeaheadResponse {
    /**
     * The cursor from where to begin iteration. Start from beginning if
     * not provided.
     */
    cursor?: string;
    /** The search results. */
    results: SearchResult[];
}
/**
 * semantic-version
 * Semversion of the package.
 */
export interface SemanticVersion {
    /**
     * Major version.
     * @format int32
     */
    major?: number;
    /**
     * Minor version.
     * @format int32
     */
    minor?: number;
    /**
     * Patch version.
     * @format int32
     */
    patch?: number;
    /** Pre-release version. */
    pre_release?: string;
}
/** send-notification */
export type SendNotification = SendNotificationDevRevReminder & {
    /** Origin of the notification. */
    origin?: string;
    /** The ID of the parent object associated with the notification. */
    parent: string;
    /** Priority of the notification. */
    priority?: NotificationPriority;
    /**
     * The ID of the user for whom the notification was generated.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    receiver: string;
    /** The ID of the user who generated the notification. */
    sender: string;
    /**
     * Timestamp of the event that triggered the notification.
     * @format date-time
     */
    timestamp?: string;
    type: SendNotificationType;
};
/** send-notification-dev-rev-reminder */
export interface SendNotificationDevRevReminder {
    /**
     * Timestamp at which the reminder was created.
     * @format date-time
     */
    created_at?: string;
    /** The message included with the reminder. */
    message?: string;
}
export declare enum SendNotificationType {
    DevrevReminder = "devrev_reminder"
}
/** service-account */
export type ServiceAccount = UserBase & {
    /** A reference to the keyrings associated with a service account. */
    keyrings?: ServiceAccountKeyring[];
};
/**
 * service-account-keyring
 * A reference to a keyring under a service account.
 */
export interface ServiceAccountKeyring {
    /** The display name of the keyring. */
    display_name?: string;
    /** A reference to a shared secret associated with a service account. */
    key?: string;
    /** A generated unique identifier under a given service account. */
    key_id?: string;
}
/** service-account-summary */
export type ServiceAccountSummary = UserBaseSummary;
/**
 * service-accounts-create-request
 * The request object to create a new service account.
 */
export interface ServiceAccountsCreateRequest {
    /**
     * The service account's display name. A unique, human readable name
     * to identify a service account.
     */
    display_name: string;
    /**
     * Indicates whether to generate a keyring along with the new service
     * account. The default is false.
     */
    gen_keyring?: boolean;
}
/**
 * service-accounts-create-response
 * The response object to create a new service account.
 */
export interface ServiceAccountsCreateResponse {
    service_account: ServiceAccount;
}
/**
 * service-accounts-delete-request
 * A request object to delete a service account.
 */
export interface ServiceAccountsDeleteRequest {
    /** The ID of the service account to be deleted. */
    id: string;
}
/**
 * service-accounts-delete-response
 * The response object to delete a service account.
 */
export type ServiceAccountsDeleteResponse = object;
/**
 * service-accounts-get-request
 * The request object to get a service account's information.
 */
export interface ServiceAccountsGetRequest {
    /** The ID of the requested service account. */
    id: string;
}
/**
 * service-accounts-get-response
 * The response object that carries the service account's information
 * corresponding to the request.
 */
export interface ServiceAccountsGetResponse {
    service_account: ServiceAccount;
}
/**
 * service-accounts-keyrings-create-request
 * A request object to create a new keyring under a service account.
 */
export interface ServiceAccountsKeyringsCreateRequest {
    /**
     * The keyrings's display name. A human readable name to identify a
     * keyring.
     */
    display_name: string;
    /** The service account ID under which the new keyring to be created. */
    service_account_id: string;
}
/**
 * service-accounts-keyrings-create-response
 * The response object to get a keyring under a service account.
 */
export interface ServiceAccountsKeyringsCreateResponse {
    /** A reference to a keyring under a service account. */
    keyring: ServiceAccountKeyring;
    /** The ID of the requested service account. */
    service_account_id: string;
    /** The ID of the requested service account. */
    service_account_id_v1?: string;
}
/**
 * service-accounts-keyrings-delete-request
 * A request object to delete a keyring under a service account.
 */
export interface ServiceAccountsKeyringsDeleteRequest {
    /** The ID of the keyring. */
    key_id: string;
    /** The ID of the requested service account. */
    service_account_id: string;
}
/**
 * service-accounts-keyrings-delete-response
 * The response to delete a keyring under a service account.
 */
export type ServiceAccountsKeyringsDeleteResponse = object;
/**
 * service-accounts-keyrings-get-request
 * A request object to get a keyring corresponding to a service account.
 */
export interface ServiceAccountsKeyringsGetRequest {
    /** The ID of the keyring. */
    key_id: string;
    /** The ID corresponding to the requested keyring. */
    service_account_id: string;
}
/**
 * service-accounts-keyrings-get-response
 * The response object to get the keyring associated with a service
 * account.
 */
export interface ServiceAccountsKeyringsGetResponse {
    /** A reference to a keyring under a service account. */
    keyring: ServiceAccountKeyring;
    /** The ID of the requested service account. */
    service_account_id: string;
    /** The ID of the requested service account. */
    service_account_id_v1?: string;
}
/**
 * service-accounts-keyrings-update-request
 * A request object to update a new keyring under a service account.
 */
export interface ServiceAccountsKeyringsUpdateRequest {
    /**
     * The keyrings's display name to be updated. A human readable name to
     * identify a keyring.
     */
    display_name?: string;
    /** The ID of the keyring. */
    key_id: string;
    /** The ID of the requested service account. */
    service_account_id: string;
}
/**
 * service-accounts-keyrings-update-response
 * The response object to get the keyring under a service account.
 */
export interface ServiceAccountsKeyringsUpdateResponse {
    /** A reference to a keyring under a service account. */
    keyring: ServiceAccountKeyring;
    /** The ID corresponding to the keyring. */
    service_account_id: string;
    /** The ID corresponding to the keyring. */
    service_account_id_v1?: string;
}
/**
 * service-accounts-list-request
 * A request object to get the list of service accounts.
 */
export type ServiceAccountsListRequest = object;
/**
 * service-accounts-list-response
 * The response object to list the service accounts.
 */
export interface ServiceAccountsListResponse {
    /** The list of service accounts. */
    service_accounts: ServiceAccount[];
}
/**
 * service-accounts-update-request
 * The request object to update a service account.
 */
export interface ServiceAccountsUpdateRequest {
    /**
     * The service account's display name to be updated. A unique, human
     * readable name to identify a service account.
     */
    display_name?: string;
    /** The ID of the requested service account. */
    id: string;
}
/**
 * service-accounts-update-response
 * The response object that carries the updated service account's
 * information.
 */
export interface ServiceAccountsUpdateResponse {
    service_account: ServiceAccount;
}
/** service-plan */
export type ServicePlan = AtomBase & {
    /** The billing frequency of the service plan. */
    billing_cycle: ServicePlanBillingCycle;
    /**
     * The billing date set for the service plan.
     * @format date-time
     */
    billing_date?: string;
    /**
     * Settings related to payment, proration, etc. Configurations may or may
     * not be defined by a DevO. 1. If DevO defines configurations then same
     * configurations are copied to RevO also to sub pack (for now, later RevO
     * can also set) 2. If DevO doesn't set anything then these configurations
     * would be set to default by application for which they were being
     * defined (for eg. if DevO doesn't set payment method for it's RevOs then
     * stripe would set it to 'charge_automatically' by default).
     */
    configurations?: Configuration;
    /** The currency on which the service plan is created. */
    currency: string;
    /** Description for the Service Plan. */
    description?: string;
    /** The latest invoice generated for this service plan. */
    latest_invoice?: string;
    /** Human readable name for the service plan. */
    name: string;
    /** The one time invoice items attached to the service plan. */
    one_time_line_items?: OneTimeLineItemSummary[];
    /** The recurring items inside the service plan. */
    recurring_line_items?: RecurringLineItemSummary[];
    rev: OrgSummary;
    /** The service plan state. ex. active, due etc. */
    state?: string;
    /** The status of the service plan. */
    status?: string;
    /**
     * This stores the intent in case of update request doesn't goes through
     * completely. For example, if a update request is made when
     * payment_behavior is  'pending_update' (this means only apply updates
     * when payment is successful), so till the payment is done and succeeded,
     * locally the service plan's update request's patch related to items is
     * stored in this field.
     */
    update_intent?: ServicePlanUpdateIntent;
};
/** The billing frequency of the service plan. */
export declare enum ServicePlanBillingCycle {
    Monthly = "monthly",
    OneTime = "one_time",
    Yearly = "yearly"
}
/** service-plan-summary */
export type ServicePlanSummary = AtomBaseSummary;
/**
 * service-plan-update-intent
 * This stores the intent in case of update request doesn't goes through
 * completely. For example, if a update request is made when
 * payment_behavior is  'pending_update' (this means only apply updates
 * when payment is successful), so till the payment is done and succeeded,
 * locally the service plan's update request's patch related to items is
 * stored in this field.
 */
export interface ServicePlanUpdateIntent {
    /** Flag which decides if trial ends immediately. */
    trial_end_now?: boolean;
    /**
     * The trial period end time.
     * @format date-time
     */
    trial_period_end_time?: string;
}
/** service-plans-cancel-request */
export interface ServicePlansCancelRequest {
    /** The service plan's DON. */
    id: string;
}
/** service-plans-create-request */
export interface ServicePlansCreateRequest {
    /** The billing frequency of the service plan. */
    billing_cycle: ServicePlanBillingCycle;
    /**
     * The billing date set for the service plan.
     * @format date-time
     */
    billing_date?: string;
    /**
     * Settings related to payment, proration, etc. Configurations may or may
     * not be defined by a DevO. 1. If DevO defines configurations then same
     * configurations are copied to RevO also to sub pack (for now, later RevO
     * can also set) 2. If DevO doesn't set anything then these configurations
     * would be set to default by application for which they were being
     * defined (for eg. if DevO doesn't set payment method for it's RevOs then
     * stripe would set it to 'charge_automatically' by default).
     */
    configurations?: Configuration;
    /** The currency on which the service plan is created. */
    currency: string;
    /** Description of the service plan. */
    description?: string;
    /** Human readable name of the service plan. */
    name: string;
    /** The one time line items to be added in the service plan. */
    one_time_line_items?: CreateOneTimeLineItems[];
    /** The recurring line items to be added in the service plan. */
    recurring_line_items: CreateRecurringLineItems[];
    /**
     * The rev org for which the current service plan is created for. Rev
     * Org is needed when service plan is being created by dev for a
     * specific rev.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
}
/** service-plans-create-response */
export interface ServicePlansCreateResponse {
    service_plan: ServicePlan;
}
/** service-plans-get-compatible-skus-request */
export interface ServicePlansGetCompatibleSkusRequest {
    /** The service plan's DON. */
    id?: string;
    /**
     * The product ID for which to get the compatible SKUs.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    product_id?: string;
}
/** service-plans-get-compatible-skus-response */
export interface ServicePlansGetCompatibleSkusResponse {
    /** Product to compatible SKU mapping. */
    product_sku_mapping?: ServicePlansGetCompatibleSkusResponseProductSkuMapping[];
}
/** service-plans-get-compatible-skus-response-product-sku-mapping */
export interface ServicePlansGetCompatibleSkusResponseProductSkuMapping {
    /**
     * The product ID for the compatible skus.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    product_id: string;
    /** The product ID for the compatible skus. */
    product_id_v1?: string;
    /** The SKU and Pricing details. */
    sku_details: ServicePlansGetCompatibleSkusResponseProductSkuMappingSkuDetails[];
}
/** service-plans-get-compatible-skus-response-product-sku-mapping-sku-details */
export interface ServicePlansGetCompatibleSkusResponseProductSkuMappingSkuDetails {
    pricing: Pricing;
    /**
     * Maximum quantity that can be purchased in case of a subscription
     * SKU.
     * @format int64
     */
    quantity?: number;
    sku: Sku;
}
/** service-plans-get-request */
export interface ServicePlansGetRequest {
    /** The service plan's DON. */
    id: string;
}
/** service-plans-get-response */
export interface ServicePlansGetResponse {
    service_plan: ServicePlan;
}
/** service-plans-list-request */
export interface ServicePlansListRequest {
    /** The list of service plan DONs which are to be aggregated. */
    ids?: string[];
    /**
     * The list of rev org DONs which are to be aggregated.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org_ids?: string[];
    /**
     * List of fields to sort the service plan object, by and how to sort
     * them. Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /** The list of states which are to be aggregated. */
    states?: string[];
}
/** service-plans-list-response */
export interface ServicePlansListResponse {
    /** The list of service plan objects. */
    service_plans: ServicePlan[];
}
/** service-plans-pending-update-cancel-request */
export interface ServicePlansPendingUpdateCancelRequest {
    /** The service plan's DON. */
    id: string;
}
/** service-plans-pending-update-cancel-response */
export interface ServicePlansPendingUpdateCancelResponse {
    service_plan: ServicePlan;
}
/** service-plans-update-request */
export interface ServicePlansUpdateRequest {
    /** The service plan's DON. */
    id: string;
    one_time_line_items?: ServicePlansUpdateRequestOneTimeLineItems;
    recurring_line_items?: ServicePlansUpdateRequestRecurringLineItems;
}
/** service-plans-update-request-one-time-line-items */
export interface ServicePlansUpdateRequestOneTimeLineItems {
    /** The one time line items to be added in the service plan. */
    add?: CreateOneTimeLineItems[];
}
/** service-plans-update-request-recurring-line-items */
export interface ServicePlansUpdateRequestRecurringLineItems {
    /** The recurring line items to be added in the service plan. */
    add?: CreateRecurringLineItems[];
    /** The recurring line items to be deleted from the service plan. */
    remove?: DeleteRecurringLineItems[];
    /** The recurring line items to be updated in the service plan. */
    set?: UpdateRecurringLineItems[];
}
/** service-plans-update-response */
export interface ServicePlansUpdateResponse {
    service_plan: ServicePlan;
}
/** set-tag-with-value */
export interface SetTagWithValue {
    /**
     * The ID of the tag.
     * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
     */
    id: string;
    /**
     * The value for the object's association with the tag. If specified,
     * the value must be one that's specified in the tag's allowed values.
     */
    value?: string;
}
/** settings-summary */
export type SettingsSummary = AtomBaseSummary;
/** Type of the created resource. */
export declare enum SetupResourceResourceType {
    Tag = "tag",
    User = "user"
}
/** sku */
export type Sku = AtomBase & {
    /** Description of the SKU. */
    description?: string;
    /** This contains the list of entitlements for the SKU. */
    entitlements: Entitlement[];
    /** Human readable name of the SKU. For example; Basic, Premium, etc. */
    family_name: string;
    /**
     * Invoice Description is meant to be displayable on the invoice
     * against the usage for the SKU.
     */
    invoice_description?: string;
    /**
     * If flag is enabled then the usage will be prorated for the time the
     * SKU is active.
     */
    is_duration_based_proration_enabled?: boolean;
    /**
     * maximum quantity a rev can subscribe to when subscribing to this
     * SKU.
     * @format int32
     */
    maximum_quantity?: number;
    /**
     * Minimum duration in minutes for the SKU usage after which the SKU
     * would be charged.
     * @format int32
     */
    minimum_duration_to_charge?: number;
    /**
     * minimum quantity a rev need to subscribe when subscribing to this
     * SKU.
     * @format int32
     */
    minimum_quantity?: number;
    /** Pricing details of the SKU. */
    pricing: PricingSummary[];
    product: PartSummary;
    rev?: OrgSummary;
    /** It defines the type of SKU. */
    sku_type: SkuType;
    /**
     * Every SKU for a given family name can have multiple SKU versions.
     * For example; when a new SKU named 'Basic' is created and publish it
     * to production, it starts with version 0. Once the SKU goes to
     * production, one can decide to do some major updates like update
     * entitlements or change the price, in that case the version 0 SKU
     * will be moved to 'end of sale' and a new 'Basic' SKU with the same
     * family name is created with version 1. Once any SKU is in 'end of
     * sale', it is not available for new sale. Customers who wants to buy
     * this SKU will always get latest version of that family name. For a
     * given family name there can be only one SKU which is in production.
     * @format int32
     */
    sku_version: number;
    /**
     * Current state of the SKU. A SKU is visible to RevOs only when it is
     * released.
     */
    state: SkuState;
    /** The update status of the SKU. */
    status: SkuStatus;
    versioned_from_sku?: SkuSummary;
};
/** sku-rules */
export type SkuRules = AtomBase & {
    /**
     * The list of allowed SKU family names which can be bought together
     * by a RevO.
     */
    allowed_sku_names: string[];
    /** Description of the SKU rules. */
    description?: string;
    product: PartSummary;
};
/** sku-rules-create-request */
export interface SkuRulesCreateRequest {
    /**
     * The list of allowed sku names which can be bought together by a rev
     * org.
     */
    allowed_sku_names: string[];
    /** Description of the sku rule. */
    description?: string;
    /** Human readable name of the sku rule. */
    name: string;
    /**
     * The product DON for which the sku rule is defined.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    product_id: string;
}
/** sku-rules-create-response */
export interface SkuRulesCreateResponse {
    sku_rule: SkuRules;
}
/** sku-rules-delete-request */
export interface SkuRulesDeleteRequest {
    /** The sku rule's DON. */
    id: string;
}
/** sku-rules-get-request */
export interface SkuRulesGetRequest {
    /** The sku rule's DON */
    id: string;
}
/** sku-rules-get-response */
export interface SkuRulesGetResponse {
    sku_rule: SkuRules;
}
/** sku-rules-list-request */
export interface SkuRulesListRequest {
    /** The list of allowed sku names which are to be aggregated. */
    allowed_sku_names?: string[];
    /** The list of sku rule DONs which are to be aggregated. */
    ids?: string[];
    /**
     * The list of product DONs which are to be aggregated.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    product_ids?: string[];
    /**
     * List of fields to sort the sku rules, by and how to sort them.
     * Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
}
/** sku-rules-list-response */
export interface SkuRulesListResponse {
    /** The list of sku rules. */
    sku_rules: SkuRules[];
}
/** sku-rules-summary */
export type SkuRulesSummary = AtomBaseSummary;
/** sku-rules-update-request */
export interface SkuRulesUpdateRequest {
    /**
     * The sku names which are to be added to this subscription rule
     * configuration.
     */
    add_allowed_sku_names?: string[];
    /** Description of the sku rule. */
    description?: string;
    /** The sku rule's DON. */
    id: string;
    /**
     * The sku names which are to be removed from this subscription rule
     * configuration.
     */
    remove_allowed_sku_names?: string[];
}
/** sku-rules-update-response */
export interface SkuRulesUpdateResponse {
    sku_rule: SkuRules;
}
/**
 * Current state of the SKU. A SKU is visible to RevOs only when it is
 * released.
 */
export declare enum SkuState {
    Approved = "approved",
    Draft = "draft",
    EndOfLife = "end_of_life",
    EndOfSale = "end_of_sale",
    Released = "released"
}
/** The update status of the SKU. */
export declare enum SkuStatus {
    CreateInProgress = "create_in_progress",
    DeleteInProgress = "delete_in_progress",
    Normal = "normal",
    UpdateInProgress = "update_in_progress"
}
/** sku-summary */
export type SkuSummary = AtomBaseSummary & {
    /** Human readable name of the SKU. For example; Basic, Premium, etc. */
    family_name: string;
    /**
     * Invoice Description is meant to be displayable on the invoice
     * against the usage for the SKU.
     */
    invoice_description?: string;
    /**
     * If flag is enabled then the usage will be prorated for the time the
     * SKU is active.
     */
    is_duration_based_proration_enabled?: boolean;
    /**
     * Minimum duration in minutes for the SKU usage after which the SKU
     * would be charged.
     * @format int32
     */
    minimum_duration_to_charge?: number;
    /** It defines the type of SKU. */
    sku_type: SkuType;
    /**
     * Current state of the SKU. A SKU is visible to RevOs only when it is
     * released.
     */
    state: SkuState;
};
/** It defines the type of SKU. */
export declare enum SkuType {
    Consumption = "consumption",
    ConsumptionAddon = "consumption_addon",
    OneOffAddon = "one_off_addon",
    OneOffCharge = "one_off_charge",
    Subscription = "subscription",
    SubscriptionAddon = "subscription_addon"
}
/** skus-create-request */
export interface SkusCreateRequest {
    /** Description of the SKU. */
    description?: string;
    /** Entitlements to be added under the SKU. */
    entitlements?: UpdateEntitlementsAddUpdateEntitlement[];
    /**
     * If specified, it is meant to be displayable on the invoice against
     * the usage for the SKU.
     */
    invoice_description?: string;
    /**
     * Enabling this flag creates custom SKU specifically for a RevOrg.
     * The custom SKU is only visible to Rev Org for whom it is created.
     * Rev Org ID is needed while creating a custom SKU.
     */
    is_custom?: boolean;
    /**
     * If flag is enabled then the usage will be prorated for the time the
     * SKU is active.
     */
    is_duration_based_proration_enabled?: boolean;
    /**
     * Maximum quantity a rev can subscribe to when subscribing to this
     * SKU.
     * @format int32
     */
    maximum_quantity?: number;
    /**
     * Minimum duration in minutes for the SKU usage after which the SKU
     * would be charged.
     * @format int64
     */
    minimum_duration_to_charge?: number;
    /**
     * Minimum quantity a rev needs to subscribe when subscribing to this
     * SKU.
     * @format int32
     */
    minimum_quantity?: number;
    /** Human readable name of the SKU. For example; Basic, Premium, etc. */
    name: string;
    /** Pricing details of the SKU. */
    pricing?: UpdatePricingAddPriceInfo[];
    /**
     * The product for which the SKU is being created for. One product can
     * have multiple SKUs and multiple type of SKUs.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    product_id: string;
    /**
     * The rev org for which the current SKU is created for. Revs would be
     * able to see the default SKUs and the SKUs created exclusively for
     * them.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
    /** It defines the type of SKU. */
    sku_type: SkuType;
    /**
     * Current state of the SKU. A SKU is visible to RevOs only when it is
     * released.
     */
    state?: SkuState;
}
/** skus-create-response */
export interface SkusCreateResponse {
    sku: Sku;
}
/** skus-delete-request */
export interface SkusDeleteRequest {
    /** The SKU object's DON. */
    id: string;
}
/** skus-get-request */
export interface SkusGetRequest {
    /** The SKU object's DON. */
    id: string;
}
/** skus-get-response */
export interface SkusGetResponse {
    sku: Sku;
}
/** skus-list-request */
export interface SkusListRequest {
    /** The list of SKU DONs which are to be aggregated. */
    ids?: string[];
    /** The list of SKU names which are to be aggregated. */
    names?: string[];
    /**
     * The list of product DONs which are to be aggregated.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    product_ids?: string[];
    /**
     * The list of rev org DONs which are to be aggregated.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org_ids?: string[];
    /** The list of SKU types which are to be aggregated. */
    sku_types?: SkuType[];
    /** The list of SKU versions which are to be aggregated. */
    sku_versions?: number[];
    /**
     * List of fields to sort the SKU object, by and how to sort them.
     * Default is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /** The list of SKU states which are to be aggregated. */
    states?: SkuState[];
}
/** skus-list-response */
export interface SkusListResponse {
    /** The list of SKU objects. */
    skus: Sku[];
}
/** skus-update-request */
export interface SkusUpdateRequest {
    /** Description of the SKU. */
    description?: string;
    entitlements?: UpdateEntitlements;
    /** The SKU object's DON. */
    id: string;
    /**
     * If specified, it is meant to be displayable on the invoice against
     * the usage for the SKU.
     */
    invoice_description?: string;
    /**
     * Enabling this flag updates a SKU to be custom (specifically for a
     * RevOrg).The custom SKU is only visible to Rev Org for whom it is
     * created. Rev Org ID is needed while making a SKU custom.
     */
    is_custom?: boolean;
    /**
     * Maximum quantity a rev can subscribe to when subscribing to this
     * SKU.
     * @format int32
     */
    maximum_quantity?: number;
    /**
     * Minimum quantity a rev needs to subscribe when subscribing to this
     * SKU.
     * @format int32
     */
    minimum_quantity?: number;
    /** Human readable name of the SKU. For example; Basic, Premium, etc. */
    name?: string;
    pricing?: UpdatePricing;
    /**
     * The rev for which the current SKU is created for. Rev would be able
     * to see the default SKUs and the SKUs created exclusively for them.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
    /**
     * Current state of the SKU. A SKU is visible to RevOs only when it is
     * released.
     */
    state?: SkuState;
}
/** skus-update-response */
export interface SkusUpdateResponse {
    sku: Sku;
}
/** skus-version-request */
export interface SkusVersionRequest {
    /** Description of the SKU. */
    description?: string;
    entitlements?: UpdateEntitlements;
    /**
     * The SKU ID from which the current SKU would be versioned from. In
     * case of some major updates are needed like price change or
     * remove/update entitlements of the current SKU, one can do end of
     * sale of the current version of SKU and create a newer version.
     */
    id: string;
    pricing?: UpdatePricing;
    /**
     * Current state of the SKU. A SKU is visible to RevOs only when it is
     * released.
     */
    state?: SkuState;
}
/** skus-version-response */
export interface SkusVersionResponse {
    sku: Sku;
}
/** sla */
export type Sla = AtomBase & {
    /**
     * Describes the compensation to be provided in case of SLA breach. It is
     * not 'self-executing', it is the responsibility of the dev_org to
     * actually provide the promised credit, resource or other payment.
     */
    compensation?: Compensation;
    /** Description of the purpose and capabilities of the SLA. */
    description?: string;
    /**
     * Specifies the frequency of when the contractually-meaningful evaluation
     * of the SLA happens. The dev_org for their own information might
     * evaluate the various metrics contained in the policy as often as we can
     * make it feasible for them, but only the evaluation at the end of the
     * evaluation period triggers a compensation and needs to be shared with
     * the rev.
     */
    evaluation_period?: SlaEvaluationPeriod;
    /** Human-readable name. */
    name?: string;
    /**
     * The policies encompassed by this SLA, ordered in decreasing
     * priority.
     */
    policies?: SlaPolicy[];
    /**
     * The status determining mutability. In 'draft' the item can be edited
     * but can't be used, in 'published' it can't be edited, but can be used,
     * and in archived neither is possible.
     */
    status?: SlaStatus;
};
/**
 * Specifies the frequency of when the contractually-meaningful evaluation
 * of the SLA happens. The dev_org for their own information might
 * evaluate the various metrics contained in the policy as often as we can
 * make it feasible for them, but only the evaluation at the end of the
 * evaluation period triggers a compensation and needs to be shared with
 * the rev.
 */
export declare enum SlaEvaluationPeriod {
    Monthly = "monthly",
    Quarterly = "quarterly",
    Weekly = "weekly",
    Yearly = "yearly"
}
/**
 * sla-metric-summary
 * The summary of a metric being tracked in an SLA.
 */
export interface SlaMetricSummary {
    /** The name of the metric. */
    name?: string;
    /**
     * The remaining time(in minutes) for paused, out of schedule metrics.
     * @format int32
     */
    remaining_time?: number;
    /** The stage of the metric. */
    stage?: SlaMetricSummaryStage;
    /**
     * The target time of the metric to avoid SLA breach.
     * @format date-time
     */
    target_time?: string;
}
/** The stage of the metric. */
export declare enum SlaMetricSummaryStage {
    Breached = "breached",
    Completed = "completed",
    OutOfSchedule = "out_of_schedule",
    Paused = "paused",
    Running = "running",
    Warning = "warning"
}
/**
 * sla-policy
 * A policy that represents a promise to your revs.
 */
export interface SlaPolicy {
    /** Metrics to apply to the selected items. */
    metrics: SupportMetricTarget[];
    /** Human-readable name. */
    name?: string;
    /**
     * The conditions by which a ticket or conversation is selected to be
     * under the SLA policy. AND is taken between the filters on each field.
     */
    selector?: SlaSelector;
}
/**
 * sla-selector
 * The conditions by which a ticket or conversation is selected to be
 * under the SLA policy. AND is taken between the filters on each field.
 */
export interface SlaSelector {
    /** The item type for which the SLA policy applies. */
    applies_to?: SlaSelectorAppliesTo;
    /** The SLA policy applies to the tickets of these parts. */
    parts?: PartSummary[];
    /** Th SLA policy applies to conversations with these priorities. */
    priority?: SlaSelectorPriority[];
    /**
     * The SLA policy applies to tickets created and conversations started
     * by rev-users of this group.
     */
    rev_user_group?: string[];
    /** The SLA policy applies to tickets with these severities. */
    severity?: SlaSelectorSeverity[];
    /** Th SLA policy applies to conversations with these sources. */
    source_channel?: string[];
    /**
     * Specifies the logical operation to perform between the presence of the
     * specified tags, whether all or any are needed.
     */
    tag_operation?: SlaSelectorTagOperation;
    /**
     * The SLA policy applies to tickets and conversations with these
     * tags. If empty, the tag filter isn't applied.
     */
    tags?: TagSummary[];
}
/** The item type for which the SLA policy applies. */
export declare enum SlaSelectorAppliesTo {
    Conversation = "conversation",
    Ticket = "ticket"
}
/** Th SLA policy applies to conversations with these priorities. */
export declare enum SlaSelectorPriority {
    P0 = "p0",
    P1 = "p1",
    P2 = "p2"
}
/** The SLA policy applies to tickets with these severities. */
export declare enum SlaSelectorSeverity {
    Blocker = "blocker",
    High = "high",
    Low = "low",
    Medium = "medium"
}
/**
 * Specifies the logical operation to perform between the presence of the
 * specified tags, whether all or any are needed.
 */
export declare enum SlaSelectorTagOperation {
    All = "all",
    Any = "any",
    NotAny = "not_any"
}
/**
 * The status determining mutability. In 'draft' the item can be edited
 * but can't be used, in 'published' it can't be edited, but can be used,
 * and in archived neither is possible.
 */
export declare enum SlaStatus {
    Archived = "archived",
    Draft = "draft",
    Published = "published"
}
/** sla-summary */
export type SlaSummary = AtomBaseSummary & {
    /** Human-readable name. */
    name?: string;
    /**
     * The status determining mutability. In 'draft' the item can be edited
     * but can't be used, in 'published' it can't be edited, but can be used,
     * and in archived neither is possible.
     */
    status?: SlaStatus;
};
/** sla-tracker-summary */
export type SlaTrackerSummary = AtomBaseSummary;
/** slas-assign-request */
export interface SlasAssignRequest {
    /** The SLA which would be assigned to the Rev organizations. */
    id: string;
    /**
     * The Rev organizations to apply the SLA to.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_orgs: string[];
}
/** slas-assign-response */
export interface SlasAssignResponse {
    /** The list of outcomes for each Rev organization. */
    results: AssignResult[];
}
/** slas-create-request */
export interface SlasCreateRequest {
    /** Description of the purpose and capabilities of the SLA. */
    description?: string;
    /**
     * Specifies the frequency of when the contractually-meaningful evaluation
     * of the SLA happens. The dev_org for their own information might
     * evaluate the various metrics contained in the policy as often as we can
     * make it feasible for them, but only the evaluation at the end of the
     * evaluation period triggers a compensation and needs to be shared with
     * the rev.
     */
    evaluation_period?: SlaEvaluationPeriod;
    /** Human-readable name. */
    name: string;
    /**
     * The policies encompassed by this SLA, ordered in decreasing
     * priority.
     */
    policies?: CreateSlaPolicy[];
}
/** slas-create-response */
export interface SlasCreateResponse {
    sla: Sla;
}
/** slas-get-request */
export interface SlasGetRequest {
    /** The ID of the SLA to get. */
    id: string;
}
/** slas-get-response */
export interface SlasGetResponse {
    sla: Sla;
}
/** slas-transition-request */
export interface SlasTransitionRequest {
    /** The updated SLA. */
    id: string;
    /**
     * The status determining mutability. In 'draft' the item can be edited
     * but can't be used, in 'published' it can't be edited, but can be used,
     * and in archived neither is possible.
     */
    status: SlaStatus;
}
/** slas-transition-response */
export interface SlasTransitionResponse {
    sla: Sla;
}
/** snap */
export type Snap = (Flow | SnapIn) & {
    type: SnapType;
};
/** snap-in */
export type SnapIn = AtomBase & {
    /** List of automations used in the snap-in. */
    automations?: SnapInNameReferenceMapping[];
    /** List of commands used in the snap-in. */
    commands?: SnapInNameReferenceMapping[];
    /** Definitions for connections used by snap-in. */
    connection_definitions?: SnapInConnection[];
    /** List of connections used in the snap-in. */
    connections?: SnapInNameReferenceMapping[];
    /** Custom fields. */
    custom_fields?: object;
    /** Custom schema fragments. */
    custom_schema_fragments?: string[];
    /** Custom schema fragments. */
    custom_schema_fragments_v1?: string;
    /** Description of the snap-in. */
    description?: string;
    /** List of event sources used in the snap-in. */
    event_sources?: SnapInNameReferenceMapping[];
    /** Values for global inputs part of the snap-in. */
    inputs?: SnapInGlobalInput[];
    /** Name of the snap-in. */
    name?: string;
    /** Per object schema. */
    per_object_schema?: SchemaFieldDescriptor[];
    /**
     * Combination of stock and custom schema fragment IDs.
     * @deprecated
     */
    schema_fragment_ids?: string[];
    /** Combination of stock and custom schema fragment IDs. */
    schema_fragment_ids_v1?: string;
    snap_in_config?: SnapInConfig;
    snap_in_version?: SnapInVersionSummary;
    /** Deployment status of the snap-in. */
    status?: SnapInStatus;
    /** Stock schema fragment. */
    stock_schema_fragment?: string;
    /** Stock schema fragment. */
    stock_schema_fragment_v1?: string;
    /** Subtype corresponding to the custom type fragment. */
    subtype?: string;
    /** List of tags used in the snap-in. */
    tags?: SnapInNameReferenceMapping[];
};
/**
 * snap-in-automation
 * Stores automations.
 */
export interface SnapInAutomation {
    /** Event source name ID to listen to. */
    event_source?: string;
    /** List of events subscribed from the event_source. */
    event_types?: string[];
    /** Function name ID to trigger for this event. */
    function?: string;
    /** Name of the automation. */
    name?: string;
}
/** snap-in-config */
export interface SnapInConfig {
    /** List of connections in the snap_in. */
    connections?: SnapInConnectionConfig[];
    /** List of inputs in the snap_in. */
    global_inputs?: SnapInGlobalInputConfig[];
}
/**
 * snap-in-connection
 * Stores required connections.
 */
export interface SnapInConnection {
    /** Description of what the connection is used for. */
    description?: string;
    /** Display name. */
    display_name?: string;
    /** Keyring types. */
    keyring_types: string[];
    /** Name of connection. */
    name?: string;
}
/** snap-in-connection-config */
export interface SnapInConnectionConfig {
    /** Description of the connection in the snap_in. */
    description?: string;
    /** Display name of the connection in the snap_in. */
    display_name?: string;
    /** Name of the connection in the snap_in. */
    name: string;
    /** List of keyring types this connection can be. */
    types: string[];
}
/**
 * snap-in-event-source
 * Stores event sources.
 */
export interface SnapInEventSource {
    /** Reference used to setup the event source. */
    connection?: string;
    /** Event source description. */
    description?: string;
    /** Shown to the installer. */
    display_name?: string;
    /** Event source name that serves as an id. */
    name?: string;
    /** Event setup instructions. */
    setup_instructions?: string;
    /** The source of the event. */
    source?: string;
    /** Source config. */
    source_config?: object;
}
/**
 * snap-in-function-definition
 * Snap in function definition.
 */
export interface SnapInFunctionDefinition {
    /** Description of the function. */
    description?: string;
    function_id?: SnapInFunctionSummary;
    /** Name of the function. */
    name?: string;
    /** The source type containing the code. */
    source_type?: SnapInFunctionDefinitionSourceType;
}
/** The source type containing the code. */
export declare enum SnapInFunctionDefinitionSourceType {
    Artifact = "artifact"
}
/** snap-in-function-summary */
export type SnapInFunctionSummary = AtomBaseSummary & {
    /** Description of the function. */
    description?: string;
    /** Name of the function. */
    name?: string;
};
/** snap-in-global-input */
export interface SnapInGlobalInput {
    /** Name of the input. */
    name: string;
    /** Input value. */
    value?: string;
}
/** snap-in-global-input-config */
export interface SnapInGlobalInputConfig {
    /** Allowed values for the input. */
    allowed_values?: string[];
    /** Default value for the input. */
    default_value?: string;
    /** Description of the input value. */
    description?: string;
    /** Display name for the input. */
    display_name?: string;
    /** Name of input in the snap_in. */
    name: string;
    /** Type of the input. */
    type: SnapInGlobalInputType;
}
/** Type of the input. */
export declare enum SnapInGlobalInputType {
    Bool = "bool",
    Enum = "enum",
    EnumList = "enum_list",
    Float = "float",
    FloatList = "float_list",
    Integer = "integer",
    IntegerList = "integer_list",
    String = "string",
    StringList = "string_list"
}
/**
 * snap-in-name-reference-mapping
 * Stores mapping from snap-in version defined name to the corresponding
 * ID.
 */
export interface SnapInNameReferenceMapping {
    /** Name by which the object is being referred in the snap-in version. */
    name: string;
    reference?: AtomSummary;
}
/** snap-in-package */
export type SnapInPackage = AtomBase & {
    /** Description of the snap-in package. */
    description?: string;
    /** Name of the snap-in package. */
    name?: string;
    /** Globally unique identifier of the Snap-in. */
    slug?: string;
};
/** snap-in-package-summary */
export type SnapInPackageSummary = AtomBaseSummary & {
    /** Description of the snap-in package. */
    description?: string;
    /** Name of the snap-in package. */
    name?: string;
    /** Globally unique identifier of the Snap-in. */
    slug?: string;
};
/** snap-in-packages-create-request */
export interface SnapInPackagesCreateRequest {
    /** Description of the snap-in package */
    description?: string;
    /** Name of the snap-in package */
    name?: string;
    /** Globally unique identifier of the Snap-in */
    slug: string;
}
/** snap-in-packages-create-response */
export interface SnapInPackagesCreateResponse {
    snap_in_package: SnapInPackage;
}
/** snap-in-packages-delete-request */
export interface SnapInPackagesDeleteRequest {
    /** The ID of the snap-in package to delete. */
    id: string;
}
/** snap-in-packages-get-request */
export interface SnapInPackagesGetRequest {
    /** The ID of the snap-in package to get. */
    id: string;
}
/** snap-in-packages-get-response */
export interface SnapInPackagesGetResponse {
    snap_in_package: SnapInPackage;
}
/** snap-in-packages-list-request */
export interface SnapInPackagesListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of snap-in packages to return. The default is
     * '50', the maximum is '100'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Fields to sort the snap-in packages by and the direction to sort
     * them.
     */
    sort_by?: string[];
}
/** snap-in-packages-list-response */
export interface SnapInPackagesListResponse {
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** List of snap-in packages. */
    snap_in_packages: SnapInPackage[];
}
/** Deployment status of the snap-in. */
export declare enum SnapInStatus {
    Active = "active",
    Draft = "draft"
}
/** snap-in-summary */
export type SnapInSummary = AtomBaseSummary;
/**
 * snap-in-tag-definition
 * Tag summary.
 */
export interface SnapInTagDefinition {
    /** Description of the tag. */
    description?: string;
    /** Name of the tag. */
    name?: string;
}
/** snap-in-version */
export type SnapInVersion = AtomBase & {
    /** Automation mappings. */
    automations?: SnapInAutomation[];
    /** Summary of the changes. */
    changelog?: string;
    /** Connections used by the snap-in code. */
    connections?: SnapInConnection[];
    /** Description. */
    description?: string;
    /** Event. */
    events?: SnapInEventSource[];
    /** Functions containing the user-provided code. */
    functions?: SnapInFunctionDefinition[];
    /** Set of global variables. */
    global_variables: string[];
    /** Semversion of the package. */
    manifest_version?: SemanticVersion;
    /** Name. */
    name?: string;
    snap_in_package?: SnapInPackageSummary;
    source_code_artifact?: ArtifactSummary;
    /** Snap-in package state. */
    state?: SnapInVersionState;
    /** Tags created during snap-in installation. */
    tags?: SnapInTagDefinition[];
    /** Semversion of the package. */
    version?: SemanticVersion;
};
/** Snap-in package state. */
export declare enum SnapInVersionState {
    Deploying = "deploying",
    Draft = "draft",
    Ready = "ready"
}
/** snap-in-version-summary */
export type SnapInVersionSummary = AtomBaseSummary;
/** snap-in-versions-create-request */
export interface SnapInVersionsCreateRequest {
    /** Manifest of the snap-in version to be created. */
    manifest: string;
    /** Parent snap-in package */
    snap_in_package: string;
    /**
     * The artifact containing user provided source code for snap-in
     * functions.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    source_code_artifact?: string;
}
/** snap-in-versions-create-response */
export interface SnapInVersionsCreateResponse {
    snap_in_version: SnapInVersion;
}
/** snap-in-versions-delete-request */
export interface SnapInVersionsDeleteRequest {
    /** The ID of the snap-in version to delete. */
    id: string;
}
/** snap-in-versions-get-request */
export interface SnapInVersionsGetRequest {
    /** The ID of the snap-in version to get. */
    id: string;
}
/** snap-in-versions-get-response */
export interface SnapInVersionsGetResponse {
    snap_in_version: SnapInVersion;
}
/** snap-ins-delete-request */
export interface SnapInsDeleteRequest {
    /** The ID of the snap-in to delete. */
    id: string;
}
/** snap-ins-deploy-request */
export interface SnapInsDeployRequest {
    /** The ID of the snap-in to deploy. */
    id: string;
}
/** snap-ins-deploy-response */
export interface SnapInsDeployResponse {
    snap_in: SnapIn;
}
/** snap-ins-draft-create-request */
export interface SnapInsDraftCreateRequest {
    /** The snap-in version from which the snap-in should be created. */
    snap_in_version: string;
}
/** snap-ins-draft-create-response */
export interface SnapInsDraftCreateResponse {
    snap_in: SnapIn;
}
/** snap-ins-get-request */
export interface SnapInsGetRequest {
    /** The ID of the snap-in to get. */
    id: string;
}
/** snap-ins-get-response */
export interface SnapInsGetResponse {
    snap_in: SnapIn;
}
/** snap-ins-list-request */
export interface SnapInsListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of snap-ins to return. The default is '50', the
     * maximum is '100'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Fields to sort the snap-ins by and the direction to sort them. */
    sort_by?: string[];
}
/** snap-ins-list-response */
export interface SnapInsListResponse {
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** List of snap-ins. */
    snap_ins: SnapIn[];
}
/** snap-ins-update-request */
export interface SnapInsUpdateRequest {
    /** List of connections used in the snap-in */
    connections?: UpdateSnapInNameReferenceMapping[];
    /** Application-defined custom fields. */
    custom_fields?: object;
    /** The ID of the snap-in to update. */
    id: string;
    /** List of inputs to update */
    inputs?: UpdateSnapInGlobalInput[];
    /** Schema fragment IDs. */
    schema_fragment_ids?: string[];
}
/** snap-ins-update-response */
export interface SnapInsUpdateResponse {
    snap_in: SnapIn;
}
/** snap-kit-action-request */
export type SnapKitActionRequest = SnapKitActionRequestButton & {
    /**
     * Id of the interactive element specified by developer in a snap-kit
     * object.
     */
    action_id: string;
    /** Action interaction type. */
    action_type?: string;
    /**
     * Id of the block within the surface which is the container for the
     * interactive element.
     */
    block_id?: string;
    /**
     * Timestamp when the action was originated.
     * @format date-time
     */
    timestamp: string;
    type: SnapKitActionRequestElementTypeValue;
};
/** snap-kit-action-request-button */
export interface SnapKitActionRequestButton {
    /** Value for the button interactive element. */
    value: string;
}
export declare enum SnapKitActionRequestElementTypeValue {
    Button = "button"
}
/** snap-kit-action-summary */
export type SnapKitActionSummary = AtomBaseSummary;
export declare enum SnapType {
    Flow = "flow",
    SnapIn = "snap_in"
}
/** snaps-list-request */
export type SnapsListRequest = object;
/** snaps-list-response */
export interface SnapsListResponse {
    /** List of snaps. */
    snaps: Snap[];
}
/** socket-action */
export interface SocketAction {
    subscribe?: SocketActionSubscribe;
    type?: 'subscribe' | 'user_typing';
    user_typing?: SocketActionUserTyping;
}
/** socket-action-subscribe */
export interface SocketActionSubscribe {
    /**
     * Adds event subscriptions for the objects with provided IDs. If a
     * subscription for an ID is already active, then nothing is done.
     */
    add?: string[];
    /**
     * An ID, generated by the client, that will be provided in the
     * resulting subscribe event. This is a mechanism for the client to
     * match a subscribe request (action) to its response (event), where a
     * subscribe action may generate one or more events. Therefore, the
     * client should not reuse the ID for several minutes to ensure that
     * duplicates aren't mistaken.
     */
    id?: string;
    /**
     * Removes event subscriptions for the objects with the provided IDs.
     * If there is no active subscription for an ID, then nothing is done.
     */
    remove?: string[];
}
/** socket-action-user-typing */
export interface SocketActionUserTyping {
    /** The ID of the object that the user is typing to. */
    object: string;
}
/** socket-event */
export interface SocketEvent {
    article_created?: EventArticleCreated;
    article_deleted?: EventArticleDeleted;
    article_updated?: EventArticleUpdated;
    artifact_created?: EventArtifactCreated;
    artifact_deleted?: EventArtifactDeleted;
    artifact_updated?: EventArtifactUpdated;
    conversation_created?: EventConversationCreated;
    conversation_deleted?: EventConversationDeleted;
    conversation_updated?: EventConversationUpdated;
    dev_user_created?: EventDevUserCreated;
    dev_user_deleted?: EventDevUserDeleted;
    dev_user_updated?: EventDevUserUpdated;
    flow_created?: EventFlowCreated;
    flow_deleted?: EventFlowDeleted;
    flow_updated?: EventFlowUpdated;
    link_created?: EventLinkCreated;
    link_deleted?: EventLinkDeleted;
    link_updated?: EventLinkUpdated;
    part_created?: EventPartCreated;
    part_deleted?: EventPartDeleted;
    part_updated?: EventPartUpdated;
    rev_org_created?: EventRevOrgCreated;
    rev_org_deleted?: EventRevOrgDeleted;
    rev_org_updated?: EventRevOrgUpdated;
    rev_user_created?: EventRevUserCreated;
    rev_user_deleted?: EventRevUserDeleted;
    rev_user_updated?: EventRevUserUpdated;
    subscribe?: EventSubscribe;
    tag_created?: EventTagCreated;
    tag_deleted?: EventTagDeleted;
    tag_updated?: EventTagUpdated;
    timeline_entry_created?: EventTimelineEntryCreated;
    timeline_entry_deleted?: EventTimelineEntryDeleted;
    timeline_entry_updated?: EventTimelineEntryUpdated;
    type?: 'article_created' | 'article_deleted' | 'article_updated' | 'artifact_created' | 'artifact_deleted' | 'artifact_updated' | 'conversation_created' | 'conversation_deleted' | 'conversation_updated' | 'dev_user_created' | 'dev_user_deleted' | 'dev_user_updated' | 'flow_created' | 'flow_deleted' | 'flow_updated' | 'link_created' | 'link_deleted' | 'link_updated' | 'part_created' | 'part_deleted' | 'part_updated' | 'rev_org_created' | 'rev_org_deleted' | 'rev_org_updated' | 'rev_user_created' | 'rev_user_deleted' | 'rev_user_updated' | 'subscribe' | 'tag_created' | 'tag_deleted' | 'tag_updated' | 'timeline_entry_created' | 'timeline_entry_deleted' | 'timeline_entry_updated' | 'user_typing' | 'vista_created' | 'vista_deleted' | 'vista_updated' | 'webhook_created' | 'webhook_deleted' | 'webhook_updated' | 'work_created' | 'work_deleted' | 'work_updated';
    user_typing?: EventUserTyping;
    vista_created?: EventVistaCreated;
    vista_deleted?: EventVistaDeleted;
    vista_updated?: EventVistaUpdated;
    webhook_created?: EventWebhookCreated;
    webhook_deleted?: EventWebhookDeleted;
    webhook_updated?: EventWebhookUpdated;
    work_created?: EventWorkCreated;
    work_deleted?: EventWorkDeleted;
    work_updated?: EventWorkUpdated;
}
/**
 * sockets-connect-request
 * The request to connect to an open socket.
 */
export interface SocketsConnectRequest {
    /**
     * The token for the open socket to connect to.
     * @format byte
     */
    token: string;
}
/**
 * sockets-open-request
 * The request to open an event socket.
 */
export type SocketsOpenRequest = object;
/**
 * sockets-open-response
 * The response to opening an event socket.
 */
export interface SocketsOpenResponse {
    /**
     * The token to use to connect to the opened socket.
     * @format byte
     */
    token: string;
}
/**
 * source-details
 * Discovery source details.
 */
export interface SourceDetails {
    /**
     * Discovery source data last captured timestamp.
     * @format date-time
     */
    last_captured_timestamp?: string;
    /**
     * Discovery source data collected file size in bytes.
     * @format int32
     */
    size_bytes?: number;
    /** Discovery source type. */
    type?: string;
}
/**
 * stage
 * Describes the current stage of a work item.
 */
export interface Stage {
    /** Current stage name of the work item. */
    name: string;
    /** Notes relevant to the stage. */
    notes?: string;
    /**
     * Current stage number of the work item (sortable).
     * @format int32
     */
    ordinal?: number;
    stage_id?: AtomSummary;
    state_id?: AtomSummary;
}
/** stage-diagram-summary */
export type StageDiagramSummary = AtomBaseSummary;
/**
 * stage-filter
 * The filter for stages.
 */
export interface StageFilter {
    /** Filters for records in the provided stage(s). */
    name?: string[];
}
/**
 * stage-init
 * Sets an object's initial stage.
 */
export interface StageInit {
    /** The name of the stage. */
    name: string;
    /** Notes relevant to the stage. */
    notes?: string;
}
/**
 * stage-update
 * Updates an object's stage.
 */
export interface StageUpdate {
    /** The updated name of the stage, otherwise unchanged if not set. */
    name?: string;
    /** The updated notes for the stage, otherwise unchanged if not set. */
    notes?: string;
}
/** start-data-collection-request */
export interface StartDataCollectionRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** start-data-collection-response */
export type StartDataCollectionResponse = object;
/**
 * status
 * Status of the user.
 */
export interface Status {
    /** Description of the status. */
    description?: string;
    /** Name of the emoji supporting the status text. */
    emoji?: string;
    /**
     * Time at which status expires.
     * @format date-time
     */
    expires_at?: string;
}
/**
 * stock-field-enum-override
 * Override for the allowed values of a stock field enum.
 */
export interface StockFieldEnumOverride {
    /** Allowed enum values. */
    enum_values: string[];
    /** REST API stock field name. */
    field_name?: string;
}
/** stock-schema-fragment */
export type StockSchemaFragment = AtomBase & {
    /** List of composite schemas. */
    composite_schemas: CompositeSchema[];
    /** Description of the schema. */
    description?: string;
    /** List of all fields in this schema. */
    fields: FieldDescriptor[];
    /** Leaf type this fragment applies to. */
    leaf_type?: string;
    new_fragment_ref?: AtomSummary;
    old_fragment_ref?: AtomSummary;
    /**
     * The SHA-256 hash of the schema. Used to implement idempotent
     * updates.
     */
    schema_signature?: string;
    /**
     * The salt used to evaluate SHA-256 hash of the schema. Used to
     * implement idempotent updates.
     */
    schema_signature_salt?: string;
    /** Title of the schema. */
    title?: string;
};
/** stock-schema-fragment-summary */
export type StockSchemaFragmentSummary = AtomBaseSummary;
/** stock-schema-fragments-get-request */
export interface StockSchemaFragmentsGetRequest {
    /** The ID of the stock schema fragment. */
    id?: string;
    /** The leaf type this fragment applies to. */
    leaf_type?: string;
}
/** stock-schema-fragments-get-response */
export interface StockSchemaFragmentsGetResponse {
    fragment: StockSchemaFragment;
}
/** stock-schema-fragments-list-request */
export interface StockSchemaFragmentsListRequest {
    /**
     * The cursor to resume iteration from, otherwise if not provided,
     * then iteration starts from the beginning.
     */
    cursor?: string;
    /** The list of leaf types. */
    leaf_type?: string[];
    /**
     * The maximum number of items.
     * @format int32
     */
    limit?: number;
    /** The list of fields to sort the items by and how to sort them. */
    sort_by?: string[];
}
/** stock-schema-fragments-list-response */
export interface StockSchemaFragmentsListResponse {
    /**
     * The cursor to resume iteration from, otherwise if not provided,
     * then iteration starts from the beginning.
     */
    cursor?: string;
    /** The stock schema fragments. */
    result: StockSchemaFragment[];
}
/** subtype */
export interface Subtype {
    /** DON of the custom type fragment this subtype belongs to. */
    fragment_id: string;
    /** DON of the custom type fragment this subtype belongs to. */
    fragment_id_v1?: string;
    /** Value of the subtype. */
    value: string;
}
/** subtypes-list-request */
export interface SubtypesListRequest {
    /** Leaf type for which subtypes are required. */
    leaf_type: string;
}
/** subtypes-list-response */
export interface SubtypesListResponse {
    /** List of subtypes. */
    subtypes: Subtype[];
}
/**
 * support-metric-target
 * An individual metric of an SLA, describing which metric should be
 * evaluated and against what target.
 */
export interface SupportMetricTarget {
    metric_definition?: AtomSummary;
    /**
     * The percentage of instances for which this metric's target must not
     * be breached, in order not to breach the overall SLA policy.
     * @format double
     */
    performance?: number;
    schedule?: AtomSummary;
    /**
     * The target value to be achieved, for example the time in which to
     * do something, or the maximum allowed number of message pairs. The
     * units and interpretation of the value is controlled by the
     * properties of the metric referenced in metric_definition_id, time
     * metrics count time in minutes, while value metrics just use
     * arbitrary units.
     * @format int32
     */
    target?: number;
    /**
     * The threshold in the same units as target where the metric is
     * considered to be 'at risk'. If it is reached, a notification will
     * be generated. It might be greater or smaller than the target,
     * depending on whether the metric is 'lesser is better' or 'greater
     * is better'.
     * @format int32
     */
    warning_target?: number;
}
/** supported-languages-request */
export interface SupportedLanguagesRequest {
    /**
     * The language to use to return localized, human readable names of
     * supported languages.
     */
    target_language?: string;
}
/** supported-languages-response */
export interface SupportedLanguagesResponse {
    /** The list of languages supported by translation API. */
    languages: LanguageResource[];
}
/** survey-summary */
export type SurveySummary = EngagementBaseSummary;
/** sys-user */
export type SysUser = UserBase & {
    /** Description of the system user. */
    description?: string;
    /** References to the tokens issued by the STS for this system user. */
    system_user_token_ids?: string[];
};
/** sys-user-summary */
export type SysUserSummary = UserBaseSummary;
/**
 * sys-users-get-request
 * A request to get a system user's information.
 */
export interface SysUsersGetRequest {
    /** User ID of the requested system user. */
    id?: string;
}
/**
 * sys-users-get-response
 * The response to getting the information for the system user.
 */
export interface SysUsersGetResponse {
    sys_user: SysUser;
}
/**
 * sys-users-list-request
 * A request to get the list of system user's information.
 */
export interface SysUsersListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The number of system users to be retrieved.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Fields to sort the system users by and the direction to sort them. */
    sort_by?: string[];
}
/**
 * sys-users-list-response
 * The response to listing the system users.
 */
export interface SysUsersListResponse {
    /**
     * The cursor that should be used to resume iteration. If not
     * provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The list of system users. */
    sys_users: SysUser[];
}
/**
 * sys-users-update-request
 * Request to update details of a Sys user.
 */
export interface SysUsersUpdateRequest {
    /**
     * Updated display handle for the Sys user.
     * @deprecated
     */
    display_handle?: string;
    /** Updated display name for the Sys user. */
    display_name?: string;
    /**
     * Artifact ID of a Sys user's display picture.
     * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
     */
    display_picture_id?: string | null;
    /** Full name of the user. */
    full_name?: string;
    /** The ID of Sys user to update. */
    id: string;
}
/**
 * sys-users-update-response
 * Updated Sys user object.
 */
export interface SysUsersUpdateResponse {
    sys_user: SysUser;
}
/** tag */
export type Tag = AtomBase & {
    access_level?: AccessLevel;
    /**
     * The allowed values for the tag, where a value is provided when a
     * tag is associated with an object. If empty, then no value should be
     * provided when the association is made.
     */
    allowed_values?: string[];
    /**
     * An informative description for the tag that should provide context
     * on the tag's purpose and usage.
     */
    description?: string;
    /**
     * The name of the tag, which denotes the logical concept by which all
     * tagged objects will be associated. The name is guaranteed to be
     * unique.
     */
    name: string;
    /** Style information of the tag (color, size, etc.). */
    style?: string;
    style_new?: TagStyle;
    /** An enum to specify the behaviour of values for this tag. */
    type?: TagType;
};
/** tag-search-summary */
export type TagSearchSummary = SearchSummaryBase & {
    tag: TagSummary;
};
/** tag-style */
export interface TagStyle {
    /** The hex color code in "#RRGGBB" format. */
    color?: string;
}
/** tag-style-summary */
export type TagStyleSummary = object;
/** tag-summary */
export type TagSummary = AtomBaseSummary & {
    /**
     * The name of the tag, which denotes the logical concept by which all
     * tagged objects will be associated. The name is guaranteed to be
     * unique.
     */
    name: string;
    /** Style information of the tag (color, size, etc.). */
    style?: string;
    style_new?: TagStyleSummary;
};
/** An enum to specify the behaviour of values for this tag. */
export declare enum TagType {
    Annotation = "annotation",
    Tag = "tag"
}
/** tag-with-value */
export interface TagWithValue {
    id: TagSummary;
    tag: TagSummary;
    /** The value for the object's association with the tag. */
    value?: string;
}
/**
 * tags-create-request
 * The request to create a new tag.
 */
export interface TagsCreateRequest {
    /**
     * The allowed values for the tag, or empty if no values are
     * permitted.
     */
    allowed_values?: string[];
    /** The description for the tag. */
    description?: string;
    /** The name for the tag, which must be unique across all tags. */
    name: string;
    /**
     * Style information for the tag.
     * @deprecated
     */
    style?: string;
    style_new?: TagStyle;
    /** An enum to specify the behaviour of values for this tag. */
    type?: TagType;
}
/**
 * tags-create-response
 * The response to creating a new tag.
 */
export interface TagsCreateResponse {
    tag: Tag;
}
/**
 * tags-delete-request
 * The request to delete a tag.
 */
export interface TagsDeleteRequest {
    /**
     * The ID of the tag to delete.
     * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
     */
    id: string;
}
/**
 * tags-delete-response
 * The response for deleting a tag.
 */
export type TagsDeleteResponse = object;
/**
 * tags-get-request
 * The request to get a tag's information.
 */
export interface TagsGetRequest {
    /**
     * The requested tag's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
     */
    id: string;
}
/**
 * tags-get-response
 * The response to getting a tag's information.
 */
export interface TagsGetResponse {
    tag: Tag;
}
/**
 * tags-list-request
 * The request to get information about a list of tags.
 */
export interface TagsListRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of tags to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
}
/**
 * tags-list-response
 * The response to listing the tags.
 */
export interface TagsListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The list of tags. */
    tags: Tag[];
}
/**
 * tags-update-allowed-values
 * Specifies an update to a tag's allowed values.
 */
export interface TagsUpdateAllowedValues {
    /** Sets the allowed values for the tag. */
    set?: string[];
}
/**
 * tags-update-request
 * The request to update a tag.
 */
export interface TagsUpdateRequest {
    /** Specifies an update to a tag's allowed values. */
    allowed_values?: TagsUpdateAllowedValues;
    /** The updated description of the tag. */
    description?: string;
    /**
     * The ID of the tag to update.
     * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
     */
    id: string;
    /**
     * The updated name of the tag. The name must be unique across all
     * tags.
     */
    name?: string;
    /** The updated style information for the tag. */
    style?: string;
    style_new?: TagStyle;
    /** An enum to specify the behaviour of values for this tag. */
    type?: TagType;
}
/**
 * tags-update-response
 * The response for updating a tag.
 */
export interface TagsUpdateResponse {
    tag: Tag;
}
/** task */
export type Task = WorkBase & {
    /**
     * Actual effort to complete the task.
     * @format double
     */
    actual_effort?: number;
    /** Part versions relevant to the work. */
    applies_to_versions?: string[];
    /** Whether this task is an embedded task of another work or not. */
    embedded?: boolean;
    /**
     * Estimated effort to complete the task.
     * @format double
     */
    estimated_effort?: number;
    /** Priority of the work based upon impact and criticality. */
    priority?: TaskPriority;
    /**
     * Timestamp when the task was started.
     * @format date-time
     */
    start_date?: string;
};
/** Priority of the work based upon impact and criticality. */
export declare enum TaskPriority {
    P0 = "p0",
    P1 = "p1",
    P2 = "p2",
    P3 = "p3"
}
/** task-summary */
export type TaskSummary = WorkBaseSummary;
/**
 * template
 * Information about the released template.
 */
export interface Template {
    artifact_id?: ArtifactSummary;
    /** Version of the latest marketplace item template. */
    version?: string;
}
/** tenant-fragment */
export type TenantFragment = CustomSchemaFragmentBase;
/** tenant-fragment-summary */
export type TenantFragmentSummary = CustomSchemaFragmentBaseSummary;
/** ticket */
export type Ticket = WorkBase & {
    /** Part versions relevant to the work. */
    applies_to_versions?: string[];
    rev_org?: OrgSummary;
    /** Severity of the ticket. */
    severity?: TicketSeverity;
    /** SLA summary for the object. */
    sla_summary?: ArchetypeSlaSummary;
};
/**
 * ticket-creation-group
 * Preferences group for Ticket creation.
 */
export interface TicketCreationGroup {
    default_ticket_owner_id?: UserSummary;
    default_ticket_part_id?: PartSummary;
}
/** Severity of the ticket. */
export declare enum TicketSeverity {
    Blocker = "blocker",
    High = "high",
    Low = "low",
    Medium = "medium"
}
/** ticket-summary */
export type TicketSummary = WorkBaseSummary & {
    rev_org?: OrgSummary;
    /** Severity of the ticket. */
    severity?: TicketSeverity;
};
/** timeline-change-event */
export type TimelineChangeEvent = TimelineEntryBase & {
    /** A timeline event. */
    event?: TimelineEvent;
};
/** timeline-change-event-summary */
export type TimelineChangeEventSummary = TimelineEntryBaseSummary;
/** timeline-comment */
export type TimelineComment = TimelineEntryBase & {
    /** The artifacts for the comment. */
    artifacts?: ArtifactSummary[];
    /** The attachments for the comment. */
    attachments?: ArtifactSummary[];
    /**
     * The comment's body. If the comment has been deleted, then no body
     * will appear in the response.
     */
    body?: string;
    /** The type of the body to use for the comment. */
    body_type?: TimelineCommentBodyType;
    /** The objects referenced in the comment. */
    references?: AtomSummary[];
    /** The SnapKit Body of the comment. */
    snap_kit_body?: object;
};
/** The type of the body to use for the comment. */
export declare enum TimelineCommentBodyType {
    SnapKit = "snap_kit",
    Text = "text"
}
/** timeline-comment-summary */
export type TimelineCommentSummary = TimelineEntryBaseSummary;
/** timeline-comments-create-request */
export interface TimelineCommentsCreateRequest {
    /**
     * The ID of the artifacts to the comment.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifact_ids?: string[];
    /**
     * The ID of the attachments to the comment.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    attachment_ids?: string[];
    /** The comment's body. */
    body?: string;
    /** The type of the body to use for the comment. */
    body_type?: TimelineCommentBodyType;
    /**
     * The ID of the object to create the comment for.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
    /** The SnapKit body of the comment. */
    snap_kit_body?: object;
}
/** timeline-comments-create-response */
export interface TimelineCommentsCreateResponse {
    entry: TimelineEntry;
}
/** Describes collections of timeline entries. */
export declare enum TimelineEntriesCollection {
    Comments = "comments",
    Events = "events"
}
/**
 * timeline-entries-create-request
 * The request to create a timeline entry for an object.
 */
export type TimelineEntriesCreateRequest = TimelineEntriesCreateRequestTimelineComment & {
    /**
     * The ID of the object to create the timeline entry for.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    object: string;
    type: TimelineEntriesCreateRequestType;
};
/** timeline-entries-create-request-timeline-comment */
export interface TimelineEntriesCreateRequestTimelineComment {
    /**
     * The IDs of the artifacts attached to the comment.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifacts?: string[];
    /** The comment's body. */
    body?: string;
    /** The type of the body to use for the comment. */
    body_type?: TimelineCommentBodyType;
    /** The SnapKit body of the comment. */
    snap_kit_body?: object;
}
export declare enum TimelineEntriesCreateRequestType {
    TimelineComment = "timeline_comment"
}
/**
 * timeline-entries-create-response
 * The response to creating a timeline entry for an object.
 */
export interface TimelineEntriesCreateResponse {
    timeline_entry: TimelineEntry;
}
/**
 * timeline-entries-delete-request
 * The request to delete a timeline entry from an object.
 */
export interface TimelineEntriesDeleteRequest {
    /** The ID of the timeline entry to delete. */
    id: string;
}
/**
 * timeline-entries-delete-response
 * The response to deleting a new timeline entry from an object.
 */
export type TimelineEntriesDeleteResponse = object;
/**
 * timeline-entries-get-request
 * The request to get a timeline entry.
 */
export interface TimelineEntriesGetRequest {
    /** The ID of the timeline entry to get. */
    id: string;
}
/**
 * timeline-entries-get-response
 * The request to getting a timeline entry.
 */
export interface TimelineEntriesGetResponse {
    entry: TimelineEntry;
    timeline_entry: TimelineEntry;
}
/**
 * timeline-entries-list-request
 * The request to list timeline entries for an object.
 */
export interface TimelineEntriesListRequest {
    /**
     * The collection(s) to list entries from, otherwise if not provided,
     * all entries are returned.
     */
    collections?: TimelineEntriesCollection[];
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The entry to begin iteration from. Note the entry will *not* be
     * included in the result (exclusive). If provided, then no cursor
     * should be set.
     */
    entry?: string;
    /**
     * The ID of the object to list timeline entries for.
     * @deprecated
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id?: string;
    /**
     * The maximum number of entries to return. If not set, then this
     * defaults to `50`.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * The ID of the object to list timeline entries for.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    object?: string;
}
/**
 * timeline-entries-list-response
 * The response to listing timeline entries for an object.
 */
export interface TimelineEntriesListResponse {
    /**
     * The cursor that should be used to resume iteration, otherwise if
     * not provided, then iteration has completed.
     * @deprecated
     */
    cursor?: string;
    /**
     * The timeline entries for the object.
     * @deprecated
     */
    entries: TimelineEntry[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The timeline entries for the object. */
    timeline_entries: TimelineEntry[];
}
/**
 * timeline-entries-update-request
 * The request to update a timeline entry.
 */
export type TimelineEntriesUpdateRequest = TimelineEntriesUpdateRequestTimelineComment & {
    /** The ID of the timeline entry to update. */
    id: string;
    type: TimelineEntriesUpdateRequestType;
};
/** timeline-entries-update-request-timeline-comment */
export interface TimelineEntriesUpdateRequestTimelineComment {
    artifacts?: TimelineEntriesUpdateRequestTimelineCommentArtifacts;
    /** The updated comment's body. */
    body?: string;
    /** The type of the body to use for the comment. */
    body_type?: TimelineCommentBodyType;
    /** The SnapKit body of the comment. */
    snap_kit_body?: object;
}
/** timeline-entries-update-request-timeline-comment-artifacts */
export interface TimelineEntriesUpdateRequestTimelineCommentArtifacts {
    /**
     * Adds the provided artifacts to the comment. An artifact cannot be
     * added more than once, i.e. nothing is done if the artifact is
     * already attached. Mutually exclusive with `set`.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    add?: string[];
    /**
     * Removes the provided artifacts from the comment. If an artifact is
     * not present, then it's ignored. Mututally exclusive with `set`.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    remove?: string[];
    /**
     * Sets the field to the provided artifacts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    set?: string[];
}
export declare enum TimelineEntriesUpdateRequestType {
    TimelineComment = "timeline_comment"
}
/**
 * timeline-entries-update-response
 * The response to updating a timeline entry.
 */
export interface TimelineEntriesUpdateResponse {
    timeline_entry: TimelineEntry;
}
/** timeline-entry */
export type TimelineEntry = (TimelineChangeEvent | TimelineComment) & {
    type: TimelineEntryType;
};
/** timeline-entry-base */
export type TimelineEntryBase = AtomBase & {
    /** Information about a pinned entry. */
    pin?: TimelinePin;
    /** The reactions to the entry. */
    reactions?: TimelineReaction[];
    /** Thread. */
    thread?: TimelineThread;
};
/** timeline-entry-base-summary */
export type TimelineEntryBaseSummary = AtomBaseSummary;
export declare enum TimelineEntryType {
    TimelineChangeEvent = "timeline_change_event",
    TimelineComment = "timeline_comment"
}
/**
 * timeline-event
 * A timeline event.
 */
export interface TimelineEvent {
    /** Base event for annotated type event. */
    annotated?: EventAnnotated;
    /** A creation event. */
    created?: EventCreated;
    /** A deletion event. */
    deleted?: EventDeleted;
    /** A linking event. */
    linked?: EventLinked;
    /** The type of the event. */
    type?: TimelineEventType;
    /** An update event. */
    updated?: EventUpdated;
}
/** The type of the event. */
export declare enum TimelineEventType {
    Annotated = "annotated",
    Created = "created",
    Deleted = "deleted",
    Linked = "linked",
    Updated = "updated"
}
/**
 * timeline-pin
 * Information about a pinned entry.
 */
export interface TimelinePin {
    pinned_by?: UserSummary;
    /**
     * Time when the object was pinned.
     * @format date-time
     */
    pinned_date?: string;
}
/**
 * timeline-reaction
 * Reaction.
 */
export interface TimelineReaction {
    /** The reaction's emoji. */
    emoji?: string;
    /** Whether the requesting user reacted with this reaction type. */
    reacted?: boolean;
    /**
     * The total number of users with this reaction type.
     * @format int32
     */
    total_users?: number;
}
/**
 * timeline-thread
 * Thread.
 */
export interface TimelineThread {
    /**
     * A subset of the first users in the thread. They will be ordered by
     * their appearance, beginning from the first reply and onwards. This
     * should be used only as a hint and should not be relied upon to be
     * present.
     */
    first_replies_by: UserSummary[];
    last_reply_by?: UserSummary;
    /**
     * Time of the last reply.
     * @format date-time
     */
    last_reply_date?: string;
    /**
     * The total number of replies in the thread.
     * @format int32
     */
    total_replies?: number;
    /**
     * The total number of unique users in the thread.
     * @format int32
     */
    total_users?: number;
}
/** translate-request */
export interface TranslateRequest {
    /** The content to translate. */
    contents: TranslateRequestContent[];
    /**
     * The language of the input text, if not set the API will attempt to
     * identify it.
     */
    input_language?: string;
    /** The format of the source text, for example, 'text/html'. */
    mime_type?: string;
    /** The language to use for translation of the input text. */
    target_language: string;
}
/** translate-request-content */
export interface TranslateRequestContent {
    /** A unique identifier for the text, for example, 'comment_id'. */
    key?: string;
    /** The input text to translate. */
    text: string;
}
/** translate-response */
export interface TranslateResponse {
    /** Translated content. */
    translations: Translation[];
}
/** translation */
export interface Translation {
    /**
     * The detected language of the input text when the input language is
     * not specified.
     */
    detected_language?: string;
    /**
     * A unique identifier for the text e.g comment_id. This is copied
     * over from the TranslationRequest content.
     */
    key?: string;
    /** The text translated to target language. */
    text: string;
}
/**
 * type-ahead-context
 * Fields required for typeahead recommendation.
 */
export interface TypeAheadContext {
    /**
     * The part that the work applies to.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part?: string;
    /**
     * The part that the work applies to.
     * @deprecated
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part_id?: string;
    /** Text context is used to represent the context for any text field. */
    body?: TypeAheadContextTextContext;
    /** Text context is used to represent the context for any text field. */
    title?: TypeAheadContextTextContext;
}
/**
 * type-ahead-context-text-context
 * Text context is used to represent the context for any text field.
 */
export interface TypeAheadContextTextContext {
    /** The text after the cursor. */
    after?: string;
    /** The text before the cursor. */
    before?: string;
}
/**
 * type-ahead-request
 * Typeahead request.
 */
export interface TypeAheadRequest {
    /** User action types. */
    action?: UserAction;
    /** Fields required for typeahead recommendation. */
    context: TypeAheadContext;
    /** Field types for typeahead recommendation. */
    requested_field: TypeAheadRequestedField;
}
/** Field types for typeahead recommendation. */
export declare enum TypeAheadRequestedField {
    Body = "body",
    Title = "title"
}
/**
 * type-ahead-response
 * Typeahead response.
 */
export interface TypeAheadResponse {
    /** The text recommedation returned by typeahead. */
    body: TypeAheadResponseTextRecommendation;
    /** The text recommedation returned by typeahead. */
    title: TypeAheadResponseTextRecommendation;
    /** The version of the type ahead model. */
    version?: string;
}
/**
 * type-ahead-response-text-recommendation
 * The text recommedation returned by typeahead.
 */
export interface TypeAheadResponseTextRecommendation {
    /** The text after the cursor. */
    after: string;
    /** The text before the cursor. */
    before: string;
    /** The text recommendation. */
    recommendation: string;
}
/**
 * unit
 * Unit encapsulates the name of the unit and the type of the unit. For
 * example, '#Number of API calls' where name is 'number_of_api_calls' and
 * type is 'number'.
 */
export interface Unit {
    /**
     * This represents human readable unit name of the UOM For example,
     * number of API calls.
     */
    name: string;
    /**
     * This defines the UOM unit type. For example, for 'number of video
     * calls', unit type will be a number.
     */
    type: UnitType;
}
/**
 * unit-summary
 * Unit encapsulates the name of the unit and the type of the unit. For
 * example, '#Number of API calls' where name is 'number_of_api_calls' and
 * type is 'number'.
 */
export interface UnitSummary {
    /**
     * This represents human readable unit name of the UOM For example,
     * number of API calls.
     */
    name: string;
    /**
     * This defines the UOM unit type. For example, for 'number of video
     * calls', unit type will be a number.
     */
    type: UnitType;
}
/**
 * This defines the UOM unit type. For example, for 'number of video
 * calls', unit type will be a number.
 */
export declare enum UnitType {
    Boolean = "boolean",
    Number = "number"
}
/** unschedule-data-collection-request */
export interface UnscheduleDataCollectionRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** unschedule-data-collection-response */
export type UnscheduleDataCollectionResponse = object;
/** unschedule-discovery-request */
export interface UnscheduleDiscoveryRequest {
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** unschedule-discovery-response */
export type UnscheduleDiscoveryResponse = object;
/** uom */
export type Uom = AtomBase & {
    /**
     * Aggregation type to be used while aggregating the metering data for the
     * UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
     * { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
     * meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
     * of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
     * {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
     * the meter in the given period (not considering the data from the
     * previous billing period) Ex. January {M1:{VM:VM0}}, February
     * {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
     * Sum of distinct active unique dimension observed for a meter in the
     * given period, taking into consideration the active data from the
     * previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
     * February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
     * 6] Duration - Sum of distinct active unique dimension duration for a
     * meter in the given period, taking into consideration the active data
     * from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
     * {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
     * 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
     * latest/last meter in the given period 8] Oldest - consider the
     * oldest/first record in the given period.
     */
    aggregation_type: UomAggregationType;
    /** Description of the UOM. */
    description?: string;
    /**
     * The list of dimensions that can be emitted along with the metering
     * data.
     */
    dimensions?: string[];
    /**
     * If set to true, then the UOM can be configured as part of
     * entitlements in skus and metering data only for the enabled uoms
     * will be passed through the metering pipeline.
     */
    is_enabled: boolean;
    /** Human readable meter name of the UOM. */
    meter_name: string;
    /**
     * The granularity at which the metering ingestion data is to be emitted
     * for the UOM.
     */
    meter_scope: UomMeterScope;
    /** Human readable name of the UOM. */
    name: string;
    part: PartSummary;
    product: PartSummary;
    /**
     * Unique dimension if provided to be considered for grouping metering
     * data for the UOM.
     */
    unique_dimension?: string;
    /**
     * Unit encapsulates the name of the unit and the type of the unit. For
     * example, '#Number of API calls' where name is 'number_of_api_calls' and
     * type is 'number'.
     */
    unit: Unit;
};
/**
 * Aggregation type to be used while aggregating the metering data for the
 * UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
 * { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
 * meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
 * of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
 * {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
 * the meter in the given period (not considering the data from the
 * previous billing period) Ex. January {M1:{VM:VM0}}, February
 * {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
 * Sum of distinct active unique dimension observed for a meter in the
 * given period, taking into consideration the active data from the
 * previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
 * February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
 * 6] Duration - Sum of distinct active unique dimension duration for a
 * meter in the given period, taking into consideration the active data
 * from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
 * {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
 * 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
 * latest/last meter in the given period 8] Oldest - consider the
 * oldest/first record in the given period.
 */
export declare enum UomAggregationType {
    Duration = "duration",
    Latest = "latest",
    Maximum = "maximum",
    Minimum = "minimum",
    Oldest = "oldest",
    RunningTotal = "running_total",
    Sum = "sum",
    UniqueCount = "unique_count"
}
/**
 * The granularity at which the metering ingestion data is to be emitted
 * for the UOM.
 */
export declare enum UomMeterScope {
    Org = "org",
    User = "user"
}
/** uom-summary */
export type UomSummary = AtomBaseSummary & {
    /** Human readable meter name of the UOM. */
    meter_name: string;
    /** Human readable name of the UOM. */
    name: string;
    /**
     * Unit encapsulates the name of the unit and the type of the unit. For
     * example, '#Number of API calls' where name is 'number_of_api_calls' and
     * type is 'number'.
     */
    unit: UnitSummary;
};
/** uoms-create-request */
export interface UomsCreateRequest {
    /**
     * Aggregation type to be used while aggregating the metering data for the
     * UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
     * { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
     * meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
     * of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
     * {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
     * the meter in the given period (not considering the data from the
     * previous billing period) Ex. January {M1:{VM:VM0}}, February
     * {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
     * Sum of distinct active unique dimension observed for a meter in the
     * given period, taking into consideration the active data from the
     * previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
     * February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
     * 6] Duration - Sum of distinct active unique dimension duration for a
     * meter in the given period, taking into consideration the active data
     * from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
     * {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
     * 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
     * latest/last meter in the given period 8] Oldest - consider the
     * oldest/first record in the given period.
     */
    aggregation_type: UomAggregationType;
    /** Description of the UOM. */
    description?: string;
    /**
     * The list of dimensions that can be emitted along with the metering
     * data. These might be needed in metering calculation or can be used
     * in the analytics service
     */
    dimensions?: string[];
    /** Human readable meter name of the UOM. */
    meter_name: string;
    /**
     * The granularity at which the metering ingestion data is to be emitted
     * for the UOM.
     */
    meter_scope: UomMeterScope;
    /** Human readable name of the UOM. */
    name: string;
    /**
     * The part ID for which the UOM is defined.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    part_id?: string;
    /**
     * The product ID for which the UOM is defined.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    product_id: string;
    /**
     * Unique dimension if provided to be considered for grouping and
     * aggregating metering data
     */
    unique_dimension?: string;
    /**
     * Unit encapsulates the name of the unit and the type of the unit. For
     * example, '#Number of API calls' where name is 'number_of_api_calls' and
     * type is 'number'.
     */
    unit: Unit;
}
/** uoms-create-response */
export interface UomsCreateResponse {
    uom: Uom;
}
/** uoms-delete-request */
export interface UomsDeleteRequest {
    /** The UOM's DON. */
    id: string;
}
/** uoms-get-request */
export interface UomsGetRequest {
    /** The UOM's DON. */
    id: string;
}
/** uoms-get-response */
export interface UomsGetResponse {
    uom: Uom;
}
/** uoms-list-request */
export interface UomsListRequest {
    /** The list of aggregation types which are to be aggregated. */
    aggregation_types?: UomAggregationType[];
    /** The list of UOM DONs which are to be aggregated. */
    ids?: string[];
    /** The list of meter names which are to be aggregated. */
    meter_names?: string[];
    /**
     * The list of part DONs which are to be aggregated.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    part_ids?: string[];
    /**
     * The list of product DONs which are to be aggregated.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    product_ids?: string[];
    /**
     * List of fields to sort the UOMs, by and how to sort them. Default
     * is to sort by created_date in descending order.
     */
    sort_by?: string[];
    /** The list of unit types which are to be aggregated. */
    unit_types?: UnitType[];
}
/** uoms-list-response */
export interface UomsListResponse {
    /** The list of UOMs. */
    uoms: Uom[];
}
/** uoms-update-request */
export interface UomsUpdateRequest {
    /**
     * Aggregation type to be used while aggregating the metering data for the
     * UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
     * { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
     * meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
     * of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
     * {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
     * the meter in the given period (not considering the data from the
     * previous billing period) Ex. January {M1:{VM:VM0}}, February
     * {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
     * Sum of distinct active unique dimension observed for a meter in the
     * given period, taking into consideration the active data from the
     * previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
     * February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
     * 6] Duration - Sum of distinct active unique dimension duration for a
     * meter in the given period, taking into consideration the active data
     * from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
     * {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
     * 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
     * latest/last meter in the given period 8] Oldest - consider the
     * oldest/first record in the given period.
     */
    aggregation_type?: UomAggregationType;
    /** Description of the UOM. */
    description?: string;
    /** The UOM's DON. */
    id: string;
    /**
     * To enable/disable the UOM. If the value is set to true, then the
     * UOM can be configured as part of entitlements in skus.Also,
     * metering data only for the enabled UOM's will be passed through the
     * metering pipeline
     */
    is_enabled?: boolean;
    /** Human readable name of the UOM. */
    name?: string;
    /** Unit name of the UOM. */
    unit?: string;
}
/** uoms-update-response */
export interface UomsUpdateResponse {
    uom: Uom;
}
/**
 * update-availability-preferences-group
 * Update object for AvailabilityPreferencesGroup.
 */
export interface UpdateAvailabilityPreferencesGroup {
    /** Manually set presence to away */
    manual_away?: boolean;
}
/** update-discovery-profile-request */
export interface UpdateDiscoveryProfileRequest {
    /** Configuration knobs for extractors. */
    extractors?: Extractors;
    /** The ID of the discovery profile to update. */
    id: string;
    /** Configuration knobs for partitioners and partition mergers. */
    mergers?: DevRevPartitionerMerger;
    /**
     * The updated ID of other data source Dev org to run discovery.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_data_source_dev_org?: string;
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
    /** Configuration knobs for partitioners and partition mergers. */
    partitioners?: DevRevPartitionerMerger;
    /** The updated name of the discovery profile. */
    profile_name?: string;
}
/** update-discovery-profile-response */
export interface UpdateDiscoveryProfileResponse {
    discovery_profile: DiscoveryProfile;
}
/** update-discovery-settings-request */
export interface UpdateDiscoverySettingsRequest {
    /** Configuration knobs for discovery application per devorg. */
    data_collection_app_settings?: DataCollectionAppSettings;
    /** Configuration knobs for discovery application per devorg. */
    discovery_app_settings?: DiscoveryAppSettings;
    /** Discovery profile id associated with devorg. */
    discovery_profile_id?: string;
    /** Discovery GitHub repositories settings for devorg. */
    github_repos?: DiscoveryGithubReposSettings[];
    /**
     * Optional Dev organization ID. This allows running on another Dev
     * organization, as long as the logged in user has access to it.
     * @example "don:<partition>:identity:devo/<dev-org-id>"
     */
    other_dev_org?: string;
}
/** update-discovery-settings-response */
export interface UpdateDiscoverySettingsResponse {
    discovery_settings: DiscoverySettings;
}
/** update-entitlements */
export interface UpdateEntitlements {
    /** Entitlements to be added under the SKU. */
    add_entitlements?: UpdateEntitlementsAddUpdateEntitlement[];
    /**
     * Entitlements to be removed from the SKU. In case, a SKU is
     * versioned orinherited, then entitlements from the parent SKU can be
     * removed.
     */
    remove_entitlements?: UpdateEntitlementsRemoveEntitlement[];
    /**
     * Entitlements to be updated in the SKU. In case, a SKU is versioned
     * orinherited, then entitlements from the parent SKU can be updated.
     */
    update_entitlements?: UpdateEntitlementsAddUpdateEntitlement[];
}
/** update-entitlements-add-update-entitlement */
export interface UpdateEntitlementsAddUpdateEntitlement {
    /**
     * Duration encapsulates the value of the duration and the type of the
     * duration. For example, 1 day where value is '1' and type is 'day'.
     */
    duration?: Duration;
    /**
     * Quantity, that the entitlement is entitled to use for the specified
     * UOM ID. In case of UOM being a boolean type (like
     * inline_compression, SAML, OAUTH) then quantity will simply be 0/1.
     * @format int32
     */
    quantity?: number;
    /**
     * Scope defines whether the entitlement is at org level or at each user
     * level. Knowing this will help on enforcing them for the given SKU at
     * rev, or at rev user level.
     */
    scope?: EntitlementScope;
    /** UOM ID of entitlement to be added/updated in the SKU. */
    uom_id: string;
}
/** update-entitlements-remove-entitlement */
export interface UpdateEntitlementsRemoveEntitlement {
    /** UOM ID of entitlement to be removed from the SKU. */
    uom_id: string;
}
/** update-event-source-setup-instructions */
export interface UpdateEventSourceSetupInstructions {
    /** Instructions content */
    content?: string;
    /** Format in which content is defined. */
    format?: InstructionsFormat;
}
/** update-flow-name-reference-mapping */
export interface UpdateFlowNameReferenceMapping {
    /**
     * Name by which the object is being referred in the flow. May be
     * different from the value of the `name` field (if present) of the
     * object.
     */
    name?: string;
    /** Reference to the actual object. */
    reference?: string;
}
/** update-flow-name-value-pair */
export interface UpdateFlowNameValuePair {
    /** Name */
    name?: string;
    /** Value */
    value?: string;
}
/** update-flow-setup-resource */
export interface UpdateFlowSetupResource {
    resource?: UpdateFlowNameReferenceMapping;
    /** Type of the created resource. */
    resource_type?: SetupResourceResourceType;
}
/** update-function-definition */
export interface UpdateFunctionDefinition {
    config_policy?: UpdatePolicyInstance;
    /** Name of the function. */
    function_name?: string;
}
/**
 * update-general-preferences-group
 * Update object for GeneralPreferencesGroup.
 */
export interface UpdateGeneralPreferencesGroup {
    /** Update object for AvailabilityPreferencesGroup. */
    availabilty?: UpdateAvailabilityPreferencesGroup;
}
/** update-global-input */
export interface UpdateGlobalInput {
    /** Name */
    name?: string;
    /** Value */
    value?: string;
}
/** update-keyring */
export interface UpdateKeyring {
    categories?: UpdateKeyringCategories;
    /** Description of the keyring. */
    description?: string;
    /** External organization ID of the keyring. */
    external_org_id?: string;
    /** Secret key. */
    key?: string;
    /** Name of the keyring. */
    name?: string;
    /** Scope of keyring. */
    scope?: KeyringScope;
}
/** update-keyring-categories */
export interface UpdateKeyringCategories {
    /** The updated categories, which will replace current categories. */
    set?: string[];
}
/** update-microflow-definition */
export interface UpdateMicroflowDefinition {
    /** Description of the microflow */
    description?: string;
    /** Name of the microflow */
    name?: string;
    /** Publish status of the microflow. */
    publish_status?: MicroflowDefinitionPublishStatus;
    /** Possible states of the object on which microflow is defined */
    states?: UpdateMicroflowTargetObjectState[];
    /** Possible transitions in the microflow */
    transitions?: UpdateMicroflowTargetObjectTransition[];
}
/** update-microflow-target-object-state */
export interface UpdateMicroflowTargetObjectState {
    /** Description of the state */
    description?: string;
    /** Name of the state */
    name?: string;
}
/** update-microflow-target-object-transition */
export interface UpdateMicroflowTargetObjectTransition {
    /** Set of triggers which could execute this transition */
    allowed_triggers?: UpdateMicroflowTriggerDefinition[];
    conditions?: UpdatePolicyInstance;
    /** Description of the transition */
    description?: string;
    /** Set of source states for the transition */
    from_states?: string[];
    /** Whether this is a global transition */
    global?: boolean;
    /** Whether this is an initial transition */
    initial?: boolean;
    /** Whether a button is displayed for the transition */
    is_ui_action?: boolean;
    /** The name of the transition, unique within a microflow */
    name?: string;
    /** Functions executed asynchronously, on transition success */
    post_function_definitions_ids?: string[];
    /** Functions executed synchronously with state change */
    pre_function_definitions_ids?: string[];
    /** The destination state of the transition */
    to_state?: string;
    validations?: UpdatePolicyInstance;
}
/** update-microflow-trigger-definition */
export interface UpdateMicroflowTriggerDefinition {
    /** Configuration defining applicable events from the source */
    config?: string;
    /** ID of the event source being subscribed */
    event_source_id?: string;
}
/**
 * update-notification-preferences-group
 * Update object for NotificationPreferencesGroup.
 */
export interface UpdateNotificationPreferencesGroup {
    /** Email notifications. */
    email_notifications?: NotificationPreferencesGroupEmailNotifications;
}
/**
 * update-org-preferences
 * Update object for OrgPreferences.
 */
export interface UpdateOrgPreferences {
    /** Automated initial response message. */
    autoresponse_initial_message?: string;
    /** Users who are notified when a new conversation is created. */
    new_conversation_notified_to?: string[];
    /** Update object for RevPortalGroup. */
    rev_portal?: UpdateRevPortalGroup;
    /**
     * Groups or users to send the analytics report to. If not specified,
     * send to all users in the organization.
     */
    weekly_analytics_report_recipients?: string[];
}
/**
 * update-phone-number
 * Update object for PhoneNumber.
 */
export interface UpdatePhoneNumber {
    /** The phone number in e164 format. */
    e164_number?: string;
    /** An optional extension. */
    extension?: string;
}
/** update-policy-instance */
export interface UpdatePolicyInstance {
    /** Name of the policy */
    name?: string;
    /** JSON string storing values for each templated variable. */
    parameters?: string;
    /** Rego policy string */
    policy?: string;
    /** Whether the policy is system generated */
    system_parseable?: boolean;
}
/**
 * update-postal-address
 * Update object for PostalAddress.
 */
export interface UpdatePostalAddress {
    /** Country name component. */
    country?: string;
    /**
     * Full mailing address, formatted for display or use on a mailing
     * label.
     */
    formatted?: string;
    /** Town, city. */
    locality?: string;
    /** Zip code of the address. */
    postal_code?: string;
    /** State, province, prefecture, or region component. */
    region?: string;
    /** Full street address component. */
    street_address?: string;
}
/** update-pricing */
export interface UpdatePricing {
    /** Pricing objects to be added. */
    add_price_infos?: UpdatePricingAddPriceInfo[];
    /** Pricing objects to be removed. */
    remove_price_infos?: UpdatePricingRemovePriceInfo[];
    /** Pricing objects to be updated. */
    update_price_infos?: UpdatePricingUpdatePriceInfo[];
}
/** update-pricing-add-price-info */
export interface UpdatePricingAddPriceInfo {
    /** Billing frequency of the SKU. */
    billing_cycle: PricingBillingCycle;
    /**
     * Number of units in each block. For example, If the metered units is
     * 540 and the block size is 100. Then the quantity will be 5.4. The
     * default value is 1.
     * @format int32
     */
    block_size?: number;
    /**
     * Currency used for the pricing object. For example, USD, INR etc.
     * Defaults to USD.
     */
    currency: string;
    /** Description of the pricing object. */
    description?: string;
    /**
     * Helps in deciding if a pricing object can be used for purchasing
     * new items. If set to true then new purchase can be made. If set to
     * false then no new purchase can be made, but quantity of existing
     * items, which were bought with this pricing ID can be updated.
     * Defaults to false.
     */
    is_active?: boolean;
    /**
     * Whether the slabs should be priced tiered or flat. The default
     * value is false.
     */
    is_tiered?: boolean;
    /** List of price slabs for the given currency. */
    price_slabs: PriceSlab[];
}
/** update-pricing-remove-price-info */
export interface UpdatePricingRemovePriceInfo {
    /** Billing frequency of the SKU. */
    billing_cycle: PricingBillingCycle;
    /**
     * Currency used for the pricing. For example, USD, INR etc. Defaults
     * to USD.
     */
    currency: string;
}
/** update-pricing-update-price-info */
export interface UpdatePricingUpdatePriceInfo {
    /** Billing frequency of the SKU. */
    billing_cycle: PricingBillingCycle;
    /**
     * Number of units in each block. For example, If the metered units is
     * 540 and the block size is 100. Then the quantity will be 5.4. The
     * default value is 1.
     * @format int32
     */
    block_size?: number;
    /**
     * Currency used for the pricing. For example, USD, INR etc. Defaults
     * to USD.
     */
    currency: string;
    /** Description of the pricing. */
    description?: string;
    /**
     * Helps in deciding if a pricing object can be used for purchasing
     * new items. If set to true then new purchase can be made. If set to
     * false then no new purchase can be made, but quantity of existing
     * items, which were bought with this pricing ID can be updated.
     * Defaults to false.
     */
    is_active?: boolean;
    /**
     * Whether the slabs should be priced tiered or flat. The default
     * value is false.
     */
    is_tiered?: boolean;
    /** List of price slabs for the given currency. */
    price_slabs: PriceSlab[];
}
/** update-recurring-line-items */
export interface UpdateRecurringLineItems {
    /**
     * Quantity to be updated in the service plan.
     * @format int32
     */
    quantity?: number;
    /** Recurring line item to be updated in the service plan. */
    recurring_line_item_id: string;
}
/**
 * update-rev-portal-group
 * Update object for RevPortalGroup.
 */
export interface UpdateRevPortalGroup {
    /** Update object for TicketCreationGroup. */
    ticket_creation_preferences?: UpdateTicketCreationGroup;
}
/** update-snap-in-global-input */
export interface UpdateSnapInGlobalInput {
    /** Name of the input whose value is to be updated. */
    name: string;
    /** Updated value, omit to UNSET. */
    value?: string;
}
/** update-snap-in-name-reference-mapping */
export interface UpdateSnapInNameReferenceMapping {
    /** Name by which the object is being referred in the snap-in version. */
    name?: string;
    /**
     * Reference to the actual object.
     * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
     */
    reference?: string;
}
/**
 * update-ticket-creation-group
 * Update object for TicketCreationGroup.
 */
export interface UpdateTicketCreationGroup {
    /**
     * Default owner for the ticket, in case the ticket is created without
     * an assigned owner
     */
    default_ticket_owner_id?: string;
    /**
     * Default part to which a ticket is assigned, in case a ticket is
     * being created without an assigned part
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    default_ticket_part_id?: string;
}
/**
 * update-user-preferences
 * Update object for UserPreferences.
 */
export interface UpdateUserPreferences {
    /** Enable email notifications */
    enable_email_notifications?: boolean;
    /** Enable weekly analytics report. */
    enable_weekly_analytics_report?: boolean;
    /** Update object for GeneralPreferencesGroup. */
    general_preferences?: UpdateGeneralPreferencesGroup;
    /** Update object for NotificationPreferencesGroup. */
    notification_preferences?: UpdateNotificationPreferencesGroup;
    /** App theme mode. */
    theme_mode?: UserPreferencesThemeMode;
}
/** User action types. */
export declare enum UserAction {
    CreatePart = "create_part",
    CreateWork = "create_work",
    UpdatePart = "update_part",
    UpdateWork = "update_work"
}
/** user-base */
export type UserBase = AtomBase & {
    /**
     * The user's display handle. This field is deprecated now. Use
     * display_name field instead.
     */
    display_handle?: string;
    /** The user's display name. The name is non-unique and mutable. */
    display_name?: string;
    display_picture?: ArtifactSummary;
    /** Email address of the user. */
    email?: string;
    /** Full name of the user. */
    full_name?: string;
    /** Phone numbers of the user. */
    phone_numbers?: string[];
    /** State of the user. */
    state?: UserState;
};
/** user-base-summary */
export type UserBaseSummary = AtomBaseSummary & {
    /**
     * The user's display handle. This field is deprecated now. Use
     * display_name field instead.
     */
    display_handle?: string;
    /** The user's display name. The name is non-unique and mutable. */
    display_name?: string;
    display_picture?: ArtifactSummary;
    /** Email address of the user. */
    email?: string;
    /** Full name of the user. */
    full_name?: string;
    /** State of the user. */
    state?: UserState;
};
/**
 * user-invitation-delete-request
 * The request to delete a invitation sent to the user.
 */
export interface UserInvitationDeleteRequest {
    /** Email of the invited user. */
    email: string;
}
/**
 * user-invitation-delete-response
 * The response of deleting a invitation sent to the user.
 */
export type UserInvitationDeleteResponse = object;
/** user-mentioned-notification */
export type UserMentionedNotification = NotificationBase & {
    /** The body on which the user was mentioned. */
    body?: string;
    /** The objects referenced in the body. */
    references?: AtomSummary[];
    source?: AtomSummary;
};
/** user-mentioned-notification-summary */
export type UserMentionedNotificationSummary = NotificationBaseSummary;
/** user-participation-notification */
export type UserParticipationNotification = NotificationBase & {
    /** Details of the comment activities that triggered the notification. */
    comment_activities?: CommentActivity[];
    /** Details of the event activities that triggered the notification. */
    event_activities?: EventActivity[];
    /** The latest type of the activity triggering the notification. */
    latest_activity_type?: UserParticipationNotificationLatestActivityType;
};
/** The latest type of the activity triggering the notification. */
export declare enum UserParticipationNotificationLatestActivityType {
    Comment = "comment",
    Event = "event"
}
/** user-participation-notification-summary */
export type UserParticipationNotificationSummary = NotificationBaseSummary;
/** user-preferences */
export type UserPreferences = PreferencesBase & {
    /** Enable email notifications. */
    enable_email_notifications?: boolean;
    /** Enable weekly analytics report. */
    enable_weekly_analytics_report?: boolean;
    /** Preferences group for General settings. */
    general_preferences?: GeneralPreferencesGroup;
    /** Preferences group for Notifications. */
    notification_preferences?: NotificationPreferencesGroup;
    /** App theme mode. */
    theme_mode?: UserPreferencesThemeMode;
};
/** user-preferences-summary */
export type UserPreferencesSummary = PreferencesBaseSummary;
/** App theme mode. */
export declare enum UserPreferencesThemeMode {
    Auto = "auto",
    Dark = "dark",
    Light = "light"
}
/**
 * user-privileges-request
 * A request to get the privileges of user on the target object/object
 * type.
 */
export interface UserPrivilegesRequest {
    /** Information regarding the target object/object type */
    target: UserPrivilegesRequestTarget;
}
/**
 * user-privileges-request-target
 * Information regarding the target object/object type
 */
export interface UserPrivilegesRequestTarget {
    /**
     * The ID of the target object for which user privileges are
     * requested.
     */
    id?: string;
    object_type?: ObjectTypeProto;
}
/**
 * user-privileges-response
 * Response object for the user privileges request.
 */
export interface UserPrivilegesResponse {
    /**
     * Unique decision ID that can be used to identify the policy
     * evaluation
     */
    decision_id?: string;
    /** Whether MFZ is enabled or not for the user object/object type. */
    is_mfz_enabled: boolean;
    /**
     * The list of the privileges the user has on the requested target
     * object/object type.
     */
    privileges: OperationType[];
}
/** user-search-summary */
export type UserSearchSummary = SearchSummaryBase & {
    user: UserSummary;
};
/** State of the user. */
export declare enum UserState {
    Active = "active",
    Deactivated = "deactivated",
    Locked = "locked",
    Shadow = "shadow",
    Unassigned = "unassigned"
}
/** user-summary */
export type UserSummary = (DevUserSummary | DevrevProfileSummary | RevUserSummary | ServiceAccountSummary | SysUserSummary) & {
    type: UserType;
};
export declare enum UserType {
    DevUser = "dev_user",
    DevrevProfile = "devrev_profile",
    RevUser = "rev_user",
    ServiceAccount = "service_account",
    SysUser = "sys_user"
}
/** validate-flow-template-request */
export interface ValidateFlowTemplateRequest {
    /** New version of the flow. Required with old version. */
    new_version?: string;
    /** The new template as a string. */
    new_yaml: string;
    /** Old version of the flow. Required with old yaml. */
    old_version?: string;
    /** The old template as a string. */
    old_yaml?: string;
}
/** validate-flow-template-response */
export interface ValidateFlowTemplateResponse {
    /**
     * If the templates are valid and the version update (if applicable)
     * is allowed.
     */
    valid: boolean;
    /** Any error in the YAML or version update */
    validation_error?: string;
}
/** vertex-v2 */
export type VertexV2 = (VertexV2Capability | VertexV2CustomPart | VertexV2Enhancement | VertexV2Feature | VertexV2Linkable | VertexV2Product | VertexV2Runnable) & {
    /**
     * ID of user who created the object.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    created_by_id: string;
    /** ID of user who created the object. */
    created_by_id_v1?: string;
    /** The timestamp at which the object was created. */
    created_date: string;
    /** The ID of the Dev org. */
    dev_oid?: string;
    /** Human-readable ID specific to the Dev org. */
    display_id?: string;
    /** ID of the devrev object which is represented by this Vertex */
    id: string;
    /** ID of the devrev object which is represented by this Vertex */
    id_v1?: string;
    /**
     * ID of the user who last modified the object.
     * @example "don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"
     */
    modified_by_id: string;
    /** ID of the user who last modified the object. */
    modified_by_id_v1?: string;
    /** The timestamp at which the object was last modified. */
    modified_date: string;
    /** Name of the part. */
    name: string;
    object_type: VertexV2ObjectType;
    /**
     * The version of the object.
     * @format int64
     */
    object_version?: number;
    /** Designated category of the part. */
    part_category: PartCategory;
    part_type: PartType;
};
/** vertex-v2-capability */
export interface VertexV2Capability {
    /** IDs of the Dev part fullfilling the part. */
    fullfilled_by: string[];
    /** IDs of the Dev part fullfilling the part. */
    fullfilled_by_v1?: string;
    /** Links associated with the object. */
    links: ArchetypeLinkSummary[];
    /** ID of the parent part. */
    part_of_part_id: string;
    /** ID of the parent part. */
    part_of_part_id_v1?: string;
}
/** vertex-v2-custom-part */
export type VertexV2CustomPart = object;
/** vertex-v2-enhancement */
export type VertexV2Enhancement = object;
/** vertex-v2-feature */
export interface VertexV2Feature {
    /** IDs of the Dev part fullfilling the part. */
    fullfilled_by: string[];
    /** IDs of the Dev part fullfilling the part. */
    fullfilled_by_v1?: string;
    /** Links associated with the object. */
    links: ArchetypeLinkSummary[];
    /** ID of the parent part. */
    part_of_part_id: string;
    /** ID of the parent part. */
    part_of_part_id_v1?: string;
}
/** vertex-v2-linkable */
export interface VertexV2Linkable {
    /** Links associated with the object. */
    links: ArchetypeLinkSummary[];
}
export declare enum VertexV2ObjectType {
    Capability = "capability",
    CustomPart = "custom_part",
    Enhancement = "enhancement",
    Feature = "feature",
    Linkable = "linkable",
    Product = "product",
    Runnable = "runnable"
}
/** vertex-v2-product */
export interface VertexV2Product {
    /** IDs of the Dev part fullfilling the part. */
    fullfilled_by: string[];
    /** IDs of the Dev part fullfilling the part. */
    fullfilled_by_v1?: string;
    /** Links associated with the object. */
    links: ArchetypeLinkSummary[];
}
/** vertex-v2-runnable */
export interface VertexV2Runnable {
    /** Links associated with the object. */
    links: ArchetypeLinkSummary[];
}
/** view-frame */
export interface ViewFrame {
    conversation_ids: string[];
    current_filter?: string;
    part_ids: string[];
    revo_ids: string[];
    route: AppRouteValue;
    vista_id?: string;
    work_ids: string[];
}
/**
 * vista
 * Represents a collection of DevRev objects.
 */
export type Vista = (CuratedVista | DynamicVista | GroupedVista) & {
    /** Type of vista object. */
    type: VistaType;
};
/** vista-base */
export type VistaBase = AtomBase & {
    access_level?: AccessLevel;
    /** Description of the vista. */
    description?: string;
    /**
     * Timestamp when the vista ends.
     * @format date-time
     */
    end_date?: string;
    /**
     * Denotes the icon associated with the object in the UI. For example,
     * 'BUG_SELECT', 'INBOX_MAIL_INCOMING'.
     */
    icon_type?: string;
    /** Boolean to specify whether it's a default Vista or not. */
    is_default?: boolean;
    /** Members associated with the object. */
    members?: ObjectMemberV1[];
    /** Name of the vista. */
    name: string;
    /**
     * Timestamp when the vista starts.
     * @format date-time
     */
    start_date?: string;
};
/** vista-member-value */
export interface VistaMemberValue {
    /** The ID of the member. */
    id: string;
    /** The ID of the role. */
    role: string;
}
/** vista-shared-notification */
export type VistaSharedNotification = NotificationBase & {
    vista_id?: AtomSummary;
};
/** vista-shared-notification-summary */
export type VistaSharedNotificationSummary = NotificationBaseSummary;
/** Type of vista object. */
export declare enum VistaType {
    Curated = "curated",
    Dynamic = "dynamic",
    Grouped = "grouped"
}
/**
 * vistas-create-request
 * The request to create new vista.
 */
export type VistasCreateRequest = (VistasCreateRequestCuratedVista | VistasCreateRequestDynamicVista | VistasCreateRequestGroupedVista) & {
    /** Description of the vista. */
    description?: string;
    /**
     * Timestamp when the vista ends.
     * @format date-time
     */
    end_date?: string;
    /** Icon type for the vista. */
    icon_type?: string;
    /** Members associated with vista. */
    members?: VistaMemberValue[];
    /** Name of the vista. */
    name: string;
    /**
     * Timestamp when the vista starts.
     * @format date-time
     */
    start_date?: string;
    /** Type of vista object. */
    type: VistaType;
};
/** vistas-create-request-curated-vista */
export interface VistasCreateRequestCuratedVista {
    /** Items associated with the vista. */
    items?: VistasCreateRequestCuratedVistaItemValue[];
}
/** vistas-create-request-curated-vista-item-value */
export interface VistasCreateRequestCuratedVistaItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** vistas-create-request-dynamic-vista */
export type VistasCreateRequestDynamicVista = (VistasCreateRequestDynamicVistaConversationsVista | VistasCreateRequestDynamicVistaPartsVista | VistasCreateRequestDynamicVistaRevOrgsVista | VistasCreateRequestDynamicVistaWorksVista) & {
    /** Type of DevRev object for which the vista is applicable. */
    filter_type: DynamicVistaFilterType;
};
/** vistas-create-request-dynamic-vista-conversations-vista */
export interface VistasCreateRequestDynamicVistaConversationsVista {
    filter: VistasCreateRequestDynamicVistaConversationsVistaFilter;
    /** Pinned items associated with the vista. */
    items?: VistasCreateRequestDynamicVistaConversationsVistaItemValue[];
}
/** vistas-create-request-dynamic-vista-conversations-vista-filter */
export interface VistasCreateRequestDynamicVistaConversationsVistaFilter {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    created_date?: DateTimeFilter;
    /** The field to group the collection by. */
    group_by?: string;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/** vistas-create-request-dynamic-vista-conversations-vista-item-value */
export interface VistasCreateRequestDynamicVistaConversationsVistaItemValue {
    /** The ID of the item. */
    id: string;
}
/** vistas-create-request-dynamic-vista-parts-vista */
export interface VistasCreateRequestDynamicVistaPartsVista {
    filter: VistasCreateRequestDynamicVistaPartsVistaFilter;
    /** Pinned items associated with the vista. */
    items?: VistasCreateRequestDynamicVistaPartsVistaItemValue[];
}
/** vistas-create-request-dynamic-vista-parts-vista-filter */
export interface VistasCreateRequestDynamicVistaPartsVistaFilter {
    /** Filters for parts of the provided categories. */
    categories?: PartCategory[];
    created_date?: DateTimeFilter;
    enhancement?: PartsFilterEnhancement;
    /** The field to group the collection by. */
    group_by?: string;
    modified_date?: DateTimeFilter;
    /** Filters for parts of the provided name(s). */
    name?: string[];
    /**
     * Filters for parts owned by any of the provided users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for part with any of the provided states. */
    state?: string[];
    /**
     * Filters for parts with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /** Filters for parts of the provided type(s). */
    type?: PartType[];
    /**
     * Filters for parts of the provided type(s).
     * @deprecated
     */
    types?: PartType[];
}
/** vistas-create-request-dynamic-vista-parts-vista-item-value */
export interface VistasCreateRequestDynamicVistaPartsVistaItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
}
/** vistas-create-request-dynamic-vista-rev-orgs-vista */
export interface VistasCreateRequestDynamicVistaRevOrgsVista {
    filter: VistasCreateRequestDynamicVistaRevOrgsVistaFilter;
    /** Pinned items associated with the vista. */
    items?: VistasCreateRequestDynamicVistaRevOrgsVistaItemValue[];
}
/** vistas-create-request-dynamic-vista-rev-orgs-vista-filter */
export interface VistasCreateRequestDynamicVistaRevOrgsVistaFilter {
    /** Filters by account. */
    account?: string[];
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    /** The field to group the collection by. */
    group_by?: string;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/** vistas-create-request-dynamic-vista-rev-orgs-vista-item-value */
export interface VistasCreateRequestDynamicVistaRevOrgsVistaItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id: string;
}
/** vistas-create-request-dynamic-vista-works-vista */
export interface VistasCreateRequestDynamicVistaWorksVista {
    filter: VistasCreateRequestDynamicVistaWorksVistaFilter;
    /** Pinned items associated with the vista. */
    items?: VistasCreateRequestDynamicVistaWorksVistaItemValue[];
}
/** vistas-create-request-dynamic-vista-works-vista-filter */
export interface VistasCreateRequestDynamicVistaWorksVistaFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** vistas-create-request-dynamic-vista-works-vista-item-value */
export interface VistasCreateRequestDynamicVistaWorksVistaItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** vistas-create-request-grouped-vista */
export type VistasCreateRequestGroupedVista = VistasCreateRequestGroupedVistaWorksVista & {
    /** Type of DevRev object for which the grouped vista is applicable. */
    filter_type: GroupedVistaFilterType;
    /** Denotes the use case of the grouped vista. */
    flavor?: GroupedVistaFlavor;
};
/** vistas-create-request-grouped-vista-works-vista */
export interface VistasCreateRequestGroupedVistaWorksVista {
    filter?: VistasCreateRequestGroupedVistaWorksVistaFilter;
    /** The list of vista groups. */
    groups?: VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItem[];
}
/** vistas-create-request-grouped-vista-works-vista-filter */
export interface VistasCreateRequestGroupedVistaWorksVistaFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** vistas-create-request-grouped-vista-works-vista-works-vista-group-item */
export type VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItem = (VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemCuratedGroup | VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemDynamicGroup) & {
    /** Description of the group. */
    description?: string;
    /** Icon associated with the group in the UI. */
    icon_type?: string;
    /** Name of the group. */
    name: string;
    /** Type of works vista group item. */
    type: WorksVistaGroupItemType;
};
/** vistas-create-request-grouped-vista-works-vista-works-vista-group-item-curated-group */
export interface VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemCuratedGroup {
    /** Static list of work items. */
    items?: VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemCuratedGroupItemValue[];
}
/** vistas-create-request-grouped-vista-works-vista-works-vista-group-item-curated-group-item-value */
export interface VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemCuratedGroupItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** vistas-create-request-grouped-vista-works-vista-works-vista-group-item-dynamic-group */
export interface VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemDynamicGroup {
    filter: VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemDynamicGroupFilter;
}
/** vistas-create-request-grouped-vista-works-vista-works-vista-group-item-dynamic-group-filter */
export interface VistasCreateRequestGroupedVistaWorksVistaWorksVistaGroupItemDynamicGroupFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/**
 * vistas-create-response
 * The response to vista creation.
 */
export interface VistasCreateResponse {
    /** Represents a collection of DevRev objects. */
    vista: Vista;
}
/**
 * vistas-delete-request
 * The request to delete a vista.
 */
export interface VistasDeleteRequest {
    /** The ID of the vista to delete. */
    id: string;
}
/**
 * vistas-delete-response
 * The response when deleting a vista.
 */
export type VistasDeleteResponse = object;
/**
 * vistas-get-request
 * The request to get a vista's information.
 */
export interface VistasGetRequest {
    /** The vista's ID. */
    id: string;
}
/**
 * vistas-get-response
 * The response to getting a vista's information.
 */
export interface VistasGetResponse {
    /** Represents a collection of DevRev objects. */
    vista: Vista;
}
/**
 * vistas-list-request
 * The request to get information about a list of vistas.
 */
export interface VistasListRequest {
    /**
     * Filters for vistas created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /** Whether the default vistas should be fetched or not. */
    is_default?: boolean;
    /**
     * The maximum number of vistas to return. The default is '50', the
     * maximum is '100'.
     * @format int32
     */
    limit?: number;
    /**
     * Filters for vistas accessible to the input members.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Filters for vistas of specific object types like works, parts etc. */
    object_type?: DynamicVistaFilterType[];
    /** Fields to sort the vistas by and the direction to sort them. */
    sort_by?: string[];
    /** Filters for vistas of the specific type. */
    type?: VistaType[];
}
/**
 * vistas-list-response
 * The response to listing the vistas.
 */
export interface VistasListResponse {
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The list of vistas. */
    vistas: Vista[];
}
/**
 * vistas-update-request
 * The request to update a vista.
 */
export type VistasUpdateRequest = (VistasUpdateRequestCuratedVista | VistasUpdateRequestDynamicVista | VistasUpdateRequestGroupedVista) & {
    /** The updated vista's description. */
    description?: string;
    /**
     * Updated timestamp of when the vista ends.
     * @format date-time
     */
    end_date?: string;
    /** The updated vista's icon type. */
    icon_type?: string;
    /** The ID of the vista to update. */
    id: string;
    members?: VistasUpdateRequestMembers;
    /** The updated vista's name. */
    name?: string;
    /**
     * Updated timestamp of when the vista starts.
     * @format date-time
     */
    start_date?: string;
    /** Type of vista object. */
    type: VistaType;
};
/** vistas-update-request-curated-vista */
export interface VistasUpdateRequestCuratedVista {
    items?: VistasUpdateRequestCuratedVistaItems;
}
/** vistas-update-request-curated-vista-items */
export interface VistasUpdateRequestCuratedVistaItems {
    /** Sets the items to the provided items. */
    set?: VistasUpdateRequestCuratedVistaItemsItemValue[];
}
/** vistas-update-request-curated-vista-items-item-value */
export interface VistasUpdateRequestCuratedVistaItemsItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** vistas-update-request-dynamic-vista */
export type VistasUpdateRequestDynamicVista = (VistasUpdateRequestDynamicVistaConversationsVista | VistasUpdateRequestDynamicVistaPartsVista | VistasUpdateRequestDynamicVistaRevOrgsVista | VistasUpdateRequestDynamicVistaWorksVista) & {
    /** Type of DevRev object for which the vista is applicable. */
    filter_type: DynamicVistaFilterType;
};
/** vistas-update-request-dynamic-vista-conversations-vista */
export interface VistasUpdateRequestDynamicVistaConversationsVista {
    filter?: VistasUpdateRequestDynamicVistaConversationsVistaFilter;
    items?: VistasUpdateRequestDynamicVistaConversationsVistaItems;
}
/** vistas-update-request-dynamic-vista-conversations-vista-filter */
export interface VistasUpdateRequestDynamicVistaConversationsVistaFilter {
    /**
     * Filters for conversations belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_parts?: string[];
    created_date?: DateTimeFilter;
    /** The field to group the collection by. */
    group_by?: string;
    /**
     * Filters for conversations where these users are participants.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    members?: string[];
    modified_date?: DateTimeFilter;
    /**
     * Filters for conversations owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for conversations that are associated with any of the
     * provided Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** Filters for conversations with any of the provided source channels. */
    source_channels?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for conversations with any of the provided states. */
    state?: string[];
    /**
     * Filters for conversations with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
}
/** vistas-update-request-dynamic-vista-conversations-vista-items */
export interface VistasUpdateRequestDynamicVistaConversationsVistaItems {
    /** Sets the items to the provided items. */
    set?: VistasUpdateRequestDynamicVistaConversationsVistaItemsItemValue[];
}
/** vistas-update-request-dynamic-vista-conversations-vista-items-item-value */
export interface VistasUpdateRequestDynamicVistaConversationsVistaItemsItemValue {
    /** The ID of the item. */
    id: string;
}
/** vistas-update-request-dynamic-vista-parts-vista */
export interface VistasUpdateRequestDynamicVistaPartsVista {
    filter?: VistasUpdateRequestDynamicVistaPartsVistaFilter;
    items?: VistasUpdateRequestDynamicVistaPartsVistaItems;
}
/** vistas-update-request-dynamic-vista-parts-vista-filter */
export interface VistasUpdateRequestDynamicVistaPartsVistaFilter {
    /** Filters for parts of the provided categories. */
    categories?: PartCategory[];
    created_date?: DateTimeFilter;
    enhancement?: PartsFilterEnhancement;
    /** The field to group the collection by. */
    group_by?: string;
    modified_date?: DateTimeFilter;
    /** Filters for parts of the provided name(s). */
    name?: string[];
    /**
     * Filters for parts owned by any of the provided users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for part with any of the provided states. */
    state?: string[];
    /**
     * Filters for parts with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /** Filters for parts of the provided type(s). */
    type?: PartType[];
    /**
     * Filters for parts of the provided type(s).
     * @deprecated
     */
    types?: PartType[];
}
/** vistas-update-request-dynamic-vista-parts-vista-items */
export interface VistasUpdateRequestDynamicVistaPartsVistaItems {
    /** Sets the items to the provided items. */
    set?: VistasUpdateRequestDynamicVistaPartsVistaItemsItemValue[];
}
/** vistas-update-request-dynamic-vista-parts-vista-items-item-value */
export interface VistasUpdateRequestDynamicVistaPartsVistaItemsItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    id: string;
}
/** vistas-update-request-dynamic-vista-rev-orgs-vista */
export interface VistasUpdateRequestDynamicVistaRevOrgsVista {
    filter?: VistasUpdateRequestDynamicVistaRevOrgsVistaFilter;
    items?: VistasUpdateRequestDynamicVistaRevOrgsVistaItems;
}
/** vistas-update-request-dynamic-vista-rev-orgs-vista-filter */
export interface VistasUpdateRequestDynamicVistaRevOrgsVistaFilter {
    /** Filters by account. */
    account?: string[];
    /** Filters by creator. */
    created_by?: string[];
    created_date?: DateTimeFilter;
    /**
     * Filters on custom fields. Input will be of the format
     * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
     */
    custom_field_filter?: string[];
    /** Array of domain for Rev organizations to be filtered. */
    domain?: string[];
    /** Environment values to be filtered. */
    environment?: OrgEnvironment[];
    /** Array of external ref for Rev organizations to be filtered. */
    external_ref?: string[];
    /** Array of external ref issuers for Rev organizations to be filtered. */
    external_ref_issuer?: string[];
    /** The field to group the collection by. */
    group_by?: string;
    modified_date?: DateTimeFilter;
    /** Filters by owners. */
    owned_by?: string[];
    /**
     * Filters by owners.
     * @deprecated
     */
    owned_by_ids?: string[];
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** State values to be filtered. */
    state?: OrgState[];
    /**
     * Filters on tags. Input will be of the format (tags=<tag id
     * 1>=<value>&tags=<tag id 2>)
     */
    tags?: string[];
    /** Array of tier for Rev organizations to be filtered. */
    tier?: string[];
    /** Types of Rev organizations to be filtered. */
    type?: RevOrgType[];
}
/** vistas-update-request-dynamic-vista-rev-orgs-vista-items */
export interface VistasUpdateRequestDynamicVistaRevOrgsVistaItems {
    /** Sets the items to the provided items. */
    set?: VistasUpdateRequestDynamicVistaRevOrgsVistaItemsItemValue[];
}
/** vistas-update-request-dynamic-vista-rev-orgs-vista-items-item-value */
export interface VistasUpdateRequestDynamicVistaRevOrgsVistaItemsItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    id: string;
}
/** vistas-update-request-dynamic-vista-works-vista */
export interface VistasUpdateRequestDynamicVistaWorksVista {
    filter?: VistasUpdateRequestDynamicVistaWorksVistaFilter;
    items?: VistasUpdateRequestDynamicVistaWorksVistaItems;
}
/** vistas-update-request-dynamic-vista-works-vista-filter */
export interface VistasUpdateRequestDynamicVistaWorksVistaFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** vistas-update-request-dynamic-vista-works-vista-items */
export interface VistasUpdateRequestDynamicVistaWorksVistaItems {
    /** Sets the items to the provided items. */
    set?: VistasUpdateRequestDynamicVistaWorksVistaItemsItemValue[];
}
/** vistas-update-request-dynamic-vista-works-vista-items-item-value */
export interface VistasUpdateRequestDynamicVistaWorksVistaItemsItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** vistas-update-request-grouped-vista */
export type VistasUpdateRequestGroupedVista = VistasUpdateRequestGroupedVistaWorksVista & {
    /** Type of DevRev object for which the grouped vista is applicable. */
    filter_type: GroupedVistaFilterType;
};
/** vistas-update-request-grouped-vista-works-vista */
export interface VistasUpdateRequestGroupedVistaWorksVista {
    filter?: VistasUpdateRequestGroupedVistaWorksVistaFilter;
    groups?: VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItems;
}
/** vistas-update-request-grouped-vista-works-vista-filter */
export interface VistasUpdateRequestGroupedVistaWorksVistaFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items */
export interface VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItems {
    /** Sets the groups to the provided set. */
    set?: VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItem[];
}
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items-works-vista-group-item */
export type VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItem = (VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemCuratedGroup | VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemDynamicGroup) & {
    /** updated description of the group. */
    description?: string;
    /** updated icon associated with the group in the UI. */
    icon_type?: string;
    /** updated name of the group. */
    name?: string;
    /** Type of works vista group item. */
    type: WorksVistaGroupItemType;
};
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items-works-vista-group-item-curated-group */
export interface VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemCuratedGroup {
    items?: VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemCuratedGroupItems;
}
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items-works-vista-group-item-curated-group-items */
export interface VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemCuratedGroupItems {
    /** Sets the items to the provided items. */
    set?: VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemCuratedGroupItemsItemValue[];
}
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items-works-vista-group-item-curated-group-items-item-value */
export interface VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemCuratedGroupItemsItemValue {
    /**
     * The ID of the item.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items-works-vista-group-item-dynamic-group */
export interface VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemDynamicGroup {
    filter?: VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemDynamicGroupFilter;
}
/** vistas-update-request-grouped-vista-works-vista-works-vista-group-items-works-vista-group-item-dynamic-group-filter */
export interface VistasUpdateRequestGroupedVistaWorksVistaWorksVistaGroupItemsWorksVistaGroupItemDynamicGroupFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** vistas-update-request-members */
export interface VistasUpdateRequestMembers {
    /** Sets the members to the provided members. */
    set?: VistaMemberValue[];
}
/**
 * vistas-update-response
 * The response to updating a vista.
 */
export interface VistasUpdateResponse {
    /** Represents a collection of DevRev objects. */
    vista: Vista;
}
/** Describes the types of watch events present on an object. */
export declare enum WatchEvent {
    Comments = "comments",
    Mentions = "mentions",
    Updates = "updates"
}
/** watchers-get-request */
export interface WatchersGetRequest {
    /**
     * The object's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** watchers-get-response */
export interface WatchersGetResponse {
    /** The events that the requesting user is watching. */
    events: WatchEvent[];
}
/** watchers-list-request */
export interface WatchersListRequest {
    /**
     * The cursor to resume iteration from, otherwise if not provided,
     * then iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The object's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
    /**
     * The maximum number of watchers to return. If not set or `<= 0`,
     * then this defaults to `50`.
     * @format int32
     */
    limit?: number;
}
/** watchers-list-response */
export interface WatchersListResponse {
    /**
     * The cursor that should be used to iterate the next sequence of
     * results, otherwise if not set, then no elements exist after.
     */
    next_cursor?: string;
    /** The list of users set as watchers on the object. */
    users: UserSummary[];
}
/** watchers-update-request */
export interface WatchersUpdateRequest {
    /**
     * The watch events that the users will be updated for on the object.
     * At least one event must be specified.
     */
    events: WatchEvent[];
    /**
     * The object's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
    watchers?: WatchersUpdateRequestWatchers;
}
/** watchers-update-request-watchers */
export interface WatchersUpdateRequestWatchers {
    /**
     * The list of users to add as watchers on the object.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    add?: string[];
    /**
     * The list of users to remove as watchers on the object.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    remove?: string[];
}
/** watchers-update-response */
export type WatchersUpdateResponse = object;
/** webhook */
export type Webhook = AtomBase & {
    /** The event types that the webhook will receive. */
    event_types?: WebhookEventType[];
    /**
     * The secret to use for verifying webhook events.
     * @format byte
     */
    secret: string;
    /** The status of the webhook. */
    status: WebhookStatus;
    /**
     * The client-provided unique key that's associated with the webhook.
     * @format byte
     */
    unique_key?: string;
    /** The URL of the webhook endpoint. */
    url: string;
};
/** webhook-event-request */
export interface WebhookEventRequest {
    article_created?: EventArticleCreated;
    article_deleted?: EventArticleDeleted;
    article_updated?: EventArticleUpdated;
    artifact_created?: EventArtifactCreated;
    artifact_deleted?: EventArtifactDeleted;
    artifact_updated?: EventArtifactUpdated;
    conversation_created?: EventConversationCreated;
    conversation_deleted?: EventConversationDeleted;
    conversation_updated?: EventConversationUpdated;
    dev_user_created?: EventDevUserCreated;
    dev_user_deleted?: EventDevUserDeleted;
    dev_user_updated?: EventDevUserUpdated;
    flow_created?: EventFlowCreated;
    flow_deleted?: EventFlowDeleted;
    flow_updated?: EventFlowUpdated;
    /** The event's ID. */
    id: string;
    /** The event's ID. */
    id_v1?: string;
    link_created?: EventLinkCreated;
    link_deleted?: EventLinkDeleted;
    link_updated?: EventLinkUpdated;
    part_created?: EventPartCreated;
    part_deleted?: EventPartDeleted;
    part_updated?: EventPartUpdated;
    rev_org_created?: EventRevOrgCreated;
    rev_org_deleted?: EventRevOrgDeleted;
    rev_org_updated?: EventRevOrgUpdated;
    rev_user_created?: EventRevUserCreated;
    rev_user_deleted?: EventRevUserDeleted;
    rev_user_updated?: EventRevUserUpdated;
    tag_created?: EventTagCreated;
    tag_deleted?: EventTagDeleted;
    tag_updated?: EventTagUpdated;
    timeline_entry_created?: EventTimelineEntryCreated;
    timeline_entry_deleted?: EventTimelineEntryDeleted;
    timeline_entry_updated?: EventTimelineEntryUpdated;
    /**
     * Timestamp of the webhook's invocation for the event. Note this
     * should be used to protect against replay attacks, where the event
     * should only be processed if the timestamp isn't stale by several
     * seconds.
     * @format date-time
     */
    timestamp?: string;
    /** The event types that the webhook will receive. */
    type?: WebhookEventType;
    /**
     * The unique key that was provided upon the webhook's creation.
     * @format byte
     */
    unique_key?: string;
    verify?: WebhookEventVerify;
    vista_created?: EventVistaCreated;
    vista_deleted?: EventVistaDeleted;
    vista_updated?: EventVistaUpdated;
    webhook_created?: EventWebhookCreated;
    webhook_deleted?: EventWebhookDeleted;
    /**
     * ID of the webhook for the event.
     * @example "don:<partition>:integration:devo/<dev-org-id>:webhook/<webhook-id>"
     */
    webhook_id: string;
    /** ID of the webhook for the event. */
    webhook_id_v1?: string;
    webhook_updated?: EventWebhookUpdated;
    work_created?: EventWorkCreated;
    work_deleted?: EventWorkDeleted;
    work_updated?: EventWorkUpdated;
}
/** webhook-event-response */
export interface WebhookEventResponse {
    /**
     * The challenge from the "verify" request, otherwise this should not
     * be set for other request types.
     * @format byte
     */
    challenge?: string;
}
/** The event types that the webhook will receive. */
export declare enum WebhookEventType {
    ArticleCreated = "article_created",
    ArticleDeleted = "article_deleted",
    ArticleUpdated = "article_updated",
    ArtifactCreated = "artifact_created",
    ArtifactDeleted = "artifact_deleted",
    ArtifactUpdated = "artifact_updated",
    CommandCreated = "command_created",
    CommandDeleted = "command_deleted",
    CommandUpdated = "command_updated",
    ConversationCreated = "conversation_created",
    ConversationDeleted = "conversation_deleted",
    ConversationUpdated = "conversation_updated",
    CustomSchemaFragmentCreated = "custom_schema_fragment_created",
    CustomSchemaFragmentDeleted = "custom_schema_fragment_deleted",
    CustomSchemaFragmentUpdated = "custom_schema_fragment_updated",
    DevUserCreated = "dev_user_created",
    DevUserDeleted = "dev_user_deleted",
    DevUserUpdated = "dev_user_updated",
    FlowCreated = "flow_created",
    FlowDeleted = "flow_deleted",
    FlowUpdated = "flow_updated",
    LinkCreated = "link_created",
    LinkDeleted = "link_deleted",
    LinkUpdated = "link_updated",
    PartCreated = "part_created",
    PartDeleted = "part_deleted",
    PartUpdated = "part_updated",
    RevOrgCreated = "rev_org_created",
    RevOrgDeleted = "rev_org_deleted",
    RevOrgUpdated = "rev_org_updated",
    RevUserCreated = "rev_user_created",
    RevUserDeleted = "rev_user_deleted",
    RevUserUpdated = "rev_user_updated",
    TagCreated = "tag_created",
    TagDeleted = "tag_deleted",
    TagUpdated = "tag_updated",
    TimelineEntryCreated = "timeline_entry_created",
    TimelineEntryDeleted = "timeline_entry_deleted",
    TimelineEntryUpdated = "timeline_entry_updated",
    Verify = "verify",
    VistaCreated = "vista_created",
    VistaDeleted = "vista_deleted",
    VistaUpdated = "vista_updated",
    WebhookCreated = "webhook_created",
    WebhookDeleted = "webhook_deleted",
    WebhookUpdated = "webhook_updated",
    WorkCreated = "work_created",
    WorkDeleted = "work_deleted",
    WorkUpdated = "work_updated"
}
/** webhook-event-verify */
export interface WebhookEventVerify {
    /**
     * The challenge that must be echoed in the response.
     * @format byte
     */
    challenge: string;
}
/** The status of the webhook. */
export declare enum WebhookStatus {
    Active = "active",
    Inactive = "inactive",
    Unverified = "unverified"
}
/** webhook-summary */
export type WebhookSummary = AtomBaseSummary;
/**
 * webhooks-create-request
 * The request to create a new webhook.
 */
export interface WebhooksCreateRequest {
    /** The event types that the webhook endpoint will receive. */
    event_types?: WebhookEventType[];
    /**
     * The secret to use when verifying webhook events. If provided, the
     * secret must be between 8 and 32 bytes (inclusive). If not set, a
     * secret will be automatically generated and provided in the
     * response.
     * @format byte
     */
    secret?: string;
    /**
     * A unique key to associate with the webhook. This key can be used to
     * ensure idempotency of webhook creations within a Dev organization,
     * and will be provided in every webhook event. If set, the value must
     * be non-empty. If provided and another webhook in the Dev
     * organization has the same unique key, then status `409 Conflict`
     * will be returned.
     * @format byte
     */
    unique_key?: string;
    /** The URL of the webhook endpoint. */
    url: string;
}
/**
 * webhooks-create-response
 * The response to creating a new webhook.
 */
export interface WebhooksCreateResponse {
    webhook: Webhook;
}
/**
 * webhooks-delete-request
 * The request to delete a webhook.
 */
export interface WebhooksDeleteRequest {
    /**
     * ID for the webhook.
     * @example "don:<partition>:integration:devo/<dev-org-id>:webhook/<webhook-id>"
     */
    id: string;
}
/**
 * webhooks-delete-response
 * The response to deleting the webhook.
 */
export type WebhooksDeleteResponse = object;
/**
 * webhooks-get-request
 * The request to get a webhook's information.
 */
export interface WebhooksGetRequest {
    /**
     * ID for the webhook.
     * @example "don:<partition>:integration:devo/<dev-org-id>:webhook/<webhook-id>"
     */
    id: string;
}
/**
 * webhooks-get-response
 * The response to getting the information for the webhook.
 */
export interface WebhooksGetResponse {
    webhook: Webhook;
}
/**
 * webhooks-list-request
 * The request to list the webhooks.
 */
export type WebhooksListRequest = object;
/**
 * webhooks-list-response
 * The response to listing the webhooks.
 */
export interface WebhooksListResponse {
    /** The list of webhooks. */
    webhooks: Webhook[];
}
/** The action to update the webhook's status. */
export declare enum WebhooksUpdateAction {
    Activate = "activate",
    Deactivate = "deactivate"
}
/**
 * webhooks-update-request
 * The request to update a webhook.
 */
export interface WebhooksUpdateRequest {
    /** The action to update the webhook's status. */
    action?: WebhooksUpdateAction;
    event_types?: WebhooksUpdateRequestEventTypes;
    /**
     * ID for the webhook.
     * @example "don:<partition>:integration:devo/<dev-org-id>:webhook/<webhook-id>"
     */
    id: string;
    /**
     * If provided, updates the secret that's used when verifying webhook
     * events, which must be between 8 and 32 bytes (inclusive). Otherwise
     * if empty, then a new secret is generated. If the webhook is active,
     * then its status will transition to the 'unverified' state and it
     * won't receive any object events until successfully verified.
     * @format byte
     */
    secret?: string;
    /**
     * The webhook's updated URL. If the webhook is active, then the
     * webhook's status will transition to the 'unverified' state and it
     * won't receive any object events until successfully verified.
     */
    url?: string;
}
/** webhooks-update-request-event-types */
export interface WebhooksUpdateRequestEventTypes {
    /**
     * The event types to add. If a provided event type is already set for
     * the webhook, then nothing is done. Note this is mutually exclusive
     * with 'set'.
     */
    add?: WebhookEventType[];
    /**
     * The event types to remove. If a provided event type isn't set for
     * the webhook, then nothing is done. Note this is mutually exclusive
     * with 'set'.
     */
    remove?: WebhookEventType[];
    /**
     * The updated event types, which will replace the webhook's current
     * event types. Note this is mutually exclusive with 'add' and
     * 'remove'.
     */
    set?: WebhookEventType[];
}
/**
 * webhooks-update-response
 * The response to updating the webhook.
 */
export interface WebhooksUpdateResponse {
    webhook: Webhook;
}
/** window-based-insight */
export type WindowBasedInsight = InsightBase & {
    /**
     * Threshold of delta beyond which it should be considered bad.
     * @format double
     */
    bad_delta_threshold?: number;
    /**
     * Threshold of delta beyond which it should be considered good.
     * @format double
     */
    good_delta_threshold?: number;
};
/** window-based-insight-summary */
export type WindowBasedInsightSummary = InsightBaseSummary;
/** window-based-insight-value */
export type WindowBasedInsightValue = InsightValueBase & {
    /**
     * Previous value of the insight with one week as the window value.
     * @format double
     */
    previous_value_for_one_week?: number;
    /**
     * Value of the insight with one week as the window value.
     * @format double
     */
    value_for_one_week?: number;
};
/** window-based-insight-value-summary */
export type WindowBasedInsightValueSummary = InsightValueBaseSummary;
/** work */
export type Work = (CustomWork | Issue | Opportunity | Project | Task | Ticket) & {
    type: WorkType;
};
/** work-base */
export type WorkBase = AtomBase & {
    /**
     * Timestamp when the work was actually completed.
     * @format date-time
     */
    actual_close_date?: string;
    applies_to_part?: PartSummary;
    /** The artifacts attached to the work item. */
    artifacts?: ArtifactSummary[];
    /** The attached artifacts. */
    attachments?: ArtifactSummary[];
    /** Body of the work object. */
    body?: string;
    /** Custom fields. */
    custom_fields?: object;
    /** Custom schema fragments. */
    custom_schema_fragments?: string[];
    /** Custom schema fragments. */
    custom_schema_fragments_v1?: string;
    /** Links associated with the object. */
    links?: ArchetypeLinkSummary[];
    /** The users that own the work. */
    owned_by: UserSummary[];
    /** Reactions on the object. */
    reactions?: ObjectReaction[];
    /** The object IDs referenced in the body. */
    references?: AtomSummary[];
    /** Users that reported the work. */
    reported_by?: UserSummary[];
    /**
     * Combination of stock and custom schema fragment IDs.
     * @deprecated
     */
    schema_fragment_ids?: string[];
    /** Combination of stock and custom schema fragment IDs. */
    schema_fragment_ids_v1?: string;
    /** Describes the current stage of a work item. */
    stage?: Stage;
    /** State of the object based upon the stage. */
    state?: string;
    /** Stock schema fragment. */
    stock_schema_fragment?: string;
    /** Stock schema fragment. */
    stock_schema_fragment_v1?: string;
    /** Subtype corresponding to the custom type fragment. */
    subtype?: string;
    /** Tags associated with the object. */
    tags?: TagWithValue[];
    /**
     * Timestamp when the work is expected to be complete.
     * @format date-time
     */
    target_close_date?: string;
    /** Title of the work object. */
    title: string;
};
/** work-base-summary */
export type WorkBaseSummary = AtomBaseSummary & {
    /** Title of the work object. */
    title: string;
};
/**
 * work-context
 * Work fields required for recommendation.
 */
export interface WorkContext {
    /**
     * The part that the work applies to.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part?: string;
    /**
     * The part that the work applies to.
     * @deprecated
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part_id?: string;
    /** Body of the work. */
    body?: string;
    /**
     * The users that own the work.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * The users that own the work.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /**
     * List of tag ids.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    /**
     * List of tag ids.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /** Title of the work. */
    title: string;
    type: WorkType;
}
/** work-deflect-base */
export interface WorkDeflectBase {
    /**
     * Confidence score of the deflection recommendation. Range of the
     * confidence must be 0 -> 1.
     * @format float
     */
    confidence: number;
}
/**
 * work-deflect-request
 * Work deflect request.
 */
export interface WorkDeflectRequest {
    /** Work fields required for recommendation. */
    context: WorkContext;
}
/**
 * work-deflect-response
 * Work Deflect response.
 */
export interface WorkDeflectResponse {
    /** The deflection results. */
    results: WorkDeflectResult[];
    /** Version of the deflection model. */
    version?: string;
}
/**
 * work-deflect-result
 * A work deflection result.
 */
export type WorkDeflectResult = WorkDeflectBase & {
    work: WorkSummary;
};
/** work-search-summary */
export type WorkSearchSummary = SearchSummaryBase & {
    work: WorkSummary;
};
/** work-summary */
export type WorkSummary = (CustomWorkSummary | IssueSummary | OpportunitySummary | ProjectSummary | TaskSummary | TicketSummary) & {
    type: WorkType;
};
export declare enum WorkType {
    CustomWork = "custom_work",
    Issue = "issue",
    Opportunity = "opportunity",
    Project = "project",
    Task = "task",
    Ticket = "ticket"
}
/** works-count-request */
export interface WorksCountRequest {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** works-count-response */
export interface WorksCountResponse {
    /**
     * Count of works matching the filter.
     * @format int32
     */
    count: number;
}
/** works-create-request */
export type WorksCreateRequest = (WorksCreateRequestCustomWork | WorksCreateRequestIssue | WorksCreateRequestTask | WorksCreateRequestTicket) & {
    /**
     * The [part](https://devrev.ai/docs/product/parts) that the work
     * applies to. Specifying a part is required when creating tickets and
     * issues.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part?: string;
    /**
     * The part that the work applies to.
     * @deprecated
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part_id?: string;
    /**
     * The IDs of the new artifact items.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifact_ids?: string[];
    /**
     * The IDs of the artifacts to associate with the work item.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    artifacts?: string[];
    /** Body of the work object. */
    body?: string;
    /** The custom schema fragments to use. */
    custom_schema_fragments?: string[];
    /** Links associated with the work item. */
    links?: EmbedLinksCreateRequest[];
    /**
     * The users that own the work.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * The users that own the work.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /**
     * The users that reported the work.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    reported_by?: string[];
    /**
     * The users that reported the work.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    reported_by_ids?: string[];
    /** Sets an object's initial stage. */
    stage?: StageInit;
    /** Tags associated with the work item. */
    tags?: SetTagWithValue[];
    /**
     * Timestamp for when the work is expected to be complete.
     * @format date-time
     */
    target_close_date?: string;
    /** Title of the work object. */
    title: string;
    type: WorkType;
    [key: string]: any;
};
/** works-create-request-custom-work */
export type WorksCreateRequestCustomWork = object;
/** works-create-request-issue */
export interface WorksCreateRequestIssue {
    /**
     * The actual effort, in hours, to complete the issue.
     * @format double
     */
    actual_effort?: number;
    /**
     * The estimated effort, in hours, to complete the issue.
     * @format double
     */
    estimated_effort?: number;
    /** Priority of the work based upon impact and criticality. */
    priority?: IssuePriority;
}
/** works-create-request-task */
export interface WorksCreateRequestTask {
    /**
     * The actual effort, in hours, to complete the issue.
     * @format double
     */
    actual_effort?: number;
    /** Whether the task is embedded in the work. */
    embedded?: boolean;
    /**
     * The estimated effort, in hours, to complete the issue.
     * @format double
     */
    estimated_effort?: number;
    /** Priority of the work based upon impact and criticality. */
    priority?: TaskPriority;
    /**
     * Timestamp when the task was started.
     * @format date-time
     */
    start_date?: string;
}
/** works-create-request-ticket */
export interface WorksCreateRequestTicket {
    /**
     * The Rev organization that the ticket is associated with.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org?: string;
    /**
     * The Rev organization that the ticket is associated with.
     * @deprecated
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string;
    /** Severity of the ticket. */
    severity?: TicketSeverity;
}
/** works-create-response */
export interface WorksCreateResponse {
    work: Work;
}
/** works-delete-request */
export interface WorksDeleteRequest {
    /**
     * The work's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** works-delete-response */
export type WorksDeleteResponse = object;
/** works-export-request */
export interface WorksExportRequest {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /**
     * The number of work items to return. The default is '50', the
     * maximum is '5000'.
     * @format int32
     */
    first?: number;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Fields to sort the work items by and the direction to sort them. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** works-export-response */
export interface WorksExportResponse {
    /** The resulting collection of work items. */
    works: Work[];
}
export declare enum WorksFilterCreatedByOperatorType {
    Any = "any",
    NotAny = "not_any"
}
/** works-filter-issue */
export interface WorksFilterIssue {
    /**
     * Filters for issues with any of the provided priorities.
     * @deprecated
     */
    priorities?: IssuePriority[];
    /** Filters for issues with any of the provided priorities. */
    priority?: IssuePriority[];
    /** Filters for issue with any of the provided subtype. */
    subtype?: string[];
}
export declare enum WorksFilterOwnedByOperatorType {
    Any = "any",
    NotAny = "not_any"
}
export declare enum WorksFilterTagIdsOperatorType {
    All = "all",
    Any = "any",
    Empty = "empty",
    NotAny = "not_any",
    NotEmpty = "not_empty"
}
/** works-filter-task */
export interface WorksFilterTask {
    /** Filter for tasks with any of the provided embedded values. */
    embedded?: boolean[];
    /**
     * Filters for tasks with any of the provided priorities.
     * @deprecated
     */
    priorities?: TaskPriority[];
    /** Filters for tasks with any of the provided priorities. */
    priority?: TaskPriority[];
    /**
     * Filters for tasks which started after the provided timestamp.
     * @format date-time
     */
    start_after_date?: string;
    /**
     * Filters for tasks which started before the provided timestamp.
     * @format date-time
     */
    start_before_date?: string;
}
/** works-filter-ticket */
export interface WorksFilterTicket {
    /**
     * Filters for tickets that are associated with any of the provided
     * Rev organizations.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org?: string[];
    /**
     * Filters for tickets associated to the provided Rev organizations
     * using an operator.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
     */
    rev_org_ids?: string[];
    rev_org_ids_op?: WorksFilterTicketRevOrgIDsOperatorType;
    /**
     * Filters for tickets with any of the provided severities.
     * @deprecated
     */
    severities?: TicketSeverity[];
    /** Filters for tickets with any of the provided severities. */
    severity?: TicketSeverity[];
    /** Filters for ticket with any of the provided subtype. */
    subtype?: string[];
}
export declare enum WorksFilterTicketRevOrgIDsOperatorType {
    Any = "any",
    Empty = "empty",
    NotAny = "not_any",
    NotEmpty = "not_empty"
}
/** works-get-request */
export interface WorksGetRequest {
    /**
     * The work's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
}
/** works-get-response */
export interface WorksGetResponse {
    work: Work;
}
/** works-group */
export interface WorksGroup {
    /** Unique key according to which the items are grouped. */
    key: string;
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The group of works. */
    works: Work[];
}
/** works-group-request */
export interface WorksGroupRequest {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the works by. */
    group_by: string;
    issue?: WorksFilterIssue;
    /**
     * The maximum number of groups to return. If not set, then the
     * default is '10'.
     * @format int32
     */
    limit?: number;
    /**
     * The maximum number of works to return for an individual group. If
     * not set, then the default is '50'.
     * @format int32
     */
    limit_per_group?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Comma-separated fields to sort the works by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** works-group-response */
export interface WorksGroupResponse {
    /** The list of groups. */
    groups: WorksGroup[];
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
}
/** works-list-request */
export interface WorksListRequest {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    issue?: WorksFilterIssue;
    /**
     * The maximum number of works to return. The default is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Fields to sort the works by and the direction to sort them. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** works-list-response */
export interface WorksListResponse {
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The list of works. */
    works: Work[];
}
/** works-suggest-request */
export interface WorksSuggestRequest {
    /**
     * The cursor to resume iteration from. If not provided, then
     * iteration starts from the beginning.
     */
    cursor?: string;
    /**
     * The maximum number of works to return. If not set, then the default
     * is '50'.
     * @format int32
     */
    limit?: number;
    /**
     * The iteration mode to use. If "after", then entries after the provided
     * cursor will be returned, or if no cursor is provided, then from the
     * beginning. If "before", then entries before the provided cursor will be
     * returned, or if no cursor is provided, then from the end. Entries will
     * always be returned in the specified sort-by order.
     */
    mode?: ListMode;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** works-suggest-response */
export interface WorksSuggestResponse {
    /**
     * The cursor used to iterate subsequent results in accordance to the
     * sort order. If not set, then no later elements exist.
     */
    next_cursor?: string;
    /**
     * The cursor used to iterate preceding results in accordance to the
     * sort order. If not set, then no prior elements exist.
     */
    prev_cursor?: string;
    /** The suggested work summaries. */
    works: WorkSummary[];
}
/** works-update-request */
export type WorksUpdateRequest = (WorksUpdateRequestCustomWork | WorksUpdateRequestIssue | WorksUpdateRequestTask | WorksUpdateRequestTicket) & {
    /**
     * Updates the part that the work applies to.
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part?: string;
    /**
     * Updates the part that the work applies to.
     * @deprecated
     * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
     */
    applies_to_part_id?: string;
    artifact_ids?: WorksUpdateRequestArtifactIds;
    artifacts?: WorksUpdateRequestArtifactIds;
    /** Updated body of the work object, or unchanged if not provided. */
    body?: string;
    /** The custom schema fragments to use. */
    custom_schema_fragments?: string[];
    /**
     * The work's ID.
     * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
     */
    id: string;
    owned_by?: WorksUpdateRequestOwnedBy;
    owned_by_ids?: WorksUpdateRequestOwnedByIds;
    reported_by?: WorksUpdateRequestReportedBy;
    reported_by_ids?: WorksUpdateRequestReportedByIds;
    /** Updates an object's stage. */
    stage?: StageUpdate;
    tags?: WorksUpdateRequestTags;
    /**
     * Updates the timestamp for when the work is expected to be complete.
     * @format date-time
     */
    target_close_date?: string;
    /** Updated title of the work object, or unchanged if not provided. */
    title?: string;
    type: WorkType;
    [key: string]: any;
};
/** works-update-request-artifact-ids */
export interface WorksUpdateRequestArtifactIds {
    /**
     * Sets the IDs to the provided artifact IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"]
     */
    set?: string[];
}
/** works-update-request-custom-work */
export type WorksUpdateRequestCustomWork = object;
/** works-update-request-issue */
export interface WorksUpdateRequestIssue {
    /**
     * Updates the actual effort, in hours, to complete the issue.
     * @format double
     */
    actual_effort?: number | null;
    /**
     * Updates the estimated effort, in hours, to complete the issue.
     * @format double
     */
    estimated_effort?: number | null;
    /** Priority of the work based upon impact and criticality. */
    priority?: IssuePriority;
}
/** works-update-request-owned-by */
export interface WorksUpdateRequestOwnedBy {
    /**
     * Sets the owner IDs to the provided user IDs. This must not be
     * empty.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** works-update-request-owned-by-ids */
export interface WorksUpdateRequestOwnedByIds {
    /**
     * Sets the owner IDs to the provided user IDs. This must not be
     * empty.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** works-update-request-reported-by */
export interface WorksUpdateRequestReportedBy {
    /**
     * Sets the users that reported the work to the provided user IDs.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** works-update-request-reported-by-ids */
export interface WorksUpdateRequestReportedByIds {
    /**
     * Sets the reportedBy IDs to the provided user IDs.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    set?: string[];
}
/** works-update-request-tags */
export interface WorksUpdateRequestTags {
    /** Sets the provided tags on the work item. */
    set?: SetTagWithValue[];
}
/** works-update-request-task */
export interface WorksUpdateRequestTask {
    /**
     * Updates the actual effort, in hours, to complete the task.
     * @format double
     */
    actual_effort?: number | null;
    /** Whether the task is embedded in the work. */
    embedded?: boolean;
    /**
     * Updates the estimated effort, in hours, to complete the task.
     * @format double
     */
    estimated_effort?: number | null;
    /** Priority of the work based upon impact and criticality. */
    priority?: TaskPriority;
    /**
     * Timestamp when the task was started.
     * @format date-time
     */
    start_date?: string;
}
/** works-update-request-ticket */
export interface WorksUpdateRequestTicket {
    /**
     * Updates the Rev organization that the ticket is associated with.
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org?: string | null;
    /**
     * Updates the Rev organization that the ticket is associated with.
     * @deprecated
     * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
     */
    rev_org_id?: string | null;
    /** Severity of the ticket. */
    severity?: TicketSeverity;
}
/** works-update-response */
export interface WorksUpdateResponse {
    work: Work;
}
/**
 * works-vista-group-item
 * Represents a nested works vista group object.
 */
export type WorksVistaGroupItem = GroupBase & (WorksVistaGroupItemCuratedGroup | WorksVistaGroupItemDynamicGroup) & {
    /** Type of works vista group item. */
    type: WorksVistaGroupItemType;
};
/** works-vista-group-item-curated-group */
export interface WorksVistaGroupItemCuratedGroup {
    /** Static list of work items. */
    items?: WorkSummary[];
}
/** works-vista-group-item-dynamic-group */
export interface WorksVistaGroupItemDynamicGroup {
    filter: WorksVistaGroupItemDynamicGroupFilter;
}
/** works-vista-group-item-dynamic-group-filter */
export interface WorksVistaGroupItemDynamicGroupFilter {
    /**
     * Filters for work actual_close after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_after_date?: string;
    /**
     * Filters for work actual_close before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    actual_close_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    actual_close_date?: DateFilter;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    ancestor_part_ids?: string[];
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     */
    ancestor_part_ids_v1?: string;
    /**
     * Filters for work which have one of the parts present as its
     * ancestor part or primary part.
     */
    ancestor_part_v1?: string;
    /**
     * Filters for work belonging to any of the provided parts.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part?: string[];
    /**
     * Filters for work belonging to any of the provided parts.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
     */
    applies_to_part_ids?: string[];
    /** Filters for work belonging to any of the provided parts. */
    applies_to_part_ids_v1?: string;
    /** Filters for work belonging to any of the provided parts. */
    applies_to_part_v1?: string;
    /**
     * Filters for work created after the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_after_date?: string;
    /**
     * Filters for work created before the timestamp provided.
     * @deprecated
     * @format date-time
     */
    created_before_date?: string;
    /**
     * Filters for work created by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by?: string[];
    /**
     * Filters for work created by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    created_by_ids?: string[];
    /** Filters for work created by any of these users. */
    created_by_ids_v1?: string;
    created_by_op?: WorksFilterCreatedByOperatorType;
    /** Filters for work created by any of these users. */
    created_by_v1?: string;
    /** Provides ways to specify date ranges on objects. */
    created_date?: DateFilter;
    /**
     * Filters for work excluding the provided work IDs.
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude?: string[];
    /** Filters for work excluding the provided work IDs. */
    exclude_v1?: string;
    /**
     * Filters for work excluding the provided work IDs.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
     */
    exclude_work_ids?: string[];
    /** Filters for work excluding the provided work IDs. */
    exclude_work_ids_v1?: string;
    /** Provides ways to specify date ranges on objects. */
    expected_close_date?: DateFilter;
    /** The field to group the collection by. */
    group_by?: string;
    issue?: WorksFilterIssue;
    /**
     * Filters for work modified after the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_after_date?: string;
    /**
     * Filters for work modified before the provided timestamp.
     * @deprecated
     * @format date-time
     */
    modified_before_date?: string;
    /** Provides ways to specify date ranges on objects. */
    modified_date?: DateFilter;
    /**
     * Filters for work owned by any of these users.
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by?: string[];
    /**
     * Filters for work owned by any of these users.
     * @deprecated
     * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
     */
    owned_by_ids?: string[];
    /** Filters for work owned by any of these users. */
    owned_by_ids_v1?: string;
    owned_by_op?: WorksFilterOwnedByOperatorType;
    /** Filters for work owned by any of these users. */
    owned_by_v1?: string;
    /** Comma-separated fields to sort the objects by. */
    sort_by?: string[];
    /** The filter for stages. */
    stage?: StageFilter;
    /** Filters for work for the provided stage names. */
    stage_names?: string[];
    /** Filters for work with any of the provided states. */
    state?: string[];
    /**
     * Filters for work with any of the provided tags.
     * @deprecated
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tag_ids?: string[];
    tag_ids_op?: WorksFilterTagIdsOperatorType;
    /** Filters for work with any of the provided tags. */
    tag_ids_v1?: string;
    /**
     * Filters for work with any of the provided tags.
     * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
     */
    tags?: string[];
    /** Filters for work with any of the provided tags. */
    tags_v1?: string;
    /**
     * Filters for work whose target close date is after the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_after_date?: string;
    /**
     * Filters for work whose target close date is before the provided
     * timestamp.
     * @deprecated
     * @format date-time
     */
    target_close_before_date?: string;
    target_close_date?: DateTimeFilter;
    task?: WorksFilterTask;
    ticket?: WorksFilterTicket;
    /** Filters for work of the provided types. */
    type?: WorkType[];
    /**
     * Filters for work of the provided types.
     * @deprecated
     */
    types?: WorkType[];
}
/** Type of works vista group item. */
export declare enum WorksVistaGroupItemType {
    Curated = "curated",
    Dynamic = "dynamic"
}
import { AxiosInstance, AxiosRequestConfig, AxiosResponse, ResponseType } from 'axios';
export type QueryParamsType = Record<string | number, any>;
export interface FullRequestParams extends Omit<AxiosRequestConfig, 'data' | 'params' | 'url' | 'responseType'> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseType;
    /** request body */
    body?: unknown;
}
export type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>;
export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, 'data' | 'cancelToken'> {
    securityWorker?: (securityData: SecurityDataType | null) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;
    secure?: boolean;
    format?: ResponseType;
}
export declare enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded",
    Text = "text/plain"
}
export declare class HttpClient<SecurityDataType = unknown> {
    instance: AxiosInstance;
    private securityData;
    private securityWorker?;
    private secure?;
    private format?;
    constructor({ securityWorker, secure, format, ...axiosConfig }?: ApiConfig<SecurityDataType>);
    setSecurityData: (data: SecurityDataType | null) => void;
    protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig;
    protected stringifyFormItem(formItem: unknown): string;
    protected createFormData(input: Record<string, unknown>): FormData;
    request: <T = any, _E = any>({ secure, path, type, query, format, body, ...params }: FullRequestParams) => Promise<AxiosResponse<T, any>>;
}
/**
 * @title DevRev REST API
 * @version 1.0.0
 * @baseUrl {protocol}://{hostname}
 *
 * DevRev's REST API.
 */
export declare class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    internal: {
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Gets the count of Accounts matching given filter.
         *
         * @tags accounts
         * @name AccountsCount
         * @request GET:/internal/accounts.count
         * @secure
         */
        accountsCount: (query?: {
            /** Filters by creator. */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /** Array of domain for Accounts to be filtered. */
            domains?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters by owners. */
            owned_by?: string[];
            /**
             * Filters on tags. Input will be of the format (tags=<tag id
             * 1>=<value>&tags=<tag id 2>)
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<AccountsCountResponse, any>>;
        /**
         * @description Gets the count of Accounts matching given filter.
         *
         * @tags accounts
         * @name AccountsCountPost
         * @request POST:/internal/accounts.count
         * @secure
         */
        accountsCountPost: (data: AccountsCountRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsCountResponse, any>>;
        /**
         * @description Creates a Account.
         *
         * @tags accounts
         * @name AccountsCreate
         * @request POST:/internal/accounts.create
         * @secure
         */
        accountsCreate: (data: AccountsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsCreateResponse, any>>;
        /**
         * @description Deletes the Account.
         *
         * @tags accounts
         * @name AccountsDelete
         * @request POST:/internal/accounts.delete
         * @secure
         */
        accountsDelete: (data: AccountsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Retrieves the Account's information.
         *
         * @tags accounts
         * @name AccountsGet
         * @request GET:/internal/accounts.get
         * @secure
         */
        accountsGet: (query: {
            /** The ID of the required Account. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<AccountsGetResponse, any>>;
        /**
         * @description Retrieves the Account's information.
         *
         * @tags accounts
         * @name AccountsGetPost
         * @request POST:/internal/accounts.get
         * @secure
         */
        accountsGetPost: (data: AccountsGetRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsGetResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Lists collections of accounts by groups.
         *
         * @tags accounts
         * @name AccountsGroup
         * @request GET:/internal/accounts.group
         * @secure
         */
        accountsGroup: (query: {
            /** The field to group the accounts by. */
            group_by: string;
            /** Filters by creator. */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /** Array of domain for Accounts to be filtered. */
            domains?: string[];
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of accounts to return for an individual group. If
             * not set, then the default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters by owners. */
            owned_by?: string[];
            /** Fields to sort the accounts by. */
            sort_by?: string[];
            /**
             * Filters on tags. Input will be of the format (tags=<tag id
             * 1>=<value>&tags=<tag id 2>)
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<AccountsGroupResponse, any>>;
        /**
         * @description Lists collections of accounts by groups.
         *
         * @tags accounts
         * @name AccountsGroupPost
         * @request POST:/internal/accounts.group
         * @secure
         */
        accountsGroupPost: (data: AccountsGroupRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsGroupResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Gets the list of Accounts' information belonging to the authenticated user's Dev Organization.
         *
         * @tags accounts
         * @name AccountsList
         * @request GET:/internal/accounts.list
         * @secure
         */
        accountsList: (query?: {
            /** Filters by creator. */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /** Array of domain for Accounts to be filtered. */
            domains?: string[];
            /**
             * The maximum number of Accounts to be retrieved per page.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters by owners. */
            owned_by?: string[];
            /** Fields to sort the Accounts by and the direction to sort them. */
            sort_by?: string[];
            /**
             * Filters on tags. Input will be of the format (tags=<tag id
             * 1>=<value>&tags=<tag id 2>)
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<AccountsListResponse, any>>;
        /**
         * @description Gets the list of Accounts' information belonging to the authenticated user's Dev Organization.
         *
         * @tags accounts
         * @name AccountsListPost
         * @request POST:/internal/accounts.list
         * @secure
         */
        accountsListPost: (data: AccountsListRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsListResponse, any>>;
        /**
         * @description Merges the Account.
         *
         * @tags accounts
         * @name AccountsMerge
         * @request POST:/internal/accounts.merge
         * @secure
         */
        accountsMerge: (data: AccountsMergeRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsMergeResponse, any>>;
        /**
         * @description Updates the Account's information.
         *
         * @tags accounts
         * @name AccountsUpdate
         * @request POST:/internal/accounts.update
         * @secure
         */
        accountsUpdate: (data: AccountsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<AccountsUpdateResponse, any>>;
        /**
         * @description Creates an addon rule
         *
         * @tags commerce
         * @name AddonRulesCreate
         * @request POST:/internal/addon-rules.create
         * @secure
         */
        addonRulesCreate: (data: AddonRulesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<AddonRulesCreateResponse, any>>;
        /**
         * @description Deletes an addon rule object.
         *
         * @tags commerce
         * @name AddonRulesDelete
         * @request POST:/internal/addon-rules.delete
         * @secure
         */
        addonRulesDelete: (data: AddonRulesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets an addon rule
         *
         * @tags commerce
         * @name AddonRulesGet
         * @request GET:/internal/addon-rules.get
         * @secure
         */
        addonRulesGet: (query: {
            /** The addon rule object's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<AddonRulesGetResponse, any>>;
        /**
         * @description Gets an addon rule
         *
         * @tags commerce
         * @name AddonRulesGetPost
         * @request POST:/internal/addon-rules.get
         * @secure
         */
        addonRulesGetPost: (data: AddonRulesGetRequest, params?: RequestParams) => Promise<AxiosResponse<AddonRulesGetResponse, any>>;
        /**
         * @description Gets the addon rule objects based on the given filters.
         *
         * @tags commerce
         * @name AddonRulesList
         * @request GET:/internal/addon-rules.list
         * @secure
         */
        addonRulesList: (query?: {
            /** The list of addon SKU DONs for which addon rulesare to be aggregated. */
            addon_ids?: string[];
            /** The associativity for which the addon rules need to be aggregated */
            associativity?: AddonRulesAssociativity[];
            /** The list of addon rule DONs which are to be aggregated. */
            ids?: string[];
            /**
             * The list of product DONs for which addon rulesare to be aggregated.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            product_ids?: string[];
            /**
             * List of fields to sort the addon rules, by and how to sort them.
             * Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
            /**
             * The list of subscription SKU DONs for which addon rulesare to be
             * aggregated.
             */
            subscription_sku_ids?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<AddonRulesListResponse, any>>;
        /**
         * @description Gets the addon rule objects based on the given filters.
         *
         * @tags commerce
         * @name AddonRulesListPost
         * @request POST:/internal/addon-rules.list
         * @secure
         */
        addonRulesListPost: (data: AddonRulesListRequest, params?: RequestParams) => Promise<AxiosResponse<AddonRulesListResponse, any>>;
        /**
         * @description Updates an addon rule
         *
         * @tags commerce
         * @name AddonRulesUpdate
         * @request POST:/internal/addon-rules.update
         * @secure
         */
        addonRulesUpdate: (data: AddonRulesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<AddonRulesUpdateResponse, any>>;
        /**
         * @description Creates multiple articles.
         *
         * @tags articles
         * @name CreateArticles
         * @request POST:/internal/articles.bulk.create
         * @secure
         */
        createArticles: (data: ArticlesBulkCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ArticlesBulkCreateResponse, any>>;
        /**
         * @description Creates an article.
         *
         * @tags articles
         * @name CreateArticle
         * @request POST:/internal/articles.create
         * @secure
         */
        createArticle: (data: ArticlesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ArticlesCreateResponse, any>>;
        /**
         * @description Deletes an article.
         *
         * @tags articles
         * @name DeleteArticle
         * @request POST:/internal/articles.delete
         * @secure
         */
        deleteArticle: (data: ArticlesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets an article.
         *
         * @tags articles
         * @name GetArticle
         * @request GET:/internal/articles.get
         * @secure
         */
        getArticle: (query: {
            /** The ID of the required article. */
            article_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ArticlesGetResponse, any>>;
        /**
         * @description Gets an article.
         *
         * @tags articles
         * @name GetArticlePost
         * @request POST:/internal/articles.get
         * @secure
         */
        getArticlePost: (data: ArticlesGetRequest, params?: RequestParams) => Promise<AxiosResponse<ArticlesGetResponse, any>>;
        /**
         * @description Lists a collection of articles.
         *
         * @tags articles
         * @name ListArticles
         * @request GET:/internal/articles.list
         * @secure
         */
        listArticles: (query?: {
            /** Filters for access level of the articles. */
            access_level?: AccessLevel[];
            /**
             * Filters for article belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_parts?: string[];
            /**
             * Filters for articles authored by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            authored_by?: string[];
            /**
             * Filters for articles created after the timestamp provided.
             * @format date-time
             */
            created_after_date?: string;
            /**
             * Filters for articles created before the timestamp provided.
             * @format date-time
             */
            created_before_date?: string;
            /**
             * Filters for articles created by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by?: string[];
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of articles to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for articles owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for articles published after the timestamp provided.
             * @format date-time
             */
            published_after_date?: string;
            /**
             * Filters for articles published before the timestamp provided.
             * @format date-time
             */
            published_before_date?: string;
            /** Filters for status of the articles. */
            status?: ArticleStatus[];
            /**
             * Filters for article with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ArticlesListResponse, any>>;
        /**
         * @description Lists a collection of articles.
         *
         * @tags articles
         * @name ListArticlesPost
         * @request POST:/internal/articles.list
         * @secure
         */
        listArticlesPost: (data: ArticlesListRequest, params?: RequestParams) => Promise<AxiosResponse<ArticlesListResponse, any>>;
        /**
         * @description Updates an article.
         *
         * @tags articles
         * @name UpdateArticle
         * @request POST:/internal/articles.update
         * @secure
         */
        updateArticle: (data: ArticlesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<ArticlesUpdateResponse, any>>;
        /**
         * @description Gets the requested artifact's information.
         *
         * @tags artifacts
         * @name ArtifactsGet
         * @request GET:/internal/artifacts.get
         * @secure
         */
        artifactsGet: (query: {
            /**
             * The requested artifact's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ArtifactsGetResponse, any>>;
        /**
         * @description Gets the requested artifact's information.
         *
         * @tags artifacts
         * @name ArtifactsGetPost
         * @request POST:/internal/artifacts.get
         * @secure
         */
        artifactsGetPost: (data: ArtifactsGetRequest, params?: RequestParams) => Promise<AxiosResponse<ArtifactsGetResponse, any>>;
        /**
         * @description List the artifacts attached to an object.
         *
         * @tags artifacts
         * @name ArtifactsList
         * @request GET:/internal/artifacts.list
         * @secure
         */
        artifactsList: (query: {
            /** The ID of the object to filter artifacts. */
            parent_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ArtifactsListResponse, any>>;
        /**
         * @description List the artifacts attached to an object.
         *
         * @tags artifacts
         * @name ArtifactsListPost
         * @request POST:/internal/artifacts.list
         * @secure
         */
        artifactsListPost: (data: ArtifactsListRequest, params?: RequestParams) => Promise<AxiosResponse<ArtifactsListResponse, any>>;
        /**
         * @description Gets the download URL for the artifact.
         *
         * @tags artifacts
         * @name ArtifactsLocate
         * @request GET:/internal/artifacts.locate
         * @secure
         */
        artifactsLocate: (query: {
            /**
             * The ID of the artifact to get the URL for.
             * @example "don:<partition>:core:devo/<dev-org-id>:artifact/<artifact-id>"
             */
            id: string;
            /**
             * The required variant of the file. By default, it returns the original
             * file.
             */
            variant?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ArtifactsLocateResponse, any>>;
        /**
         * @description Gets the download URL for the artifact.
         *
         * @tags artifacts
         * @name ArtifactsLocatePost
         * @request POST:/internal/artifacts.locate
         * @secure
         */
        artifactsLocatePost: (data: ArtifactsLocateRequest, params?: RequestParams) => Promise<AxiosResponse<ArtifactsLocateResponse, any>>;
        /**
         * @description Creates an artifact and generates an upload URL for its data.
         *
         * @tags artifacts
         * @name ArtifactsPrepare
         * @request POST:/internal/artifacts.prepare
         * @secure
         */
        artifactsPrepare: (data: ArtifactsPrepareRequest, params?: RequestParams) => Promise<AxiosResponse<ArtifactsPrepareResponse, any>>;
        /**
         * @description Creates a JWT corresponding to the requested token type for the authenticated user.
         *
         * @tags auth-tokens
         * @name AuthTokensCreate
         * @request POST:/internal/auth-tokens.create
         * @secure
         */
        authTokensCreate: (data: AuthTokensCreateRequest, params?: RequestParams) => Promise<AxiosResponse<AuthTokensCreateResponse, any>>;
        /**
         * @description Revokes the token that matches the given token ID issued under the given Dev organization.
         *
         * @tags auth-tokens
         * @name AuthTokensDelete
         * @request POST:/internal/auth-tokens.delete
         * @secure
         */
        authTokensDelete: (data: AuthTokensDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets the token metadata corresponding to the given token ID under the given Dev organization.
         *
         * @tags auth-tokens
         * @name AuthTokensGet
         * @request GET:/internal/auth-tokens.get
         * @secure
         */
        authTokensGet: (query: {
            /** The unique identifier of the token under a given Dev organization. */
            token_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<AuthTokensGetResponse, any>>;
        /**
         * @description Gets the token metadata corresponding to the given token ID under the given Dev organization.
         *
         * @tags auth-tokens
         * @name AuthTokensGetPost
         * @request POST:/internal/auth-tokens.get
         * @secure
         */
        authTokensGetPost: (data: AuthTokensGetRequest, params?: RequestParams) => Promise<AxiosResponse<AuthTokensGetResponse, any>>;
        /**
         * @description Gets the token metadata for all the tokens corresponding to the given token type issued for a given subject.
         *
         * @tags auth-tokens
         * @name AuthTokensList
         * @request GET:/internal/auth-tokens.list
         * @secure
         */
        authTokensList: (query?: {
            /**
             * An identifier that represents the application, which requested the
             * token. Only relevant for application access tokens.
             */
            client_id?: string;
            /**
             * The type of the requested token. If no value is specified, the
             * response will include tokens of all the types.
             */
            requested_token_type?: AuthTokenRequestedTokenType;
            /**
             * The subject associated with the token. In the absence of this
             * parameter, the ID of the authenticated entity is treated as the
             * subject.
             */
            subject?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<AuthTokensListResponse, any>>;
        /**
         * @description Gets the token metadata for all the tokens corresponding to the given token type issued for a given subject.
         *
         * @tags auth-tokens
         * @name AuthTokensListPost
         * @request POST:/internal/auth-tokens.list
         * @secure
         */
        authTokensListPost: (data: AuthTokensListRequest, params?: RequestParams) => Promise<AxiosResponse<AuthTokensListResponse, any>>;
        /**
         * @description Revokes all the tokens that matches the given token type created by the authenticated user.
         *
         * @tags auth-tokens
         * @name AuthTokensSelfDelete
         * @request POST:/internal/auth-tokens.self.delete
         * @secure
         */
        authTokensSelfDelete: (data: AuthTokensSelfDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Updates token metadata of a token issued under a given Dev organization.
         *
         * @tags auth-tokens
         * @name AuthTokensUpdate
         * @request POST:/internal/auth-tokens.update
         * @secure
         */
        authTokensUpdate: (data: AuthTokensUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<AuthTokensUpdateResponse, any>>;
        /**
         * @description Performs a batch of operations.
         *
         * @name BatchApply
         * @request POST:/internal/batch.apply
         * @secure
         */
        batchApply: (data: BatchApplyRequest, params?: RequestParams) => Promise<AxiosResponse<BatchApplyResponse, any>>;
        /**
         * @description Creates a command.
         *
         * @tags command
         * @name CommandsCreate
         * @request POST:/internal/commands.create
         * @secure
         */
        commandsCreate: (data: CommandCreateRequest, params?: RequestParams) => Promise<AxiosResponse<CommandCreateResponse, any>>;
        /**
         * @description Deletes a command.
         *
         * @tags command
         * @name CommandsDelete
         * @request POST:/internal/commands.delete
         * @secure
         */
        commandsDelete: (data: CommandDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Executes a command.
         *
         * @tags command
         * @name CommandsExecute
         * @request POST:/internal/commands.execute
         * @secure
         */
        commandsExecute: (data: CommandExecuteRequest, params?: RequestParams) => Promise<AxiosResponse<CommandExecuteResponse, any>>;
        /**
         * @description Gets a command.
         *
         * @tags command
         * @name CommandsGet
         * @request GET:/internal/commands.get
         * @secure
         */
        commandsGet: (query: {
            /** The command's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<CommandGetResponse, any>>;
        /**
         * @description Gets a command.
         *
         * @tags command
         * @name CommandsGetPost
         * @request POST:/internal/commands.get
         * @secure
         */
        commandsGetPost: (data: CommandGetRequest, params?: RequestParams) => Promise<AxiosResponse<CommandGetResponse, any>>;
        /**
         * @description Lists commands for a Dev organization.
         *
         * @tags command
         * @name CommandsList
         * @request GET:/internal/commands.list
         * @secure
         */
        commandsList: (query?: {
            /** The cursor to begin iteration from. */
            cursor?: string;
            /** List of fields to sort the commands items by and how to sort them. */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<CommandsListResponse, any>>;
        /**
         * @description Lists commands for a Dev organization.
         *
         * @tags command
         * @name CommandsListPost
         * @request POST:/internal/commands.list
         * @secure
         */
        commandsListPost: (data: CommandsListRequest, params?: RequestParams) => Promise<AxiosResponse<CommandsListResponse, any>>;
        /**
         * @description Updates a command.
         *
         * @tags command
         * @name CommandsUpdate
         * @request POST:/internal/commands.update
         * @secure
         */
        commandsUpdate: (data: CommandUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<CommandUpdateResponse, any>>;
        /**
         * @description Lists recommended objects, which can assist the conversation.
         *
         * @tags recommendations
         * @name ConversationAssist
         * @request GET:/internal/conversations.assist
         * @secure
         */
        conversationAssist: (query: {
            /** ID of the conversation for which assistance is requested. */
            id: string;
            /** List of requested objects. */
            requested_objects: ConversationAssistRequestedObject[];
        }, params?: RequestParams) => Promise<AxiosResponse<ConversationAssistResponse, any>>;
        /**
         * @description Lists recommended objects, which can assist the conversation.
         *
         * @tags recommendations
         * @name ConversationAssistPost
         * @request POST:/internal/conversations.assist
         * @secure
         */
        conversationAssistPost: (data: ConversationAssistRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationAssistResponse, any>>;
        /**
         * @description Get count of conversations matching given filter.
         *
         * @tags conversations
         * @name ConversationsCount
         * @request GET:/internal/conversations.count
         * @secure
         */
        conversationsCount: (query?: {
            /**
             * Filters for conversations belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_parts?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * Filters for conversations where these users are participants.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            members?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * Filters for conversations owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for conversations that are associated with any of the
             * provided Rev organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /** Filters for conversations with any of the provided source channels. */
            source_channels?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for conversations with any of the provided states. */
            state?: string[];
            /**
             * Filters for conversations with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ConversationsCountResponse, any>>;
        /**
         * @description Get count of conversations matching given filter.
         *
         * @tags conversations
         * @name ConversationsCountPost
         * @request POST:/internal/conversations.count
         * @secure
         */
        conversationsCountPost: (data: ConversationsCountRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsCountResponse, any>>;
        /**
         * @description Creates a conversation.
         *
         * @tags conversations
         * @name ConversationsCreate
         * @request POST:/internal/conversations.create
         * @secure
         */
        conversationsCreate: (data: ConversationsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsCreateResponse, any>>;
        /**
         * @description Deletes the requested conversation.
         *
         * @tags conversations
         * @name ConversationsDelete
         * @request POST:/internal/conversations.delete
         * @secure
         */
        conversationsDelete: (data: ConversationsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Exports a collection of conversation items.
         *
         * @tags conversations
         * @name ConversationsExport
         * @request GET:/internal/conversations.export
         * @secure
         */
        conversationsExport: (query?: {
            /**
             * Filters for conversations belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_parts?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The number of conversation items to return. The default is '50', the
             * maximum is '5000'.
             * @format int32
             */
            first?: number;
            /**
             * Filters for conversations where these users are participants.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            members?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * Filters for conversations owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for conversations that are associated with any of the
             * provided Rev organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /**
             * Fields to sort the conversation items by and the direction to sort
             * them.
             */
            sort_by?: string[];
            /** Filters for conversations with any of the provided source channels. */
            source_channels?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for conversations with any of the provided states. */
            state?: string[];
            /**
             * Filters for conversations with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ConversationsExportResponse, any>>;
        /**
         * @description Exports a collection of conversation items.
         *
         * @tags conversations
         * @name ConversationsExportPost
         * @request POST:/internal/conversations.export
         * @secure
         */
        conversationsExportPost: (data: ConversationsExportRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsExportResponse, any>>;
        /**
         * @description Gets the requested conversation's information.
         *
         * @tags conversations
         * @name ConversationsGet
         * @request GET:/internal/conversations.get
         * @secure
         */
        conversationsGet: (query: {
            /** The requested conversation's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ConversationsGetResponse, any>>;
        /**
         * @description Gets the requested conversation's information.
         *
         * @tags conversations
         * @name ConversationsGetPost
         * @request POST:/internal/conversations.get
         * @secure
         */
        conversationsGetPost: (data: ConversationsGetRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsGetResponse, any>>;
        /**
         * @description Lists collections of conversations by groups.
         *
         * @tags conversations
         * @name ConversationsGroup
         * @request GET:/internal/conversations.group
         * @secure
         */
        conversationsGroup: (query: {
            /** The field to group the conversations by. */
            group_by: string;
            /**
             * Filters for conversations belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_parts?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of conversations to return for an individual
             * group. The default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * Filters for conversations where these users are participants.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            members?: string[];
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * Filters for conversations owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for conversations that are associated with any of the
             * provided Rev organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /** Comma-separated fields to sort the conversations by. */
            sort_by?: string[];
            /** Filters for conversations with any of the provided source channels. */
            source_channels?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for conversations with any of the provided states. */
            state?: string[];
            /**
             * Filters for conversations with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ConversationsGroupResponse, any>>;
        /**
         * @description Lists collections of conversations by groups.
         *
         * @tags conversations
         * @name ConversationsGroupPost
         * @request POST:/internal/conversations.group
         * @secure
         */
        conversationsGroupPost: (data: ConversationsGroupRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsGroupResponse, any>>;
        /**
         * @description Lists the available conversations.
         *
         * @tags conversations
         * @name ConversationsList
         * @request GET:/internal/conversations.list
         * @secure
         */
        conversationsList: (query?: {
            /**
             * Filters for conversations belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_parts?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of conversations to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * Filters for conversations where these users are participants.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            members?: string[];
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * Filters for conversations owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for conversations that are associated with any of the
             * provided Rev organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /** Fields to sort the conversations by and the direction to sort them. */
            sort_by?: string[];
            /** Filters for conversations with any of the provided source channels. */
            source_channels?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for conversations with any of the provided states. */
            state?: string[];
            /**
             * Filters for conversations with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ConversationsListResponse, any>>;
        /**
         * @description Lists the available conversations.
         *
         * @tags conversations
         * @name ConversationsListPost
         * @request POST:/internal/conversations.list
         * @secure
         */
        conversationsListPost: (data: ConversationsListRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsListResponse, any>>;
        /**
         * @description Updates the requested conversation.
         *
         * @tags conversations
         * @name ConversationsUpdate
         * @request POST:/internal/conversations.update
         * @secure
         */
        conversationsUpdate: (data: ConversationsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<ConversationsUpdateResponse, any>>;
        /**
         * @description Applies a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsApply
         * @request POST:/internal/credit-coupons.apply
         * @secure
         */
        creditCouponsApply: (data: CreditCouponsApplyRequest, params?: RequestParams) => Promise<AxiosResponse<CreditCouponsApplyResponse, any>>;
        /**
         * @description Creates a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsCreate
         * @request POST:/internal/credit-coupons.create
         * @secure
         */
        creditCouponsCreate: (data: CreditCouponsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<CreditCouponsCreateResponse, any>>;
        /**
         * @description Deletes a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsDelete
         * @request POST:/internal/credit-coupons.delete
         * @secure
         */
        creditCouponsDelete: (data: CreditCouponsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsGet
         * @request GET:/internal/credit-coupons.get
         * @secure
         */
        creditCouponsGet: (query: {
            /** The coupon's code. */
            coupon_code: string;
        }, params?: RequestParams) => Promise<AxiosResponse<CreditCouponsGetResponse, any>>;
        /**
         * @description Gets a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsGetPost
         * @request POST:/internal/credit-coupons.get
         * @secure
         */
        creditCouponsGetPost: (data: CreditCouponsGetRequest, params?: RequestParams) => Promise<AxiosResponse<CreditCouponsGetResponse, any>>;
        /**
         * @description Updates a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsUpdate
         * @request POST:/internal/credit-coupons.update
         * @secure
         */
        creditCouponsUpdate: (data: CreditCouponsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<CreditCouponsUpdateResponse, any>>;
        /**
         * @description Validates a credit coupon object.
         *
         * @tags commerce
         * @name CreditCouponsValidate
         * @request POST:/internal/credit-coupons.validate
         * @secure
         */
        creditCouponsValidate: (data: CreditCouponsValidateRequest, params?: RequestParams) => Promise<AxiosResponse<CreditCouponsValidateResponse, any>>;
        /**
         * @description Creates a credit object.
         *
         * @tags commerce
         * @name CreditsCreate
         * @request POST:/internal/credits.create
         * @secure
         */
        creditsCreate: (data: CreditsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<CreditsCreateResponse, any>>;
        /**
         * @description Deletes a credit object.
         *
         * @tags commerce
         * @name CreditsDelete
         * @request POST:/internal/credits.delete
         * @secure
         */
        creditsDelete: (data: CreditsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a credit object.
         *
         * @tags commerce
         * @name CreditsGet
         * @request GET:/internal/credits.get
         * @secure
         */
        creditsGet: (query: {
            /** The credit object's DON */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<CreditsGetResponse, any>>;
        /**
         * @description Gets a credit object.
         *
         * @tags commerce
         * @name CreditsGetPost
         * @request POST:/internal/credits.get
         * @secure
         */
        creditsGetPost: (data: CreditsGetRequest, params?: RequestParams) => Promise<AxiosResponse<CreditsGetResponse, any>>;
        /**
         * @description Gets the credit objects based on the given filters.
         *
         * @tags commerce
         * @name CreditsList
         * @request GET:/internal/credits.list
         * @secure
         */
        creditsList: (query?: {
            /**
             * Filter items which have expiry date after the timestamp provided.
             * @format date-time
             */
            after_expiry_date?: string;
            /**
             * Filter items which have expiry date before the timestamp provided.
             * @format date-time
             */
            before_expiry_date?: string;
            /** The list of credit object DONs which are to be aggregated. */
            ids?: string[];
            /**
             * The list of rev org DONs which are to be aggregated.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org_ids?: string[];
            /**
             * List of fields to sort the credit objects, by and how to sort them.
             * Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
            /** The list of status values which are to be aggregated. */
            statuses?: CreditStatus[];
        }, params?: RequestParams) => Promise<AxiosResponse<CreditsListResponse, any>>;
        /**
         * @description Gets the credit objects based on the given filters.
         *
         * @tags commerce
         * @name CreditsListPost
         * @request POST:/internal/credits.list
         * @secure
         */
        creditsListPost: (data: CreditsListRequest, params?: RequestParams) => Promise<AxiosResponse<CreditsListResponse, any>>;
        /**
         * @description Updates a credit object.
         *
         * @tags commerce
         * @name CreditsUpdate
         * @request POST:/internal/credits.update
         * @secure
         */
        creditsUpdate: (data: CreditsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<CreditsUpdateResponse, any>>;
        /**
         * @description Gets dataset for a query.
         *
         * @tags analytics
         * @name DatasetGet
         * @request GET:/internal/dataset.get
         * @secure
         */
        datasetGet: (query: {
            /**
             * End date at which to end the dataset.
             * @format date-time
             */
            end_date: string;
            /** Query ID to get the dataset for. */
            query_id: string;
            /**
             * Start date from which to start the dataset.
             * @format date-time
             */
            start_date: string;
        }, params?: RequestParams) => Promise<AxiosResponse<DatasetGetResponse, any>>;
        /**
         * @description Gets dataset for a query.
         *
         * @tags analytics
         * @name DatasetGetPost
         * @request POST:/internal/dataset.get
         * @secure
         */
        datasetGetPost: (data: DatasetGetRequest, params?: RequestParams) => Promise<AxiosResponse<DatasetGetResponse, any>>;
        /**
         * @description Creates a new enterprise authentication connection for a Dev organization. This authentication connection will not be enabled by default for the organization and the user will need to explicitly enable this. Keep in mind that at a time, only one authentication connection can be enabled for a Dev organization. At present, only 5 enterprise connections can be created by an organization.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsCreate
         * @request POST:/internal/dev-orgs.auth-connections.create
         * @secure
         */
        devOrgAuthConnectionsCreate: (data: DevOrgAuthConnectionsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgAuthConnectionsCreateResponse, any>>;
        /**
         * @description Deletes an authentication connection. Only enterprise connections which are explicitly set up for a Dev organization can be deleted. Default connections can not be deleted using this method.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsDelete
         * @request POST:/internal/dev-orgs.auth-connections.delete
         * @secure
         */
        devOrgAuthConnectionsDelete: (data: DevOrgAuthConnectionsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Retrieves the details for an authentication connection.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsGet
         * @request GET:/internal/dev-orgs.auth-connections.get
         * @secure
         */
        devOrgAuthConnectionsGet: (query: {
            /** ID of the authentication connection. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<DevOrgAuthConnectionsGetResponse, any>>;
        /**
         * @description Retrieves the details for an authentication connection.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsGetPost
         * @request POST:/internal/dev-orgs.auth-connections.get
         * @secure
         */
        devOrgAuthConnectionsGetPost: (data: DevOrgAuthConnectionsGetRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgAuthConnectionsGetResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Lists all the authentication connections available for a Dev organization. This list will include both social and enterprise connections which are either available by default or are explicitly created by the user.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsList
         * @request GET:/internal/dev-orgs.auth-connections.list
         * @secure
         */
        devOrgAuthConnectionsList: (params?: RequestParams) => Promise<AxiosResponse<DevOrgAuthConnectionsListResponse, any>>;
        /**
         * @description Lists all the authentication connections available for a Dev organization. This list will include both social and enterprise connections which are either available by default or are explicitly created by the user.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsListPost
         * @request POST:/internal/dev-orgs.auth-connections.list
         * @secure
         */
        devOrgAuthConnectionsListPost: (data: Empty, params?: RequestParams) => Promise<AxiosResponse<DevOrgAuthConnectionsListResponse, any>>;
        /**
         * @description Enable or disable an authentication connection for a Dev organization. Currently, only 1 authentication connection can be enabled at a time. When a new authentication connection is enabled, the connection which is currently enabled for the Dev organization is automatically disabled.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsToggle
         * @request POST:/internal/dev-orgs.auth-connections.toggle
         * @secure
         */
        devOrgAuthConnectionsToggle: (data: DevOrgAuthConnectionsToggleRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Updates an authentication connection.
         *
         * @tags auth-connection, dev-orgs
         * @name DevOrgAuthConnectionsUpdate
         * @request POST:/internal/dev-orgs.auth-connections.update
         * @secure
         */
        devOrgAuthConnectionsUpdate: (data: DevOrgAuthConnectionsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgAuthConnectionsUpdateResponse, any>>;
        /**
         * @description Creates a Dev organization for the authenticated user.
         *
         * @tags dev-orgs
         * @name DevOrgsCreate
         * @request POST:/internal/dev-orgs.create
         * @secure
         */
        devOrgsCreate: (data: DevOrgsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsCreateResponse, any>>;
        /**
         * @description Delete the Dev organization of the authenticated user.
         *
         * @tags dev-orgs
         * @name DevOrgsDelete
         * @request POST:/internal/dev-orgs.delete
         * @secure
         */
        devOrgsDelete: (data: DevOrgsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets the Dev organization's information of the authenticated user.
         *
         * @tags dev-orgs
         * @name DevOrgsGet
         * @request GET:/internal/dev-orgs.get
         * @secure
         */
        devOrgsGet: (params?: RequestParams) => Promise<AxiosResponse<DevOrgsGetResponse, any>>;
        /**
         * @description Gets the Dev organization's information of the authenticated user.
         *
         * @tags dev-orgs
         * @name DevOrgsGetPost
         * @request POST:/internal/dev-orgs.get
         * @secure
         */
        devOrgsGetPost: (data: DevOrgsGetRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsGetResponse, any>>;
        /**
         * @description Create an invitation to a user.
         *
         * @tags dev-orgs
         * @name DevOrgsInvitesCreate
         * @request POST:/internal/dev-orgs.invites.create
         * @secure
         */
        devOrgsInvitesCreate: (data: DevOrgsInvitesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsInvitesCreateResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets the list of Dev user invitations in the user's Dev organization.
         *
         * @tags dev-orgs
         * @name DevOrgsInvitesList
         * @request GET:/internal/dev-orgs.invites.list
         * @secure
         */
        devOrgsInvitesList: (query?: {
            /** Filters invitations to those created by the specified users. */
            created_by_ids?: string[];
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of invited users to be retrieved.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Fields to sort the invites by and the direction to sort them. */
            sort_by?: string[];
            /** Array of state values to be filtered. */
            state?: DevuInviteState[];
        }, params?: RequestParams) => Promise<AxiosResponse<DevOrgsInvitesListResponse, any>>;
        /**
         * @description Gets the list of Dev user invitations in the user's Dev organization.
         *
         * @tags dev-orgs
         * @name DevOrgsInvitesListPost
         * @request POST:/internal/dev-orgs.invites.list
         * @secure
         */
        devOrgsInvitesListPost: (data: DevOrgsInvitesListRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsInvitesListResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets a short-lived invitation url to join the organisation on the basis of email domain.
         *
         * @tags dev-orgs
         * @name DevOrgsJoin
         * @request GET:/internal/dev-orgs.join
         * @secure
         */
        devOrgsJoin: (query: {
            /**
             * The globally unique ID of the DevRev organization.
             * @example "don:<partition>:identity:devo/<dev-org-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<DevOrgsJoinResponse, any>>;
        /**
         * @description Gets a short-lived invitation url to join the organisation on the basis of email domain.
         *
         * @tags dev-orgs
         * @name DevOrgsJoinPost
         * @request POST:/internal/dev-orgs.join
         * @secure
         */
        devOrgsJoinPost: (data: DevOrgsJoinRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsJoinResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets the list of Dev organizations for the authenticated Dev user.
         *
         * @tags dev-orgs
         * @name DevOrgsList
         * @request GET:/internal/dev-orgs.list
         * @secure
         */
        devOrgsList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Whether to list the Dev organizations available to join without
             * invitation.
             */
            is_available?: boolean;
            /**
             * The number of Dev organizations to be retrieved.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Fields to sort the Dev organizations by and the direction to sort
             * them.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<DevOrgsListResponse, any>>;
        /**
         * @description Gets the list of Dev organizations for the authenticated Dev user.
         *
         * @tags dev-orgs
         * @name DevOrgsListPost
         * @request POST:/internal/dev-orgs.list
         * @secure
         */
        devOrgsListPost: (data: DevOrgsListRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsListResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets public information of a Dev organization from Slug.
         *
         * @tags dev-orgs
         * @name DevOrgPublicInfo
         * @request GET:/internal/dev-orgs.public-info.get
         */
        devOrgPublicInfo: (query: {
            /** Slug of the Dev organization. */
            slug: string;
        }, params?: RequestParams) => Promise<AxiosResponse<DevOrgPublicInfoResponse, any>>;
        /**
         * @description Gets public information of a Dev organization from Slug.
         *
         * @tags dev-orgs
         * @name DevOrgPublicInfoPost
         * @request POST:/internal/dev-orgs.public-info.get
         * @secure
         */
        devOrgPublicInfoPost: (data: DevOrgPublicInfoRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgPublicInfoResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets the authenticated user's Dev organization information.
         *
         * @tags dev-orgs
         * @name DevOrgsSelf
         * @request GET:/internal/dev-orgs.self
         * @secure
         */
        devOrgsSelf: (params?: RequestParams) => Promise<AxiosResponse<DevOrgsSelfGetResponse, any>>;
        /**
         * @description Gets the authenticated user's Dev organization information.
         *
         * @tags dev-orgs
         * @name DevOrgsSelfPost
         * @request POST:/internal/dev-orgs.self
         * @secure
         */
        devOrgsSelfPost: (data: DevOrgsSelfGetRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsSelfGetResponse, any>>;
        /**
         * @description ### Owner: sambhav.jain@devrev.ai ### Gets the authenticated user's Dev organization information.
         *
         * @tags dev-orgs
         * @name DevOrgsSelfGet
         * @request GET:/internal/dev-orgs.self.get
         * @secure
         */
        devOrgsSelfGet: (params?: RequestParams) => Promise<AxiosResponse<DevOrgsSelfGetResponse, any>>;
        /**
         * @description Gets the authenticated user's Dev organization information.
         *
         * @tags dev-orgs
         * @name DevOrgsSelfGetPost
         * @request POST:/internal/dev-orgs.self.get
         * @secure
         */
        devOrgsSelfGetPost: (data: DevOrgsSelfGetRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsSelfGetResponse, any>>;
        /**
         * @description Updates the Dev organization's information of the authenticated user.
         *
         * @tags dev-orgs
         * @name DevOrgsUpdate
         * @request POST:/internal/dev-orgs.update
         * @secure
         */
        devOrgsUpdate: (data: DevOrgsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<DevOrgsUpdateResponse, any>>;
        /**
         * @description Deactivates the requested user.
         *
         * @tags dev-users
         * @name DevUsersDeactivate
         * @request POST:/internal/dev-users.deactivate
         * @secure
         */
        devUsersDeactivate: (data: DevUsersDeactivateRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Deletes the requested user.
         *
         * @tags dev-users
         * @name DevUsersDelete
         * @request POST:/internal/dev-users.delete
         * @secure
         */
        devUsersDelete: (data: DevUsersDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Checks if a display handle is available for the authenticated user or not.
         *
         * @tags dev-users
         * @name DevUsersIsDisplayHandleAvailable
         * @request GET:/internal/dev-users.display-handles.is-available
         * @secure
         */
        devUsersIsDisplayHandleAvailable: (query: {
            /** Display handle to be checked for availability. */
            display_handle: string;
        }, params?: RequestParams) => Promise<AxiosResponse<DevUsersIsDisplayHandleAvailableResponse, any>>;
        /**
         * @description Checks if a display handle is available for the authenticated user or not.
         *
         * @tags dev-users
         * @name DevUsersIsDisplayHandleAvailablePost
         * @request POST:/internal/dev-users.display-handles.is-available
         * @secure
         */
        devUsersIsDisplayHandleAvailablePost: (data: DevUsersIsDisplayHandleAvailableRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersIsDisplayHandleAvailableResponse, any>>;
        /**
         * @description Updates the display picture of a Dev User
         *
         * @tags dev-users
         * @name DevUserUpdateDisplayPicture
         * @request POST:/internal/dev-users.display-picture
         * @secure
         */
        devUserUpdateDisplayPicture: (data: DevUserUpdateDisplayPictureRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the requested user's information.
         *
         * @tags dev-users
         * @name DevUsersGet
         * @request GET:/internal/dev-users.get
         * @secure
         */
        devUsersGet: (query: {
            /** User ID of the requested Dev user. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<DevUsersGetResponse, any>>;
        /**
         * @description Gets the requested user's information.
         *
         * @tags dev-users
         * @name DevUsersGetPost
         * @request POST:/internal/dev-users.get
         * @secure
         */
        devUsersGetPost: (data: DevUsersGetRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersGetResponse, any>>;
        /**
         * @description Links an external/secondary identity to the Dev user.
         *
         * @tags dev-users
         * @name DevUsersIdentitiesLink
         * @request POST:/internal/dev-users.identities.link
         * @secure
         */
        devUsersIdentitiesLink: (data: DevUsersIdentitiesLinkRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersIdentitiesLinkResponse, any>>;
        /**
         * @description Lists users within your organization.
         *
         * @tags dev-users
         * @name DevUsersList
         * @request GET:/internal/dev-users.list
         * @secure
         */
        devUsersList: (query?: {
            /**
             * Filters list of Dev users which are created by specified list of Dev
             * user IDs.
             */
            created_by?: string[];
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /** Filters Dev users based on email addresses. */
            email?: string[];
            /** Filters Dev users based on job titles. */
            job_title?: DevUserJobTitle[];
            /**
             * The maximum number of Dev users to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Fields to sort the Dev users by and the direction to sort them. */
            sort_by?: string[];
            /** Filters Dev users based on state. */
            state?: UserState[];
        }, params?: RequestParams) => Promise<AxiosResponse<DevUsersListResponse, any>>;
        /**
         * @description Lists users within your organization.
         *
         * @tags dev-users
         * @name DevUsersListPost
         * @request POST:/internal/dev-users.list
         * @secure
         */
        devUsersListPost: (data: DevUsersListRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersListResponse, any>>;
        /**
         * @description Logout from a Dev organization.
         *
         * @tags dev-users
         * @name DevUsersLogout
         * @request POST:/internal/dev-users.logout
         * @secure
         */
        devUsersLogout: (data: DevUsersLogoutRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Merges the identity of a secondary Dev user with the primary Dev user.The account of the secondary Dev user will be deactivated and will no longer be able to log into DevRev. All objects - issues, tickets, parts etc. owned by the secondary Dev user will be transferred to the primary Dev user.
         *
         * @tags dev-users
         * @name DevUsersMerge
         * @request POST:/internal/dev-users.merge
         * @secure
         */
        devUsersMerge: (data: DevUsersMergeRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Updates the user's phone number if the verification code entered by the user is valid.
         *
         * @tags dev-users
         * @name DevUsersCheckPhoneNumberCode
         * @request POST:/internal/dev-users.phonenumbers.check-code
         * @secure
         */
        devUsersCheckPhoneNumberCode: (data: DevUsersCheckPhoneNumberCodeRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersCheckPhoneNumberCodeResponse, any>>;
        /**
         * @description Sends a verification code to the user's phone number.
         *
         * @tags dev-users
         * @name DevUsersSendPhoneNumberCode
         * @request POST:/internal/dev-users.phonenumbers.send-code
         * @secure
         */
        devUsersSendPhoneNumberCode: (data: DevUsersSendPhoneNumberCodeRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Request made by UI to perform first set of operations when Dev user logs into a Dev organization.
         *
         * @tags dev-users
         * @name DevUsersPostLogin
         * @request POST:/internal/dev-users.post-login
         * @secure
         */
        devUsersPostLogin: (data: DevUsersPostLoginRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersPostLoginResponse, any>>;
        /**
         * @description Gets the authenticated user's information.
         *
         * @tags dev-users
         * @name DevUsersSelf
         * @request GET:/internal/dev-users.self
         * @secure
         */
        devUsersSelf: (params?: RequestParams) => Promise<AxiosResponse<DevUsersSelfResponse, any>>;
        /**
         * @description Gets the authenticated user's information.
         *
         * @tags dev-users
         * @name DevUsersSelfPost
         * @request POST:/internal/dev-users.self
         * @secure
         */
        devUsersSelfPost: (data: DevUsersSelfRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersSelfResponse, any>>;
        /**
         * @description Deletes the authenticated user.
         *
         * @tags dev-users
         * @name DevUsersSelfDelete
         * @request POST:/internal/dev-users.self.delete
         * @secure
         */
        devUsersSelfDelete: (data: DevUsersSelfDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Updates the authenticated user.
         *
         * @tags dev-users
         * @name DevUsersSelfUpdate
         * @request POST:/internal/dev-users.self.update
         * @secure
         */
        devUsersSelfUpdate: (data: DevUsersSelfUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersUpdateResponse, any>>;
        /**
         * @description Updates the user corresponding to the input Id.
         *
         * @tags dev-users
         * @name DevUsersUpdate
         * @request POST:/internal/dev-users.update
         * @secure
         */
        devUsersUpdate: (data: DevUsersUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<DevUsersUpdateResponse, any>>;
        /**
         * @description Schedule data collection for discovery.
         *
         * @tags discovery
         * @name ScheduleDataCollection
         * @request POST:/internal/discovery.data-collection.schedule
         * @secure
         */
        scheduleDataCollection: (data: ScheduleDataCollectionRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Start data collection for discovery.
         *
         * @tags discovery
         * @name StartDataCollection
         * @request POST:/internal/discovery.data-collection.start
         * @secure
         */
        startDataCollection: (data: StartDataCollectionRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Unschedule data collection for discovery.
         *
         * @tags discovery
         * @name UnscheduleDataCollection
         * @request POST:/internal/discovery.data-collection.unschedule
         * @secure
         */
        unscheduleDataCollection: (data: UnscheduleDataCollectionRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Create discovery profile.
         *
         * @tags discovery
         * @name CreateDiscoveryProfile
         * @request POST:/internal/discovery.profiles.create
         * @secure
         */
        createDiscoveryProfile: (data: CreateDiscoveryProfileRequest, params?: RequestParams) => Promise<AxiosResponse<CreateDiscoveryProfileResponse, any>>;
        /**
         * @description Delete discovery profile.
         *
         * @tags discovery
         * @name DeleteDiscoveryProfile
         * @request POST:/internal/discovery.profiles.delete
         * @secure
         */
        deleteDiscoveryProfile: (data: DeleteDiscoveryProfileRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Get discovery profile.
         *
         * @tags discovery
         * @name GetDiscoveryProfile
         * @request POST:/internal/discovery.profiles.get
         * @secure
         */
        getDiscoveryProfile: (data: GetDiscoveryProfileRequest, params?: RequestParams) => Promise<AxiosResponse<GetDiscoveryProfileResponse, any>>;
        /**
         * @description List discovery profiles.
         *
         * @tags discovery
         * @name ListDiscoveryProfiles
         * @request POST:/internal/discovery.profiles.list
         * @secure
         */
        listDiscoveryProfiles: (data: ListDiscoveryProfilesRequest, params?: RequestParams) => Promise<AxiosResponse<ListDiscoveryProfilesResponse, any>>;
        /**
         * @description Update discovery profile.
         *
         * @tags discovery
         * @name UpdateDiscoveryProfile
         * @request POST:/internal/discovery.profiles.update
         * @secure
         */
        updateDiscoveryProfile: (data: UpdateDiscoveryProfileRequest, params?: RequestParams) => Promise<AxiosResponse<UpdateDiscoveryProfileResponse, any>>;
        /**
         * @description Run discovery using profile.
         *
         * @tags discovery
         * @name RunDiscovery
         * @request POST:/internal/discovery.run
         * @secure
         */
        runDiscovery: (data: RunDiscoveryRequest, params?: RequestParams) => Promise<AxiosResponse<RunDiscoveryResponse, any>>;
        /**
         * @description Get discovery run status.
         *
         * @tags discovery
         * @name GetDiscoveryRun
         * @request GET:/internal/discovery.run.status
         * @secure
         */
        getDiscoveryRun: (query: {
            /** Discovery run unique ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<GetDiscoveryRunResponse, any>>;
        /**
         * @description Get discovery run status.
         *
         * @tags discovery
         * @name GetDiscoveryRunPost
         * @request POST:/internal/discovery.run.status
         * @secure
         */
        getDiscoveryRunPost: (data: GetDiscoveryRunRequest, params?: RequestParams) => Promise<AxiosResponse<GetDiscoveryRunResponse, any>>;
        /**
         * @description Schedule discovery run.
         *
         * @tags discovery
         * @name ScheduleDiscovery
         * @request POST:/internal/discovery.schedule
         * @secure
         */
        scheduleDiscovery: (data: ScheduleDiscoveryRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Create discovery Settings.
         *
         * @tags discovery
         * @name CreateDiscoverySettings
         * @request POST:/internal/discovery.settings.create
         * @secure
         */
        createDiscoverySettings: (data: CreateDiscoverySettingsRequest, params?: RequestParams) => Promise<AxiosResponse<CreateDiscoverySettingsResponse, any>>;
        /**
         * @description Delete discovery Settings.
         *
         * @tags discovery
         * @name DeleteDiscoverySettings
         * @request POST:/internal/discovery.settings.delete
         * @secure
         */
        deleteDiscoverySettings: (data: DeleteDiscoverySettingsRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Get discovery Settings.
         *
         * @tags discovery
         * @name GetDiscoverySettings
         * @request GET:/internal/discovery.settings.get
         * @secure
         */
        getDiscoverySettings: (query?: {
            /**
             * Optional Dev organization ID. This allows running on another Dev
             * organization, as long as the logged in user has access to it.
             * @example "don:<partition>:identity:devo/<dev-org-id>"
             */
            other_dev_org?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<GetDiscoverySettingsResponse, any>>;
        /**
         * @description Get discovery Settings.
         *
         * @tags discovery
         * @name GetDiscoverySettingsPost
         * @request POST:/internal/discovery.settings.get
         * @secure
         */
        getDiscoverySettingsPost: (data: GetDiscoverySettingsRequest, params?: RequestParams) => Promise<AxiosResponse<GetDiscoverySettingsResponse, any>>;
        /**
         * @description Update discovery Settings.
         *
         * @tags discovery
         * @name UpdateDiscoverySettings
         * @request POST:/internal/discovery.settings.update
         * @secure
         */
        updateDiscoverySettings: (data: UpdateDiscoverySettingsRequest, params?: RequestParams) => Promise<AxiosResponse<UpdateDiscoverySettingsResponse, any>>;
        /**
         * @description List discovery sources.
         *
         * @tags discovery
         * @name ListDiscoverySources
         * @request GET:/internal/discovery.sources.list
         * @secure
         */
        listDiscoverySources: (query?: {
            /**
             * Optional Dev organization ID. This allows running on another Dev
             * organization, as long as the logged in user has access to it.
             * @example "don:<partition>:identity:devo/<dev-org-id>"
             */
            other_dev_org?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ListDiscoverySourcesResponse, any>>;
        /**
         * @description List discovery sources.
         *
         * @tags discovery
         * @name ListDiscoverySourcesPost
         * @request POST:/internal/discovery.sources.list
         * @secure
         */
        listDiscoverySourcesPost: (data: ListDiscoverySourcesRequest, params?: RequestParams) => Promise<AxiosResponse<ListDiscoverySourcesResponse, any>>;
        /**
         * @description Unschedule discovery run.
         *
         * @tags discovery
         * @name UnscheduleDiscovery
         * @request POST:/internal/discovery.unschedule
         * @secure
         */
        unscheduleDiscovery: (data: UnscheduleDiscoveryRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Creates domain identity for the supplied domain
         *
         * @tags domain-identity
         * @name DomainIdentitiesCreate
         * @request POST:/internal/domain-identities.create
         * @secure
         */
        domainIdentitiesCreate: (data: DomainIdentitiesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<DomainIdentitiesCreateResponse, any>>;
        /**
         * @description Syncs the domain identity verification status
         *
         * @tags domain-identity
         * @name DomainIdentitiesSync
         * @request POST:/internal/domain-identities.sync
         * @secure
         */
        domainIdentitiesSync: (data: DomainIdentitiesSyncRequest, params?: RequestParams) => Promise<AxiosResponse<DomainIdentitiesSyncResponse, any>>;
        /**
         * @description Creates an event source.
         *
         * @tags event-source
         * @name EventSourcesCreate
         * @request POST:/internal/event-sources.create
         * @secure
         */
        eventSourcesCreate: (data: EventSourceCreateRequest, params?: RequestParams) => Promise<AxiosResponse<EventSourceCreateResponse, any>>;
        /**
         * @description Deletes an event source.
         *
         * @tags event-source
         * @name EventSourceDelete
         * @request POST:/internal/event-sources.delete
         * @secure
         */
        eventSourceDelete: (data: EventSourceDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Schedules/publishes an event to the specified event source.
         *
         * @tags event-source
         * @name EventSourcesScheduleEvent
         * @request POST:/internal/event-sources.event.schedule
         * @secure
         */
        eventSourcesScheduleEvent: (data: EventSourcesScheduleEventRequest, params?: RequestParams) => Promise<AxiosResponse<EventSourcesScheduleEventResponse, any>>;
        /**
         * @description Deletes a scheduled event scheduled for the specified event source.
         *
         * @tags event-source
         * @name EventSourcesDeleteScheduledEvent
         * @request POST:/internal/event-sources.event.unschedule
         * @secure
         */
        eventSourcesDeleteScheduledEvent: (data: EventSourcesDeleteScheduledEventRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets an event source.
         *
         * @tags event-source
         * @name EventSourcesGet
         * @request GET:/internal/event-sources.get
         * @secure
         */
        eventSourcesGet: (query: {
            /** The event source's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<EventSourceGetResponse, any>>;
        /**
         * @description Gets an event source.
         *
         * @tags event-source
         * @name EventSourcesGetPost
         * @request POST:/internal/event-sources.get
         * @secure
         */
        eventSourcesGetPost: (data: EventSourceGetRequest, params?: RequestParams) => Promise<AxiosResponse<EventSourceGetResponse, any>>;
        /**
         * @description Lists event sources for a Dev organization.
         *
         * @tags event-source
         * @name EventSourcesList
         * @request GET:/internal/event-sources.list
         * @secure
         */
        eventSourcesList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Fields to sort the event sources by and the direction to sort them. */
            sort_by?: string[];
            /**
             * type describes which event source is being instantiated from list of
             * event sources we support. It would contain values like
             * pd/github/new-or-updated-pull-request, etc.
             */
            type?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<EventSourcesListResponse, any>>;
        /**
         * @description Lists event sources for a Dev organization.
         *
         * @tags event-source
         * @name EventSourcesListPost
         * @request POST:/internal/event-sources.list
         * @secure
         */
        eventSourcesListPost: (data: EventSourcesListRequest, params?: RequestParams) => Promise<AxiosResponse<EventSourcesListResponse, any>>;
        /**
         * @description Updates an event source.
         *
         * @tags event-source
         * @name EventSourceUpdate
         * @request POST:/internal/event-sources.update
         * @secure
         */
        eventSourceUpdate: (data: EventSourceUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<EventSourceUpdateResponse, any>>;
        /**
         * @description Gets the flags for a user.
         *
         * @tags experience
         * @name ExperienceFlagsGet
         * @request GET:/internal/experience.flags.get
         */
        experienceFlagsGet: (params?: RequestParams) => Promise<AxiosResponse<ExperienceFlagsGetResponse, any>>;
        /**
         * @description Gets the flags for a user.
         *
         * @tags experience
         * @name ExperienceFlagsGetPost
         * @request POST:/internal/experience.flags.get
         * @secure
         */
        experienceFlagsGetPost: (data: ExperienceFlagsGetRequest, params?: RequestParams) => Promise<AxiosResponse<ExperienceFlagsGetResponse, any>>;
        /**
         * @description Deletes a flow.
         *
         * @tags flows
         * @name FlowDelete
         * @request POST:/internal/flows.delete
         * @secure
         */
        flowDelete: (data: FlowDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a Flow.
         *
         * @tags flows
         * @name FlowGet
         * @request GET:/internal/flows.get
         * @secure
         */
        flowGet: (query: {
            /** The flow's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<FlowGetResponse, any>>;
        /**
         * @description Gets a Flow.
         *
         * @tags flows
         * @name FlowGetPost
         * @request POST:/internal/flows.get
         * @secure
         */
        flowGetPost: (data: FlowGetRequest, params?: RequestParams) => Promise<AxiosResponse<FlowGetResponse, any>>;
        /**
         * @description Creates GitHub flow with the given parameters.
         *
         * @tags flows
         * @name FlowsGithubCreate
         * @request POST:/internal/flows.github.create
         * @secure
         */
        flowsGithubCreate: (data: FlowsGithubCreateRequest, params?: RequestParams) => Promise<AxiosResponse<FlowsGithubCreateResponse, any>>;
        /**
         * @description Lists flows for a Dev organization.
         *
         * @tags flows
         * @name FlowsList
         * @request GET:/internal/flows.list
         * @secure
         */
        flowsList: (query?: {
            /** The cursor to begin iteration from. */
            cursor?: string;
            /** ID of Marketplace Item which installed this flow. */
            marketplace_item?: string[];
            /** Parameter to indicate if the response must omit the raw_template. */
            omit_raw_template?: boolean;
            /** Fields to sort the flows by and the direction to sort them. */
            sort_by?: string[];
            /** Deployment status of the flow. */
            status?: FlowStatus[];
        }, params?: RequestParams) => Promise<AxiosResponse<FlowsListResponse, any>>;
        /**
         * @description Lists flows for a Dev organization.
         *
         * @tags flows
         * @name FlowsListPost
         * @request POST:/internal/flows.list
         * @secure
         */
        flowsListPost: (data: FlowsListRequest, params?: RequestParams) => Promise<AxiosResponse<FlowsListResponse, any>>;
        /**
         * @description Updates a Flow.
         *
         * @tags flows
         * @name FlowUpdate
         * @request POST:/internal/flows.update
         * @secure
         */
        flowUpdate: (data: FlowUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<FlowUpdateResponse, any>>;
        /**
         * @description Validates the flow template and version update
         *
         * @tags flows
         * @name ValidateFlowTemplate
         * @request POST:/internal/flows.validate.template
         * @secure
         */
        validateFlowTemplate: (data: ValidateFlowTemplateRequest, params?: RequestParams) => Promise<AxiosResponse<ValidateFlowTemplateResponse, any>>;
        /**
         * @description Creates a function definition in a devOrg.
         *
         * @tags microflows
         * @name FunctionDefinitionsCreate
         * @request POST:/internal/functions.create
         * @secure
         */
        functionDefinitionsCreate: (data: FunctionDefinitionsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<FunctionDefinitionsCreateResponse, any>>;
        /**
         * @description Deletes a function definition in a devOrg.
         *
         * @tags microflows
         * @name FunctionDefinitionsDelete
         * @request POST:/internal/functions.delete
         * @secure
         */
        functionDefinitionsDelete: (data: FunctionDefinitionsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a function definition in a devOrg.
         *
         * @tags microflows
         * @name FunctionDefinitionsGet
         * @request GET:/internal/functions.get
         * @secure
         */
        functionDefinitionsGet: (query: {
            /** The function definition's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<FunctionDefinitionsGetResponse, any>>;
        /**
         * @description Gets a function definition in a devOrg.
         *
         * @tags microflows
         * @name FunctionDefinitionsGetPost
         * @request POST:/internal/functions.get
         * @secure
         */
        functionDefinitionsGetPost: (data: FunctionDefinitionsGetRequest, params?: RequestParams) => Promise<AxiosResponse<FunctionDefinitionsGetResponse, any>>;
        /**
         * @description Lists functions used in microflows for a Dev organization.
         *
         * @tags microflows
         * @name FunctionDefinitionsList
         * @request GET:/internal/functions.list
         * @secure
         */
        functionDefinitionsList: (query?: {
            /**
             * Page number for paginated function definition items.
             * @format int32
             */
            page?: number;
            /**
             * Number of function definition items to return per page. Default is
             * 50.
             * @format int32
             */
            per_page?: number;
            /**
             * List of fields to sort the function definition items by and how to
             * sort them. Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<FunctionDefinitionsListResponse, any>>;
        /**
         * @description Lists functions used in microflows for a Dev organization.
         *
         * @tags microflows
         * @name FunctionDefinitionsListPost
         * @request POST:/internal/functions.list
         * @secure
         */
        functionDefinitionsListPost: (data: FunctionDefinitionsListRequest, params?: RequestParams) => Promise<AxiosResponse<FunctionDefinitionsListResponse, any>>;
        /**
         * @description Updates a function definition in a devOrg.
         *
         * @tags microflows
         * @name FunctionDefinitionsUpdate
         * @request POST:/internal/functions.update
         * @secure
         */
        functionDefinitionsUpdate: (data: FunctionDefinitionsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<FunctionDefinitionsUpdateResponse, any>>;
        /**
         * @description Executes a GraphQL request.
         *
         * @name Graphql
         * @request POST:/internal/graphql.execute
         * @secure
         */
        graphql: (data: GraphqlRequest, params?: RequestParams) => Promise<AxiosResponse<GraphqlResponse, any>>;
        /**
         * @description Creates a new group.
         *
         * @tags groups
         * @name GroupsCreate
         * @request POST:/internal/groups.create
         * @secure
         */
        groupsCreate: (data: GroupsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<GroupsCreateResponse, any>>;
        /**
         * @description Deletes the requested group.
         *
         * @tags groups
         * @name GroupsDelete
         * @request POST:/internal/groups.delete
         * @secure
         */
        groupsDelete: (data: GroupsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Lists the available groups.
         *
         * @tags groups
         * @name GroupsList
         * @request GET:/internal/groups.list
         * @secure
         */
        groupsList: (params?: RequestParams) => Promise<AxiosResponse<GroupsListResponse, any>>;
        /**
         * @description Lists the available groups.
         *
         * @tags groups
         * @name GroupsListPost
         * @request POST:/internal/groups.list
         * @secure
         */
        groupsListPost: (data: GroupsListRequest, params?: RequestParams) => Promise<AxiosResponse<GroupsListResponse, any>>;
        /**
         * @description Updates the requested group.
         *
         * @tags groups
         * @name GroupsUpdate
         * @request POST:/internal/groups.update
         * @secure
         */
        groupsUpdate: (data: GroupsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<GroupsUpdateResponse, any>>;
        /**
         * @description Gets an Insight.
         *
         * @tags insights
         * @name InsightsGet
         * @request GET:/internal/insights.get
         * @secure
         */
        insightsGet: (query: {
            /** The insights's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<InsightsGetResponse, any>>;
        /**
         * @description Gets an Insight.
         *
         * @tags insights
         * @name InsightsGetPost
         * @request POST:/internal/insights.get
         * @secure
         */
        insightsGetPost: (data: InsightsGetRequest, params?: RequestParams) => Promise<AxiosResponse<InsightsGetResponse, any>>;
        /**
         * @description Lists insights.
         *
         * @tags insights
         * @name InsightsList
         * @request GET:/internal/insights.list
         * @secure
         */
        insightsList: (query?: {
            /**
             * The cursor to begin iteration from, otherwise if not provided, then
             * iteration starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of insights to return. If not set, then the
             * default is '50'.
             * @format int32
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<InsightsListResponse, any>>;
        /**
         * @description Lists insights.
         *
         * @tags insights
         * @name InsightsListPost
         * @request POST:/internal/insights.list
         * @secure
         */
        insightsListPost: (data: InsightsListRequest, params?: RequestParams) => Promise<AxiosResponse<InsightsListResponse, any>>;
        /**
         * @description Lists insight values.
         *
         * @tags insights
         * @name InsightsValuesList
         * @request GET:/internal/insights.values.list
         * @secure
         */
        insightsValuesList: (query?: {
            /**
             * The cursor to begin iteration from, otherwise if not provided, then
             * iteration starts from the beginning.
             */
            cursor?: string;
            /**
             * Filter based on for_object_id.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            for_object_ids?: string[];
            /** Filter based on insight ids. */
            insight_ids?: string[];
            /**
             * The maximum number of insights to return. If not set, then the
             * default is '50'.
             * @format int32
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<InsightsValuesListResponse, any>>;
        /**
         * @description Lists insight values.
         *
         * @tags insights
         * @name InsightsValuesListPost
         * @request POST:/internal/insights.values.list
         * @secure
         */
        insightsValuesListPost: (data: InsightsValuesListRequest, params?: RequestParams) => Promise<AxiosResponse<InsightsValuesListResponse, any>>;
        /**
         * @description Returns the invoice.
         *
         * @tags commerce
         * @name InvoicesGet
         * @request GET:/internal/invoices.get
         * @secure
         */
        invoicesGet: (query: {
            /** The invoice object's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<InvoicesGetResponse, any>>;
        /**
         * @description Returns the invoice.
         *
         * @tags commerce
         * @name InvoicesGetPost
         * @request POST:/internal/invoices.get
         * @secure
         */
        invoicesGetPost: (data: InvoicesGetRequest, params?: RequestParams) => Promise<AxiosResponse<InvoicesGetResponse, any>>;
        /**
         * @description List invoices for a customer.
         *
         * @tags commerce
         * @name InvoicesList
         * @request GET:/internal/invoices.list
         * @secure
         */
        invoicesList: (query?: {
            /**
             * Filter items which have billing date after the timestamp provided.
             * @format date-time
             */
            after_billing_date?: string;
            /**
             * Filter items which have due date after the timestamp provided.
             * @format date-time
             */
            after_due_date?: string;
            /**
             * Filter items which have billing date before the timestamp provided.
             * @format date-time
             */
            before_billing_date?: string;
            /**
             * Filter items which have due date before the timestamp provided.
             * @format date-time
             */
            before_due_date?: string;
            /** Filter items by doing queries on invoice collection method. */
            collection_method?: InvoicesCollectionMethod;
            /** Filter items by doing queries on service plan. */
            service_plan_id?: string;
            /** Filter items by doing queries on invoice status. */
            statuses?: InvoiceStatus[];
        }, params?: RequestParams) => Promise<AxiosResponse<InvoicesListResponse, any>>;
        /**
         * @description List invoices for a customer.
         *
         * @tags commerce
         * @name InvoicesListPost
         * @request POST:/internal/invoices.list
         * @secure
         */
        invoicesListPost: (data: InvoicesListRequest, params?: RequestParams) => Promise<AxiosResponse<InvoicesListResponse, any>>;
        /**
         * @description OAuth2 authorization callback.
         *
         * @tags keyring
         * @name KeyringsCreateCallback
         * @request GET:/internal/keyrings.authorize
         */
        keyringsCreateCallback: (query?: {
            /** Request for user sign-in authentication */
            authuser?: string;
            /** Code to exchange for an access token */
            code?: string;
            /** OAuth2 short error */
            error?: string;
            /** OAuth2 error description */
            error_description?: string;
            /** Server ID where the application is authorized [for discord] */
            guild_id?: string;
            /** The hosted domain of the user account */
            hd?: string;
            /** Github installation ID */
            installation_id?: string;
            /** OAuth2 permissions for an application */
            permissions?: string;
            /** User consent dialog */
            prompt?: string;
            /** OAuth2 scope */
            scope?: string;
            /** Github action information */
            setup_action?: string;
            /** State value given to the authorization request */
            state?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description OAuth2 authorization callback.
         *
         * @tags keyring
         * @name KeyringsCreateCallbackPost
         * @request POST:/internal/keyrings.authorize
         * @secure
         */
        keyringsCreateCallbackPost: (data: KeyringsCreateCallbackRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Lists capabilities.
         *
         * @tags keyring
         * @name CapabilitiesList
         * @request GET:/internal/keyrings.capability.list
         * @secure
         */
        capabilitiesList: (params?: RequestParams) => Promise<AxiosResponse<CapabilitiesListResponse, any>>;
        /**
         * @description Lists capabilities.
         *
         * @tags keyring
         * @name CapabilitiesListPost
         * @request POST:/internal/keyrings.capability.list
         * @secure
         */
        capabilitiesListPost: (data: CapabilitiesListRequest, params?: RequestParams) => Promise<AxiosResponse<CapabilitiesListResponse, any>>;
        /**
         * @description Creates a keyring.
         *
         * @tags keyring
         * @name KeyringsCreate
         * @request POST:/internal/keyrings.create
         * @secure
         */
        keyringsCreate: (data: KeyringsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<KeyringsCreateResponse, any>>;
        /**
         * @description Deletes a keyring.
         *
         * @tags keyring
         * @name KeyringsDelete
         * @request POST:/internal/keyrings.delete
         * @secure
         */
        keyringsDelete: (data: KeyringsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Lists external organiztaions linked to a keyring.
         *
         * @tags keyring
         * @name ExternalOrgsList
         * @request GET:/internal/keyrings.external_org.list
         * @secure
         */
        externalOrgsList: (query: {
            /** The keyring's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ExternalOrgsListResponse, any>>;
        /**
         * @description Lists external organiztaions linked to a keyring.
         *
         * @tags keyring
         * @name ExternalOrgsListPost
         * @request POST:/internal/keyrings.external_org.list
         * @secure
         */
        externalOrgsListPost: (data: ExternalOrgsListRequest, params?: RequestParams) => Promise<AxiosResponse<ExternalOrgsListResponse, any>>;
        /**
         * @description Gets a keyring.
         *
         * @tags keyring
         * @name KeyringsGet
         * @request GET:/internal/keyrings.get
         * @secure
         */
        keyringsGet: (query: {
            /** The keyring's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<KeyringsGetResponse, any>>;
        /**
         * @description Gets a keyring.
         *
         * @tags keyring
         * @name KeyringsGetPost
         * @request POST:/internal/keyrings.get
         * @secure
         */
        keyringsGetPost: (data: KeyringsGetRequest, params?: RequestParams) => Promise<AxiosResponse<KeyringsGetResponse, any>>;
        /**
         * @description Lists keyrings for a Dev organization.
         *
         * @tags keyring
         * @name KeyringsList
         * @request GET:/internal/keyrings.list
         * @secure
         */
        keyringsList: (query?: {
            /** Filters keyrings with associated categories. */
            categories?: string[];
            /** The cursor to begin iteration from */
            cursor?: string;
            /**
             * Comma separated fields to sort the items by and how to sort them
             * (field_name1:[asc/desc],field_name2:[asc/desc]).
             */
            sort_by?: string;
            /** Filters for keyring of the provided types. */
            types?: KeyringType[];
        }, params?: RequestParams) => Promise<AxiosResponse<KeyringsListResponse, any>>;
        /**
         * @description Lists keyrings for a Dev organization.
         *
         * @tags keyring
         * @name KeyringsListPost
         * @request POST:/internal/keyrings.list
         * @secure
         */
        keyringsListPost: (data: KeyringsListRequest, params?: RequestParams) => Promise<AxiosResponse<KeyringsListResponse, any>>;
        /**
         * @description Updates a keyring.
         *
         * @tags keyring
         * @name KeyringsUpdate
         * @request POST:/internal/keyrings.update
         * @secure
         */
        keyringsUpdate: (data: KeyringsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<KeyringsUpdateResponse, any>>;
        /**
         * @description Lists all the vertices and edges in knowledge graph
         *
         * @tags parts
         * @name KnowledgeV2
         * @request GET:/internal/knowledge
         * @secure
         */
        knowledgeV2: (params?: RequestParams) => Promise<AxiosResponse<KnowledgeV2Response, any>>;
        /**
         * @description Lists all the vertices and edges in knowledge graph
         *
         * @tags parts
         * @name KnowledgeV2Post
         * @request POST:/internal/knowledge
         * @secure
         */
        knowledgeV2Post: (data: KnowledgeV2Request, params?: RequestParams) => Promise<AxiosResponse<KnowledgeV2Response, any>>;
        /**
         * @description Creates a link.
         *
         * @tags links
         * @name LinksCreate
         * @request POST:/internal/links.create
         * @secure
         */
        linksCreate: (data: LinksCreateRequest, params?: RequestParams) => Promise<AxiosResponse<LinksCreateResponse, any>>;
        /**
         * @description Deletes the requested link.
         *
         * @tags links
         * @name LinksDelete
         * @request POST:/internal/links.delete
         * @secure
         */
        linksDelete: (data: LinksDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the requested link's information.
         *
         * @tags links
         * @name LinksGet
         * @request GET:/internal/links.get
         * @secure
         */
        linksGet: (query: {
            /** The requested link's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<LinksGetResponse, any>>;
        /**
         * @description Gets the requested link's information.
         *
         * @tags links
         * @name LinksGetPost
         * @request POST:/internal/links.get
         * @secure
         */
        linksGetPost: (data: LinksGetRequest, params?: RequestParams) => Promise<AxiosResponse<LinksGetResponse, any>>;
        /**
         * @description Lists collections of links by groups.
         *
         * @tags links
         * @name LinksGroup
         * @request GET:/internal/links.group
         * @secure
         */
        linksGroup: (query: {
            /** The field to group the links by. */
            group_by: string;
            /** The ID of the object to list the link groups for. */
            object_id: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The direction of the links to list, otherwise if not present, then
             * links in both directions (source and target) are included.
             */
            direction?: LinksDirection;
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of links to return for an individual group. If not
             * set, then the default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * The link types to filter for, otherwise if not present, all link
             * types are included.
             */
            types?: LinkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<LinksGroupResponse, any>>;
        /**
         * @description Lists collections of links by groups.
         *
         * @tags links
         * @name LinksGroupPost
         * @request POST:/internal/links.group
         * @secure
         */
        linksGroupPost: (data: LinksGroupRequest, params?: RequestParams) => Promise<AxiosResponse<LinksGroupResponse, any>>;
        /**
         * @description Lists the available links.
         *
         * @tags links
         * @name LinksList
         * @request GET:/internal/links.list
         * @secure
         */
        linksList: (query: {
            /** The ID of the object to list the links for. */
            object_id: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The direction of the links to list, otherwise if not present, then
             * links in both directions (source and target) are included.
             */
            direction?: LinksDirection;
            /**
             * The maximum number of links to return. If not set, then the default
             * is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * The link types to filter for, otherwise if not present, all link
             * types are included.
             */
            types?: LinkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<LinksListResponse, any>>;
        /**
         * @description Lists the available links.
         *
         * @tags links
         * @name LinksListPost
         * @request POST:/internal/links.list
         * @secure
         */
        linksListPost: (data: LinksListRequest, params?: RequestParams) => Promise<AxiosResponse<LinksListResponse, any>>;
        /**
         * @description Replaces a link.
         *
         * @tags links
         * @name LinksReplace
         * @request POST:/internal/links.replace
         * @secure
         */
        linksReplace: (data: LinksReplaceRequest, params?: RequestParams) => Promise<AxiosResponse<LinksReplaceResponse, any>>;
        /**
         * @description Lists the available lobbies.
         *
         * @tags lobbies
         * @name LobbiesList
         * @request GET:/internal/lobbies.list
         * @secure
         */
        lobbiesList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of lobbies to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
        }, params?: RequestParams) => Promise<AxiosResponse<LobbiesListResponse, any>>;
        /**
         * @description Lists the available lobbies.
         *
         * @tags lobbies
         * @name LobbiesListPost
         * @request POST:/internal/lobbies.list
         * @secure
         */
        lobbiesListPost: (data: LobbiesListRequest, params?: RequestParams) => Promise<AxiosResponse<LobbiesListResponse, any>>;
        /**
         * @description Gets a marketplace category.
         *
         * @tags marketplace
         * @name MarketplaceCategoriesGet
         * @request GET:/internal/marketplace-categories.get
         * @secure
         */
        marketplaceCategoriesGet: (query: {
            /** The marketplace category ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<MarketplaceCategoriesGetResponse, any>>;
        /**
         * @description Gets a marketplace category.
         *
         * @tags marketplace
         * @name MarketplaceCategoriesGetPost
         * @request POST:/internal/marketplace-categories.get
         * @secure
         */
        marketplaceCategoriesGetPost: (data: MarketplaceCategoriesGetRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceCategoriesGetResponse, any>>;
        /**
         * @description Gets the categories for a marketplace.
         *
         * @tags marketplace
         * @name MarketplaceCategoriesList
         * @request GET:/internal/marketplace-categories.list
         * @secure
         */
        marketplaceCategoriesList: (query: {
            /** The marketplace ID. */
            marketplace_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<MarketplaceCategoriesListResponse, any>>;
        /**
         * @description Gets the categories for a marketplace.
         *
         * @tags marketplace
         * @name MarketplaceCategoriesListPost
         * @request POST:/internal/marketplace-categories.list
         * @secure
         */
        marketplaceCategoriesListPost: (data: MarketplaceCategoriesListRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceCategoriesListResponse, any>>;
        /**
         * @description Creates a marketplace item.
         *
         * @tags marketplace
         * @name MarketplaceItemsCreate
         * @request POST:/internal/marketplace-items.create
         * @secure
         */
        marketplaceItemsCreate: (data: MarketplaceItemsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsCreateResponse, any>>;
        /**
         * @description Deletes a marketplace item.
         *
         * @tags marketplace
         * @name MarketplaceItemsDelete
         * @request POST:/internal/marketplace-items.delete
         * @secure
         */
        marketplaceItemsDelete: (data: MarketplaceItemsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a marketplace item.
         *
         * @tags marketplace
         * @name MarketplaceItemsGet
         * @request GET:/internal/marketplace-items.get
         * @secure
         */
        marketplaceItemsGet: (query?: {
            /** The marketplace item's ID. */
            id?: string;
            /** Markteplace ID where to search a marketplace item by slug. */
            marketplace_id?: string;
            /** The marketplace item's slug. */
            slug?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsGetResponse, any>>;
        /**
         * @description Gets a marketplace item.
         *
         * @tags marketplace
         * @name MarketplaceItemsGetPost
         * @request POST:/internal/marketplace-items.get
         * @secure
         */
        marketplaceItemsGetPost: (data: MarketplaceItemsGetRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsGetResponse, any>>;
        /**
         * @description Installs a flow or vista for the marketplace item.
         *
         * @tags marketplace
         * @name MarketplaceItemsInstall
         * @request POST:/internal/marketplace-items.install
         * @secure
         */
        marketplaceItemsInstall: (data: MarketplaceItemsInstallRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsInstallResponse, any>>;
        /**
         * @description Gets the marketplace items.
         *
         * @tags marketplace
         * @name MarketplaceItemsList
         * @request GET:/internal/marketplace-items.list
         * @secure
         */
        marketplaceItemsList: (query?: {
            /**
             * To start listing marketplace items cursor field should not be
             * provided. Set cursor to value returned by the previous call to list
             * items in the next page.
             */
            cursor?: string;
            /**
             * Limit for how many items to be retrieved per page. Default is 50.
             * @format int32
             */
            limit?: number;
            /** Marketplace category where to list marketplace items. */
            marketplace_category_id?: string;
            /** Markteplace ID where to list marketplace items. */
            marketplace_id?: string;
            /**
             * List of fields to sort the marketplace item object, by and how to
             * sort them. Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsListResponse, any>>;
        /**
         * @description Gets the marketplace items.
         *
         * @tags marketplace
         * @name MarketplaceItemsListPost
         * @request POST:/internal/marketplace-items.list
         * @secure
         */
        marketplaceItemsListPost: (data: MarketplaceItemsListRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsListResponse, any>>;
        /**
         * @description Puts a marketplace item in desired state.
         *
         * @tags marketplace
         * @name MarketplaceItemsTransition
         * @request POST:/internal/marketplace-items.transition
         * @secure
         */
        marketplaceItemsTransition: (data: MarketplaceItemsTransitionRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsTransitionResponse, any>>;
        /**
         * @description Updates a marketplace item.
         *
         * @tags marketplace
         * @name MarketplaceItemsUpdate
         * @request POST:/internal/marketplace-items.update
         * @secure
         */
        marketplaceItemsUpdate: (data: MarketplaceItemsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplaceItemsUpdateResponse, any>>;
        /**
         * @description Gets a marketplace.
         *
         * @tags marketplace
         * @name MarketplacesGet
         * @request GET:/internal/marketplaces.get
         * @secure
         */
        marketplacesGet: (query: {
            /** The marketplace DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<MarketplacesGetResponse, any>>;
        /**
         * @description Gets a marketplace.
         *
         * @tags marketplace
         * @name MarketplacesGetPost
         * @request POST:/internal/marketplaces.get
         * @secure
         */
        marketplacesGetPost: (data: MarketplacesGetRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplacesGetResponse, any>>;
        /**
         * @description Gets the marketplaces.
         *
         * @tags marketplace
         * @name MarketplacesList
         * @request GET:/internal/marketplaces.list
         * @secure
         */
        marketplacesList: (params?: RequestParams) => Promise<AxiosResponse<MarketplacesListResponse, any>>;
        /**
         * @description Gets the marketplaces.
         *
         * @tags marketplace
         * @name MarketplacesListPost
         * @request POST:/internal/marketplaces.list
         * @secure
         */
        marketplacesListPost: (data: MarketplacesListRequest, params?: RequestParams) => Promise<AxiosResponse<MarketplacesListResponse, any>>;
        /**
         * @description Ingest endpoint for DevRev metrics data from clients.
         *
         * @tags telemetry
         * @name MetricsDevrevIngest
         * @request POST:/internal/metrics.devrev.ingest
         * @secure
         */
        metricsDevrevIngest: (data: MetricsDataIngestRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Write endpoint for OTLP metrics data from clients.
         *
         * @tags telemetry
         * @name MetricsOtlpWrite
         * @request POST:/internal/metrics.otlp.write
         * @secure
         */
        metricsOtlpWrite: (data: any, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Write endpoint for Prometheus metrics data from clients.
         *
         * @tags telemetry
         * @name MetricsPrometheusWrite
         * @request POST:/internal/metrics.prometheus.write
         * @secure
         */
        metricsPrometheusWrite: (data: any, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Seeds default configuration of groups, conditional roles and group members for the dev organization.
         *
         * @tags dev-orgs
         * @name MfzDefaultsSeed
         * @request POST:/internal/mfz-defaults.seed
         * @secure
         */
        mfzDefaultsSeed: (data: MfzDefaultsSeedRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Creates a microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsCreate
         * @request POST:/internal/microflows.create
         * @secure
         */
        microflowDefinitionsCreate: (data: MicroflowDefinitionsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsCreateResponse, any>>;
        /**
         * @description Deletes a microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsDelete
         * @request POST:/internal/microflows.delete
         * @secure
         */
        microflowDefinitionsDelete: (data: MicroflowDefinitionsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Creates a draft microflow corresponding to a published microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsCreateDraft
         * @request POST:/internal/microflows.draft.create
         * @secure
         */
        microflowDefinitionsCreateDraft: (data: MicroflowDefinitionsCreateDraftRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsCreateDraftResponse, any>>;
        /**
         * @description Gets a draft microflow associated with a published microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsGetDraft
         * @request GET:/internal/microflows.draft.get
         * @secure
         */
        microflowDefinitionsGetDraft: (query: {
            /** The published microflow's DON */
            published_microflow_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsGetDraftResponse, any>>;
        /**
         * @description Gets a draft microflow associated with a published microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsGetDraftPost
         * @request POST:/internal/microflows.draft.get
         * @secure
         */
        microflowDefinitionsGetDraftPost: (data: MicroflowDefinitionsGetDraftRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsGetDraftResponse, any>>;
        /**
         * @description Gets a draft microflow associated with a published microflow or creates one if does not exist.
         *
         * @tags microflows
         * @name MicroflowDefinitionsGetOrCreateDraft
         * @request POST:/internal/microflows.draft.getorcreate
         * @secure
         */
        microflowDefinitionsGetOrCreateDraft: (data: MicroflowDefinitionsGetOrCreateDraftRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsGetOrCreateDraftResponse, any>>;
        /**
         * @description Gets a microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsGet
         * @request GET:/internal/microflows.get
         * @secure
         */
        microflowDefinitionsGet: (query: {
            /** The microflow definition's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsGetResponse, any>>;
        /**
         * @description Gets a microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsGetPost
         * @request POST:/internal/microflows.get
         * @secure
         */
        microflowDefinitionsGetPost: (data: MicroflowDefinitionsGetRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsGetResponse, any>>;
        /**
         * @description Lists microflows for a Dev organization.
         *
         * @tags microflows
         * @name MicroflowDefinitionsList
         * @request GET:/internal/microflows.list
         * @secure
         */
        microflowDefinitionsList: (query?: {
            /**
             * Page number for paginated microflow definition items.
             * @format int32
             */
            page?: number;
            /**
             * Number of microflow definition items to return per page. Default is
             * 50.
             * @format int32
             */
            per_page?: number;
            /**
             * List of fields to sort the microflow definition items by and how to
             * sort them. Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsListResponse, any>>;
        /**
         * @description Lists microflows for a Dev organization.
         *
         * @tags microflows
         * @name MicroflowDefinitionsListPost
         * @request POST:/internal/microflows.list
         * @secure
         */
        microflowDefinitionsListPost: (data: MicroflowDefinitionsListRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsListResponse, any>>;
        /**
         * @description Publishes a microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsPublish
         * @request POST:/internal/microflows.publish
         * @secure
         */
        microflowDefinitionsPublish: (data: MicroflowDefinitionsPublishRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Creates state within a microflow.
         *
         * @tags microflows
         * @name MicroflowsTargetObjectStatesCreate
         * @request POST:/internal/microflows.states.create
         * @secure
         */
        microflowsTargetObjectStatesCreate: (data: MicroflowsTargetObjectStatesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowsTargetObjectStatesCreateResponse, any>>;
        /**
         * @description Deletes a state within a microflow.
         *
         * @tags microflows
         * @name MicroflowsTargetObjectStatesDelete
         * @request POST:/internal/microflows.states.delete
         * @secure
         */
        microflowsTargetObjectStatesDelete: (data: MicroflowsTargetObjectStatesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Updates a state within a microflow.
         *
         * @tags microflows
         * @name MicroflowsTargetObjectStatesUpdate
         * @request POST:/internal/microflows.states.update
         * @secure
         */
        microflowsTargetObjectStatesUpdate: (data: MicroflowsTargetObjectStatesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowsTargetObjectStatesUpdateResponse, any>>;
        /**
         * @description Creates a transition within a microflow.
         *
         * @tags microflows
         * @name MicroflowsTargetObjectTransitionsCreate
         * @request POST:/internal/microflows.transitions.create
         * @secure
         */
        microflowsTargetObjectTransitionsCreate: (data: MicroflowsTargetObjectTransitionsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowsTargetObjectTransitionsCreateResponse, any>>;
        /**
         * @description Deletes a transition within a microflow.
         *
         * @tags microflows
         * @name MicroflowsTargetObjectTransitionsDelete
         * @request POST:/internal/microflows.transitions.delete
         * @secure
         */
        microflowsTargetObjectTransitionsDelete: (data: MicroflowsTargetObjectTransitionsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Updates a transition within a microflow.
         *
         * @tags microflows
         * @name MicroflowsTargetObjectTransitionsUpdate
         * @request POST:/internal/microflows.transitions.update
         * @secure
         */
        microflowsTargetObjectTransitionsUpdate: (data: MicroflowsTargetObjectTransitionsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowsTargetObjectTransitionsUpdateResponse, any>>;
        /**
         * @description Updates a microflow.
         *
         * @tags microflows
         * @name MicroflowDefinitionsUpdate
         * @request POST:/internal/microflows.update
         * @secure
         */
        microflowDefinitionsUpdate: (data: MicroflowDefinitionsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<MicroflowDefinitionsUpdateResponse, any>>;
        /**
         * @description Creates a news item.
         *
         * @tags news
         * @name NewsCreate
         * @request POST:/internal/news.create
         * @secure
         */
        newsCreate: (data: NewsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<NewsCreateResponse, any>>;
        /**
         * @description Deletes a news item.
         *
         * @tags news
         * @name NewsDelete
         * @request POST:/internal/news.delete
         * @secure
         */
        newsDelete: (data: NewsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a news item.
         *
         * @tags news
         * @name NewsGet
         * @request GET:/internal/news.get
         * @secure
         */
        newsGet: (query: {
            /** The ID of the requested news item. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<NewsGetResponse, any>>;
        /**
         * @description Gets a news item.
         *
         * @tags news
         * @name NewsGetPost
         * @request POST:/internal/news.get
         * @secure
         */
        newsGetPost: (data: NewsGetRequest, params?: RequestParams) => Promise<AxiosResponse<NewsGetResponse, any>>;
        /**
         * @description Lists news items.
         *
         * @tags news
         * @name NewsList
         * @request GET:/internal/news.list
         * @secure
         */
        newsList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of news items to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
        }, params?: RequestParams) => Promise<AxiosResponse<NewsListResponse, any>>;
        /**
         * @description Lists news items.
         *
         * @tags news
         * @name NewsListPost
         * @request POST:/internal/news.list
         * @secure
         */
        newsListPost: (data: NewsListRequest, params?: RequestParams) => Promise<AxiosResponse<NewsListResponse, any>>;
        /**
         * @description Lists the notifications channels for Android.
         *
         * @tags notifications
         * @name NotificationsChannels
         * @request GET:/internal/notifications.channels
         * @secure
         */
        notificationsChannels: (query?: {
            /** The type of mobile device. */
            device_type?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<NotificationsChannelsResponse, any>>;
        /**
         * @description Lists the notifications channels for Android.
         *
         * @tags notifications
         * @name NotificationsChannelsPost
         * @request POST:/internal/notifications.channels
         * @secure
         */
        notificationsChannelsPost: (data: NotificationsChannelsRequest, params?: RequestParams) => Promise<AxiosResponse<NotificationsChannelsResponse, any>>;
        /**
         * @description Lists the notifications by groups.
         *
         * @tags notifications
         * @name NotificationsGroup
         * @request GET:/internal/notifications.group
         * @secure
         */
        notificationsGroup: (query: {
            /** The field to group the notifications by. */
            group_by: string;
            /**
             * Actor user IDs by which to filter the response.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            actor_ids?: string[];
            /**
             * The cursor from where to begin iteration. Start from beginning if not
             * provided.
             */
            cursor?: string;
            /** Notification IDs by which to filter the response. */
            ids?: string[];
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of notifications to return for an individual
             * group. Default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * Parent IDs by which to filter the response.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            parent_ids?: string[];
            /** Parent object types by which to filter the response. */
            parent_types?: NotificationParentType[];
            /** Comma-separated fields to sort the notifications by. */
            sort_by?: string[];
            /** Notification states by which to filter the response. */
            states?: NotificationState[];
            /** Notification types by which to filter the response. */
            types?: NotificationType[];
        }, params?: RequestParams) => Promise<AxiosResponse<NotificationsGroupResponse, any>>;
        /**
         * @description Lists the notifications by groups.
         *
         * @tags notifications
         * @name NotificationsGroupPost
         * @request POST:/internal/notifications.group
         * @secure
         */
        notificationsGroupPost: (data: NotificationsGroupRequest, params?: RequestParams) => Promise<AxiosResponse<NotificationsGroupResponse, any>>;
        /**
         * @description Lists the notifications.
         *
         * @tags notifications
         * @name NotificationsList
         * @request GET:/internal/notifications.list
         * @secure
         */
        notificationsList: (query?: {
            /**
             * Actor user IDs by which to filter the response.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            actor_ids?: string[];
            /**
             * The cursor from where to begin iteration. Start from beginning if not
             * provided.
             */
            cursor?: string;
            /** Notification IDs by which to filter the response. */
            ids?: string[];
            /**
             * The maximum number of notifications to return. Default is 50.
             * @format int32
             */
            limit?: number;
            /**
             * Parent IDs by which to filter the response.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            parent_ids?: string[];
            /** Parent object types by which to filter the response. */
            parent_types?: NotificationParentType[];
            /** Comma-separated fields to sort the notifications by. */
            sort_by?: string[];
            /** Notification states by which to filter the response. */
            states?: NotificationState[];
            /** Notification types by which to filter the response. */
            types?: NotificationType[];
        }, params?: RequestParams) => Promise<AxiosResponse<NotificationsListResponse, any>>;
        /**
         * @description Lists the notifications.
         *
         * @tags notifications
         * @name NotificationsListPost
         * @request POST:/internal/notifications.list
         * @secure
         */
        notificationsListPost: (data: NotificationsListRequest, params?: RequestParams) => Promise<AxiosResponse<NotificationsListResponse, any>>;
        /**
         * @description Updates the state of the notifications.
         *
         * @tags notifications
         * @name NotificationsMark
         * @request POST:/internal/notifications.mark
         * @secure
         */
        notificationsMark: (data: NotificationsMarkRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Generate a notification.
         *
         * @tags notifications
         * @name NotificationsSend
         * @request POST:/internal/notifications.send
         * @secure
         */
        notificationsSend: (data: NotificationsSendRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Returns the total count of the object members satisfying the request parameters.
         *
         * @tags object-members
         * @name CountObjectMember
         * @request GET:/internal/object-members.count
         * @secure
         */
        countObjectMember: (query?: {
            /**
             * The ID of the users or groups that must be a member of one of the
             * specified objects. If empty, then the result sums the total number of
             * members for each object.
             */
            member_ids?: string[];
            /**
             * The ID of the objects to count the members for. If empty, then the
             * result sums the total number of objects that each member is a part
             * of.
             */
            object_ids?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<CountObjectMemberResponse, any>>;
        /**
         * @description Returns the total count of the object members satisfying the request parameters.
         *
         * @tags object-members
         * @name CountObjectMemberPost
         * @request POST:/internal/object-members.count
         * @secure
         */
        countObjectMemberPost: (data: CountObjectMemberRequest, params?: RequestParams) => Promise<AxiosResponse<CountObjectMemberResponse, any>>;
        /**
         * @description Creates an object member.
         *
         * @tags object-members
         * @name CreateObjectMember
         * @request POST:/internal/object-members.create
         * @secure
         */
        createObjectMember: (data: CreateObjectMemberRequest, params?: RequestParams) => Promise<AxiosResponse<CreateObjectMemberResponse, any>>;
        /**
         * @description Gets an object member.
         *
         * @tags object-members
         * @name GetObjectMember
         * @request GET:/internal/object-members.get
         * @secure
         */
        getObjectMember: (query: {
            /** Globally unique DevRev Object Name (DON) for the Object Member. */
            object_member_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<GetObjectMemberResponse, any>>;
        /**
         * @description Gets an object member.
         *
         * @tags object-members
         * @name GetObjectMemberPost
         * @request POST:/internal/object-members.get
         * @secure
         */
        getObjectMemberPost: (data: GetObjectMemberRequest, params?: RequestParams) => Promise<AxiosResponse<GetObjectMemberResponse, any>>;
        /**
         * @description Lists object members satisfying the request parameters.
         *
         * @tags object-members
         * @name ListObjectMember
         * @request GET:/internal/object-members.list
         * @secure
         */
        listObjectMember: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of object members to return. If not set, then the
             * default is '50'.
             * @format int32
             */
            limit?: number;
            /** ID of the user or group. */
            member_ids?: string[];
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Globally unique DevRev Object Name (DON) for the object where the
             * member is being added.
             */
            object_ids?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ListObjectMemberResponse, any>>;
        /**
         * @description Lists object members satisfying the request parameters.
         *
         * @tags object-members
         * @name ListObjectMemberPost
         * @request POST:/internal/object-members.list
         * @secure
         */
        listObjectMemberPost: (data: ListObjectMemberRequest, params?: RequestParams) => Promise<AxiosResponse<ListObjectMemberResponse, any>>;
        /**
         * @description Removes an object member.
         *
         * @tags object-members
         * @name RemoveObjectMember
         * @request POST:/internal/object-members.remove
         * @secure
         */
        removeObjectMember: (data: RemoveObjectMemberRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the one time line item objects based on the given filters.
         *
         * @tags commerce
         * @name OneTimeItemsList
         * @request GET:/internal/one-time-line-items.list
         * @secure
         */
        oneTimeItemsList: (query?: {
            /** The list of one time line item DONs which are to be aggregated. */
            ids?: string[];
            /** Filter, invoiced vs un-invoiced service plan objects. */
            is_invoiced?: boolean;
            /**
             * The list of rev org DONs which are to be aggregated.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org_ids?: string[];
            /** The list of service plan DONs which are to be aggregated. */
            service_plan_ids?: string[];
            /**
             * List of fields to sort the one time line item object, by and how to
             * sort them. Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<OneTimeItemsListResponse, any>>;
        /**
         * @description Gets the one time line item objects based on the given filters.
         *
         * @tags commerce
         * @name OneTimeItemsListPost
         * @request POST:/internal/one-time-line-items.list
         * @secure
         */
        oneTimeItemsListPost: (data: OneTimeItemsListRequest, params?: RequestParams) => Promise<AxiosResponse<OneTimeItemsListResponse, any>>;
        /**
         * @description Lists top contributors of a part.
         *
         * @tags parts
         * @name PartsContributorsList
         * @request GET:/internal/parts.contributors.list
         * @secure
         */
        partsContributorsList: (query: {
            /**
             * The part's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id: string;
            /**
             * The maximum number of contributors to return. If not set, then the
             * default is '10'.
             * @format int32
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<PartsContributorsListResponse, any>>;
        /**
         * @description Lists top contributors of a part.
         *
         * @tags parts
         * @name PartsContributorsListPost
         * @request POST:/internal/parts.contributors.list
         * @secure
         */
        partsContributorsListPost: (data: PartsContributorsListRequest, params?: RequestParams) => Promise<AxiosResponse<PartsContributorsListResponse, any>>;
        /**
         * @description Get count of parts matching given filter.
         *
         * @tags parts
         * @name PartsCount
         * @request GET:/internal/parts.count
         * @secure
         */
        partsCount: (query?: {
            /** Filters for parts of the provided categories. */
            categories?: PartCategory[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'enhancement.target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'enhancement.target_close_date.before'?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters for parts of the provided name(s). */
            name?: string[];
            /**
             * Filters for parts owned by any of the provided users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for part with any of the provided states. */
            state?: string[];
            /**
             * Filters for parts with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** Filters for parts of the provided type(s). */
            type?: PartType[];
            /**
             * Filters for parts of the provided type(s).
             * @deprecated
             */
            types?: PartType[];
        }, params?: RequestParams) => Promise<AxiosResponse<PartsCountResponse, any>>;
        /**
         * @description Get count of parts matching given filter.
         *
         * @tags parts
         * @name PartsCountPost
         * @request POST:/internal/parts.count
         * @secure
         */
        partsCountPost: (data: PartsCountRequest, params?: RequestParams) => Promise<AxiosResponse<PartsCountResponse, any>>;
        /**
         * @description Creates new [part](https://devrev.ai/docs/product/parts).
         *
         * @tags parts
         * @name PartsCreate
         * @request POST:/internal/parts.create
         * @secure
         */
        partsCreate: (data: PartsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<PartsCreateResponse, any>>;
        /**
         * @description Lists top customers of a part.
         *
         * @tags parts
         * @name PartsCustomersList
         * @request GET:/internal/parts.customers.list
         * @secure
         */
        partsCustomersList: (query: {
            /**
             * The part's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id: string;
            /**
             * The maximum number of customers to return. If not set, then the
             * default is '10'.
             * @format int32
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<PartsCustomersListResponse, any>>;
        /**
         * @description Lists top customers of a part.
         *
         * @tags parts
         * @name PartsCustomersListPost
         * @request POST:/internal/parts.customers.list
         * @secure
         */
        partsCustomersListPost: (data: PartsCustomersListRequest, params?: RequestParams) => Promise<AxiosResponse<PartsCustomersListResponse, any>>;
        /**
         * @description Deletes a [part](https://devrev.ai/docs/product/parts).
         *
         * @tags parts
         * @name PartsDelete
         * @request POST:/internal/parts.delete
         * @secure
         */
        partsDelete: (data: PartsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Get links for part hierarchy
         *
         * @tags parts
         * @name PartsDescendantLinksTraverse
         * @request GET:/internal/parts.descendant-links.traverse
         * @secure
         */
        partsDescendantLinksTraverse: (query: {
            /**
             * ID of the part tree root to traverse links to descendant nodes from.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            root: string;
            /**
             * Cursor to begin iteration from. If empty, iteration will begin from
             * the beginning of the result set
             */
            cursor?: string;
            /**
             * Maximum number of link items to return. Default is 50.
             * @format int32
             */
            limit?: number;
            /**
             * If > 0, the maximum depth of the tree to traverse links from the
             * root.
             * @format int32
             */
            max_depth?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<PartsDescendantLinksTraverseResponse, any>>;
        /**
         * @description Get links for part hierarchy
         *
         * @tags parts
         * @name PartsDescendantLinksTraversePost
         * @request POST:/internal/parts.descendant-links.traverse
         * @secure
         */
        partsDescendantLinksTraversePost: (data: PartsDescendantLinksTraverseRequest, params?: RequestParams) => Promise<AxiosResponse<PartsDescendantLinksTraverseResponse, any>>;
        /**
         * @description Deletes API endpoints from a feature.
         *
         * @tags parts
         * @name PartsFeaturesApiEndpointsDelete
         * @request POST:/internal/parts.features.api-endpoints.delete
         * @secure
         */
        partsFeaturesApiEndpointsDelete: (data: PartsFeaturesApiEndpointsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<PartsFeaturesApiEndpointsDeleteResponse, any>>;
        /**
         * @description Merges API endpoints across two features.
         *
         * @tags parts
         * @name PartsFeaturesApiEndpointsMerge
         * @request POST:/internal/parts.features.api-endpoints.merge
         * @secure
         */
        partsFeaturesApiEndpointsMerge: (data: PartsFeaturesApiEndpointsMergeRequest, params?: RequestParams) => Promise<AxiosResponse<PartsFeaturesApiEndpointsMergeResponse, any>>;
        /**
         * @description Deletes API operations from a feature.
         *
         * @tags parts
         * @name PartsFeaturesApiOperationsDelete
         * @request POST:/internal/parts.features.api-operations.delete
         * @secure
         */
        partsFeaturesApiOperationsDelete: (data: PartsFeaturesApiOperationsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<PartsFeaturesApiOperationsDeleteResponse, any>>;
        /**
         * @description Merges API operations across two features.
         *
         * @tags parts
         * @name PartsFeaturesApiOperationsMerge
         * @request POST:/internal/parts.features.api-operations.merge
         * @secure
         */
        partsFeaturesApiOperationsMerge: (data: PartsFeaturesApiOperationsMergeRequest, params?: RequestParams) => Promise<AxiosResponse<PartsFeaturesApiOperationsMergeResponse, any>>;
        /**
         * @description Gets a [part's](https://devrev.ai/docs/product/parts) information.
         *
         * @tags parts
         * @name PartsGet
         * @request GET:/internal/parts.get
         * @secure
         */
        partsGet: (query: {
            /**
             * The ID of the part to retrieve.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<PartsGetResponse, any>>;
        /**
         * @description Gets a [part's](https://devrev.ai/docs/product/parts) information.
         *
         * @tags parts
         * @name PartsGetPost
         * @request POST:/internal/parts.get
         * @secure
         */
        partsGetPost: (data: PartsGetRequest, params?: RequestParams) => Promise<AxiosResponse<PartsGetResponse, any>>;
        /**
         * @description Lists collections of parts by groups.
         *
         * @tags parts
         * @name PartsGroup
         * @request GET:/internal/parts.group
         * @secure
         */
        partsGroup: (query: {
            /** The field to group the parts by. */
            group_by: string;
            /** Filters for parts of the provided categories. */
            categories?: PartCategory[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'enhancement.target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'enhancement.target_close_date.before'?: string;
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of parts to return for an individual group. If not
             * set, then the default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters for parts of the provided name(s). */
            name?: string[];
            /**
             * Filters for parts owned by any of the provided users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** Comma-separated fields to sort the parts by. */
            sort_by?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for part with any of the provided states. */
            state?: string[];
            /**
             * Filters for parts with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** Filters for parts of the provided type(s). */
            type?: PartType[];
            /**
             * Filters for parts of the provided type(s).
             * @deprecated
             */
            types?: PartType[];
        }, params?: RequestParams) => Promise<AxiosResponse<PartsGroupResponse, any>>;
        /**
         * @description Lists collections of parts by groups.
         *
         * @tags parts
         * @name PartsGroupPost
         * @request POST:/internal/parts.group
         * @secure
         */
        partsGroupPost: (data: PartsGroupRequest, params?: RequestParams) => Promise<AxiosResponse<PartsGroupResponse, any>>;
        /**
         * @description Lists a collection of [parts](https://devrev.ai/docs/product/parts).
         *
         * @tags parts
         * @name PartsList
         * @request GET:/internal/parts.list
         * @secure
         */
        partsList: (query?: {
            /** Filters for parts of the provided categories. */
            categories?: PartCategory[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'enhancement.target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'enhancement.target_close_date.before'?: string;
            /**
             * The maximum number of parts to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters for parts of the provided name(s). */
            name?: string[];
            /**
             * Filters for parts owned by any of the provided users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** Fields to sort the parts by and the direction to sort them. */
            sort_by?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for part with any of the provided states. */
            state?: string[];
            /**
             * Filters for parts with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** Filters for parts of the provided type(s). */
            type?: PartType[];
            /**
             * Filters for parts of the provided type(s).
             * @deprecated
             */
            types?: PartType[];
        }, params?: RequestParams) => Promise<AxiosResponse<PartsListResponse, any>>;
        /**
         * @description Lists a collection of [parts](https://devrev.ai/docs/product/parts).
         *
         * @tags parts
         * @name PartsListPost
         * @request POST:/internal/parts.list
         * @secure
         */
        partsListPost: (data: PartsListRequest, params?: RequestParams) => Promise<AxiosResponse<PartsListResponse, any>>;
        /**
         * @description Mutate a part to either promote or merge it.
         *
         * @tags parts
         * @name PartsMutate
         * @request GET:/internal/parts.mutate
         * @secure
         */
        partsMutate: (query: {
            /**
             * ID of the part to be mutated.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<PartsMutateResponse, any>>;
        /**
         * @description Mutate a part to either promote or merge it.
         *
         * @tags parts
         * @name PartsMutatePost
         * @request POST:/internal/parts.mutate
         * @secure
         */
        partsMutatePost: (data: PartsMutateRequest, params?: RequestParams) => Promise<AxiosResponse<PartsMutateResponse, any>>;
        /**
         * @description Lists top supporters of a part.
         *
         * @tags parts
         * @name PartsSupportersList
         * @request GET:/internal/parts.supporters.list
         * @secure
         */
        partsSupportersList: (query: {
            /**
             * The part's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id: string;
            /**
             * The maximum number of supporters to return. If not set, then the
             * default is '10'.
             * @format int32
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<PartsSupportersListResponse, any>>;
        /**
         * @description Lists top supporters of a part.
         *
         * @tags parts
         * @name PartsSupportersListPost
         * @request POST:/internal/parts.supporters.list
         * @secure
         */
        partsSupportersListPost: (data: PartsSupportersListRequest, params?: RequestParams) => Promise<AxiosResponse<PartsSupportersListResponse, any>>;
        /**
         * @description Updates a [part's](https://devrev.ai/docs/product/parts) information.
         *
         * @tags parts
         * @name PartsUpdate
         * @request POST:/internal/parts.update
         * @secure
         */
        partsUpdate: (data: PartsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<PartsUpdateResponse, any>>;
        /**
         * @description Update payment intent object.
         *
         * @tags commerce
         * @name PaymentIntentsUpdate
         * @request POST:/internal/payment-intents.update
         * @secure
         */
        paymentIntentsUpdate: (data: PaymentIntentsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Deletes the payment method from the customer configuration.
         *
         * @tags commerce
         * @name PaymentMethodsDelete
         * @request POST:/internal/payment-methods.delete
         * @secure
         */
        paymentMethodsDelete: (data: PaymentMethodsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Returns the payment method.
         *
         * @tags commerce
         * @name PaymentMethodsGet
         * @request GET:/internal/payment-methods.get
         * @secure
         */
        paymentMethodsGet: (query: {
            /** The payment method's DON */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<PaymentMethodsGetResponse, any>>;
        /**
         * @description Returns the payment method.
         *
         * @tags commerce
         * @name PaymentMethodsGetPost
         * @request POST:/internal/payment-methods.get
         * @secure
         */
        paymentMethodsGetPost: (data: PaymentMethodsGetRequest, params?: RequestParams) => Promise<AxiosResponse<PaymentMethodsGetResponse, any>>;
        /**
         * @description List payment methods for a customer.
         *
         * @tags commerce
         * @name PaymentMethodsList
         * @request GET:/internal/payment-methods.list
         * @secure
         */
        paymentMethodsList: (params?: RequestParams) => Promise<AxiosResponse<PaymentMethodsListResponse, any>>;
        /**
         * @description List payment methods for a customer.
         *
         * @tags commerce
         * @name PaymentMethodsListPost
         * @request POST:/internal/payment-methods.list
         * @secure
         */
        paymentMethodsListPost: (data: Empty, params?: RequestParams) => Promise<AxiosResponse<PaymentMethodsListResponse, any>>;
        /**
         * @description Sets the payment method as default in the customer configuration.
         *
         * @tags commerce
         * @name PaymentMethodsSetDefault
         * @request POST:/internal/payment-methods.set-default
         * @secure
         */
        paymentMethodsSetDefault: (data: PaymentMethodsSetDefaultRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Setup intent initiates the process of saving a payment method details in the customer's configuration. The API returns a client key which is to be used on the front end side to call Stripe to verify and save the user entered payment method details for the customer on Stripe.
         *
         * @tags commerce
         * @name PaymentMethodsSetupIntentCreate
         * @request POST:/internal/payment-methods.setup-intent.create
         * @secure
         */
        paymentMethodsSetupIntentCreate: (data: PaymentMethodsSetupIntentCreateRequest, params?: RequestParams) => Promise<AxiosResponse<PaymentMethodsSetupIntentCreateResponse, any>>;
        /**
         * @description Lists the preferences defined for a particular object.
         *
         * @tags preferences
         * @name PreferencesList
         * @request GET:/internal/preferences.list
         * @secure
         */
        preferencesList: (query: {
            /**
             * The ID of the object for which the preferences are to be listed.
             * @example "don:<partition>:identity:devo/<dev-org-id>"
             */
            object: string;
        }, params?: RequestParams) => Promise<AxiosResponse<PreferencesListResponse, any>>;
        /**
         * @description Lists the preferences defined for a particular object.
         *
         * @tags preferences
         * @name PreferencesListPost
         * @request POST:/internal/preferences.list
         * @secure
         */
        preferencesListPost: (data: PreferencesListRequest, params?: RequestParams) => Promise<AxiosResponse<PreferencesListResponse, any>>;
        /**
         * @description Lists the preferences snap kit JSON for a particular object.
         *
         * @tags preferences
         * @name PreferencesSnapKitList
         * @request GET:/internal/preferences.snap-kit.list
         * @secure
         */
        preferencesSnapKitList: (query: {
            /**
             * The ID of the object for which the preferences snap kit is to be
             * fetched.
             * @example "don:<partition>:identity:devo/<dev-org-id>"
             */
            object: string;
        }, params?: RequestParams) => Promise<AxiosResponse<PreferencesSnapKitListResponse, any>>;
        /**
         * @description Lists the preferences snap kit JSON for a particular object.
         *
         * @tags preferences
         * @name PreferencesSnapKitListPost
         * @request POST:/internal/preferences.snap-kit.list
         * @secure
         */
        preferencesSnapKitListPost: (data: PreferencesSnapKitListRequest, params?: RequestParams) => Promise<AxiosResponse<PreferencesSnapKitListResponse, any>>;
        /**
         * @description Updates the preference for a particular object.
         *
         * @tags preferences
         * @name PreferencesUpdate
         * @request POST:/internal/preferences.update
         * @secure
         */
        preferencesUpdate: (data: PreferencesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<PreferencesUpdateResponse, any>>;
        /**
         * @description Creates a pricing object.
         *
         * @tags commerce
         * @name PricingsCreate
         * @request POST:/internal/pricings.create
         * @secure
         */
        pricingsCreate: (data: PricingsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<PricingsCreateResponse, any>>;
        /**
         * @description Deletes a pricing object.
         *
         * @tags commerce
         * @name PricingsDelete
         * @request POST:/internal/pricings.delete
         * @secure
         */
        pricingsDelete: (data: PricingsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a pricing object.
         *
         * @tags commerce
         * @name PricingsGet
         * @request GET:/internal/pricings.get
         * @secure
         */
        pricingsGet: (query: {
            /** The pricing object's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<PricingsGetResponse, any>>;
        /**
         * @description Gets a pricing object.
         *
         * @tags commerce
         * @name PricingsGetPost
         * @request POST:/internal/pricings.get
         * @secure
         */
        pricingsGetPost: (data: PricingsGetRequest, params?: RequestParams) => Promise<AxiosResponse<PricingsGetResponse, any>>;
        /**
         * @description Gets the pricing objects based on the given filters.
         *
         * @tags commerce
         * @name PricingsList
         * @request GET:/internal/pricings.list
         * @secure
         */
        pricingsList: (query?: {
            /** The list of pricing DONs which are to be aggregated. */
            ids?: string[];
            /** Filter, active vs inactive pricing objects. */
            is_active?: boolean;
            /**
             * The list of rev org DONs which are to be aggregated.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org_ids?: string[];
            /** The list of sku DONs which are to be aggregated. */
            sku_ids?: string[];
            /**
             * List of fields to sort the pricing object, by and how to sort them.
             * Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<PricingsListResponse, any>>;
        /**
         * @description Gets the pricing objects based on the given filters.
         *
         * @tags commerce
         * @name PricingsListPost
         * @request POST:/internal/pricings.list
         * @secure
         */
        pricingsListPost: (data: PricingsListRequest, params?: RequestParams) => Promise<AxiosResponse<PricingsListResponse, any>>;
        /**
         * @description Updates a pricing object.
         *
         * @tags commerce
         * @name PricingsUpdate
         * @request POST:/internal/pricings.update
         * @secure
         */
        pricingsUpdate: (data: PricingsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<PricingsUpdateResponse, any>>;
        /**
         * @description DevRev Profile is a user's personal profile to promote themselves and connect with other professionals. This method returns a successful response if a profile is created with a unique email and display handle. If another login option with same email is used, the existing profile is updated. Otherwise, the method returns conflict response due to already existing profile. Also, the method requires authorization token obtained from DevRev platform through the login workflow.
         *
         * @tags profiles
         * @name ProfilesCreate
         * @request POST:/internal/profiles.create
         * @secure
         */
        profilesCreate: (data: ProfilesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ProfilesCreateResponse, any>>;
        /**
         * @description Gets the profile's public information of a user on the DevRev platform using display-handle. The method returns not-found response if the profile's visibility is private or if it does not exist. Also note that display-handle can also be changed by the user.
         *
         * @tags profiles
         * @name ProfilesGetByHandle
         * @request GET:/internal/profiles.get-by-handle
         */
        profilesGetByHandle: (query: {
            /** The display handle of the profile to get. */
            display_handle: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ProfilesGetByHandleResponse, any>>;
        /**
         * @description Gets the profile's public information of a user on the DevRev platform using display-handle. The method returns not-found response if the profile's visibility is private or if it does not exist. Also note that display-handle can also be changed by the user.
         *
         * @tags profiles
         * @name ProfilesGetByHandlePost
         * @request POST:/internal/profiles.get-by-handle
         * @secure
         */
        profilesGetByHandlePost: (data: ProfilesGetByHandleRequest, params?: RequestParams) => Promise<AxiosResponse<ProfilesGetByHandleResponse, any>>;
        /**
         * @description Checks to ensure that the desired display handle is not already in use. This does not secure the handle, so it is possible that the check would be successful and a subsequent call to create a profile with the checked display handle might fail due to a race condition.
         *
         * @tags profiles
         * @name ProfilesIsDisplayHandleAvailable
         * @request GET:/internal/profiles.is-display-handle-available
         * @secure
         */
        profilesIsDisplayHandleAvailable: (query: {
            /** Display handles are used to uniquely identify the users. */
            display_handle: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ProfilesIsDisplayHandleAvailableResponse, any>>;
        /**
         * @description Checks to ensure that the desired display handle is not already in use. This does not secure the handle, so it is possible that the check would be successful and a subsequent call to create a profile with the checked display handle might fail due to a race condition.
         *
         * @tags profiles
         * @name ProfilesIsDisplayHandleAvailablePost
         * @request POST:/internal/profiles.is-display-handle-available
         * @secure
         */
        profilesIsDisplayHandleAvailablePost: (data: ProfilesIsDisplayHandleAvailableRequest, params?: RequestParams) => Promise<AxiosResponse<ProfilesIsDisplayHandleAvailableResponse, any>>;
        /**
         * @description Gets the currently logged in user's profile information.
         *
         * @tags profiles
         * @name ProfilesSelf
         * @request GET:/internal/profiles.self
         * @secure
         */
        profilesSelf: (params?: RequestParams) => Promise<AxiosResponse<ProfilesSelfResponse, any>>;
        /**
         * @description Gets the currently logged in user's profile information.
         *
         * @tags profiles
         * @name ProfilesSelfPost
         * @request POST:/internal/profiles.self
         * @secure
         */
        profilesSelfPost: (data: ProfilesSelfRequest, params?: RequestParams) => Promise<AxiosResponse<ProfilesSelfResponse, any>>;
        /**
         * @description Deletes the currently logged in user profile from the DevRev platform.
         *
         * @tags profiles
         * @name ProfilesSelfDelete
         * @request POST:/internal/profiles.self.delete
         * @secure
         */
        profilesSelfDelete: (data: ProfilesSelfDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Updates the currently logged-in user's profile information. Beware, the links to your profile page will return a not-found error on changing your display-handle. Also, your old display-handle becomes available for anyone else to claim.
         *
         * @tags profiles
         * @name ProfilesSelfUpdate
         * @request POST:/internal/profiles.self.update
         * @secure
         */
        profilesSelfUpdate: (data: ProfilesSelfUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<ProfilesSelfUpdateResponse, any>>;
        /**
         * @description Registers a push device.
         *
         * @tags notifications
         * @name PushDevicesRegister
         * @request POST:/internal/push-devices.register
         * @secure
         */
        pushDevicesRegister: (data: PushDevicesRegisterRequest, params?: RequestParams) => Promise<AxiosResponse<PushDevicesRegisterResponse, any>>;
        /**
         * @description Unregisters a push device.
         *
         * @tags notifications
         * @name PushDevicesUnregister
         * @request POST:/internal/push-devices.unregister
         * @secure
         */
        pushDevicesUnregister: (data: PushDevicesUnregisterRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Updates the timestamp on a device.
         *
         * @tags notifications
         * @name PushDevicesUpdate
         * @request POST:/internal/push-devices.update
         * @secure
         */
        pushDevicesUpdate: (data: PushDevicesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<PushDevicesUpdateResponse, any>>;
        /**
         * @description Adds a reaction to an object.
         *
         * @tags timeline-entries, works
         * @name ReactionsAdd
         * @request POST:/internal/reactions.add
         * @secure
         */
        reactionsAdd: (data: ReactionsAddRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description List the reactions for an object.
         *
         * @tags timeline-entries, works
         * @name ReactionsList
         * @request GET:/internal/reactions.list
         * @secure
         */
        reactionsList: (query: {
            /** The emoji to list reactions for. */
            emoji: string;
            /**
             * The ID of the object to list reactions to.
             * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
             */
            object: string;
            /**
             * The cursor to resume iteration from, otherwise if not provided, then
             * iteration starts from the beginning.
             */
            cursor?: string;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
        }, params?: RequestParams) => Promise<AxiosResponse<ReactionsListResponse, any>>;
        /**
         * @description List the reactions for an object.
         *
         * @tags timeline-entries, works
         * @name ReactionsListPost
         * @request POST:/internal/reactions.list
         * @secure
         */
        reactionsListPost: (data: ReactionsListRequest, params?: RequestParams) => Promise<AxiosResponse<ReactionsListResponse, any>>;
        /**
         * @description Removes a reaction from an object.
         *
         * @tags timeline-entries, works
         * @name ReactionsRemove
         * @request POST:/internal/reactions.remove
         * @secure
         */
        reactionsRemove: (data: ReactionsRemoveRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Lists suggestions for given input fields.
         *
         * @tags recommendations
         * @name AutoSuggest
         * @request POST:/internal/recommendations.autosuggest
         * @secure
         */
        autoSuggest: (data: AutoSuggestRequest, params?: RequestParams) => Promise<AxiosResponse<AutoSuggestResponse, any>>;
        /**
         * @description Lists link target recommendations.
         *
         * @tags recommendations
         * @name LinkTarget
         * @request POST:/internal/recommendations.link.target
         * @secure
         */
        linkTarget: (data: LinkTargetRequest, params?: RequestParams) => Promise<AxiosResponse<LinkTargetResponse, any>>;
        /**
         * @description Lists personalized work items for a user.
         *
         * @tags recommendations
         * @name PersonalizedList
         * @request POST:/internal/recommendations.personalized.list
         * @secure
         */
        personalizedList: (data: PersonalizedListRequest, params?: RequestParams) => Promise<AxiosResponse<PersonalizedListResponse, any>>;
        /**
         * @description Typeahead recommendation.
         *
         * @tags recommendations
         * @name TypeAhead
         * @request POST:/internal/recommendations.typeahead
         * @secure
         */
        typeAhead: (data: TypeAheadRequest, params?: RequestParams) => Promise<AxiosResponse<TypeAheadResponse, any>>;
        /**
         * @description Lists similar work items.
         *
         * @tags recommendations
         * @name WorkDeflect
         * @request POST:/internal/recommendations.works.deflect
         * @secure
         */
        workDeflect: (data: WorkDeflectRequest, params?: RequestParams) => Promise<AxiosResponse<WorkDeflectResponse, any>>;
        /**
         * @description Gets a Rev org's commerce details.
         *
         * @tags commerce
         * @name RevOrgsCommerceDetailsGet
         * @request GET:/internal/rev-orgs.commerce-details.get
         * @secure
         */
        revOrgsCommerceDetailsGet: (query?: {
            /**
             * The rev org's DON.
             * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
             */
            id?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RevOrgsCommerceDetailsGetResponse, any>>;
        /**
         * @description Gets a Rev org's commerce details.
         *
         * @tags commerce
         * @name RevOrgsCommerceDetailsGetPost
         * @request POST:/internal/rev-orgs.commerce-details.get
         * @secure
         */
        revOrgsCommerceDetailsGetPost: (data: RevOrgsCommerceDetailsGetRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsCommerceDetailsGetResponse, any>>;
        /**
         * @description Updates a Rev org's commerce details.
         *
         * @tags commerce
         * @name RevOrgsCommerceDetailsUpdate
         * @request POST:/internal/rev-orgs.commerce-details.update
         * @secure
         */
        revOrgsCommerceDetailsUpdate: (data: RevOrgsCommerceDetailsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsCommerceDetailsUpdateResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Gets the count of Rev organizations matching given filter.
         *
         * @tags rev-orgs
         * @name RevOrgsCount
         * @request GET:/internal/rev-orgs.count
         * @secure
         */
        revOrgsCount: (query?: {
            /** Filters by account. */
            account?: string[];
            /** Filters by creator. */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
             */
            custom_field_filter?: string[];
            /** Array of domain for Rev organizations to be filtered. */
            domain?: string[];
            /** Environment values to be filtered. */
            environment?: OrgEnvironment[];
            /** Array of external ref for Rev organizations to be filtered. */
            external_ref?: string[];
            /** Array of external ref issuers for Rev organizations to be filtered. */
            external_ref_issuer?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters by owners. */
            owned_by?: string[];
            /**
             * Filters by owners.
             * @deprecated
             */
            owned_by_ids?: string[];
            /** State values to be filtered. */
            state?: OrgState[];
            /**
             * Filters on tags. Input will be of the format (tags=<tag id
             * 1>=<value>&tags=<tag id 2>)
             */
            tags?: string[];
            /** Array of tier for Rev organizations to be filtered. */
            tier?: string[];
            /** Types of Rev organizations to be filtered. */
            type?: RevOrgType[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevOrgsCountResponse, any>>;
        /**
         * @description Gets the count of Rev organizations matching given filter.
         *
         * @tags rev-orgs
         * @name RevOrgsCountPost
         * @request POST:/internal/rev-orgs.count
         * @secure
         */
        revOrgsCountPost: (data: RevOrgsCountRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsCountResponse, any>>;
        /**
         * @description Creates a Rev organization in the authenticated user's Dev organization.
         *
         * @tags rev-orgs
         * @name RevOrgsCreate
         * @request POST:/internal/rev-orgs.create
         * @secure
         */
        revOrgsCreate: (data: RevOrgsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsCreateResponse, any>>;
        /**
         * @description Creates bulk Rev organizations for the authenticated user's Dev organization.
         *
         * @tags rev-orgs
         * @name RevOrgsBulkCreate
         * @request POST:/internal/rev-orgs.create.bulk.csv
         * @secure
         */
        revOrgsBulkCreate: (data: RevOrgsBulkCreateRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsBulkCreateResponse, any>>;
        /**
         * @description Deletes the Rev organization.
         *
         * @tags rev-orgs
         * @name RevOrgsDelete
         * @request POST:/internal/rev-orgs.delete
         * @secure
         */
        revOrgsDelete: (data: RevOrgsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Exports a list of revorgs.
         *
         * @tags rev-orgs
         * @name RevOrgsExport
         * @request POST:/internal/rev-orgs.export
         * @secure
         */
        revOrgsExport: (data: RevOrgsExportRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsExportResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Retrieves the Rev organization's information.
         *
         * @tags rev-orgs
         * @name RevOrgsGet
         * @request GET:/internal/rev-orgs.get
         * @secure
         */
        revOrgsGet: (query: {
            /**
             * The ID of the required Rev organization.
             * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RevOrgsGetResponse, any>>;
        /**
         * @description Retrieves the Rev organization's information.
         *
         * @tags rev-orgs
         * @name RevOrgsGetPost
         * @request POST:/internal/rev-orgs.get
         * @secure
         */
        revOrgsGetPost: (data: RevOrgsGetRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsGetResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Lists collections of Rev organizations by groups.
         *
         * @tags rev-orgs
         * @name RevOrgsGroup
         * @request GET:/internal/rev-orgs.group
         * @secure
         */
        revOrgsGroup: (query: {
            /** The field to group the rev orgs by. */
            group_by: string;
            /** Filters by account. */
            account?: string[];
            /** Filters by creator. */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
             */
            custom_field_filter?: string[];
            /** Array of domain for Rev organizations to be filtered. */
            domain?: string[];
            /** Environment values to be filtered. */
            environment?: OrgEnvironment[];
            /** Array of external ref for Rev organizations to be filtered. */
            external_ref?: string[];
            /** Array of external ref issuers for Rev organizations to be filtered. */
            external_ref_issuer?: string[];
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of rev orgs to return for an individual group. If
             * not set, then the default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters by owners. */
            owned_by?: string[];
            /**
             * Filters by owners.
             * @deprecated
             */
            owned_by_ids?: string[];
            /** Fields to sort the rev orgs by. */
            sort_by?: string[];
            /** State values to be filtered. */
            state?: OrgState[];
            /**
             * Filters on tags. Input will be of the format (tags=<tag id
             * 1>=<value>&tags=<tag id 2>)
             */
            tags?: string[];
            /** Array of tier for Rev organizations to be filtered. */
            tier?: string[];
            /** Types of Rev organizations to be filtered. */
            type?: RevOrgType[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevOrgsGroupResponse, any>>;
        /**
         * @description Lists collections of Rev organizations by groups.
         *
         * @tags rev-orgs
         * @name RevOrgsGroupPost
         * @request POST:/internal/rev-orgs.group
         * @secure
         */
        revOrgsGroupPost: (data: RevOrgsGroupRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsGroupResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Gets the list of Rev organizations' information belonging to the authenticated user's Dev Organization which the user is also authorized to access.
         *
         * @tags rev-orgs
         * @name RevOrgsList
         * @request GET:/internal/rev-orgs.list
         * @secure
         */
        revOrgsList: (query?: {
            /** Filters by account. */
            account?: string[];
            /** Filters by creator. */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
             */
            custom_field_filter?: string[];
            /** Array of domain for Rev organizations to be filtered. */
            domain?: string[];
            /** Environment values to be filtered. */
            environment?: OrgEnvironment[];
            /** Array of external ref for Rev organizations to be filtered. */
            external_ref?: string[];
            /** Array of external ref issuers for Rev organizations to be filtered. */
            external_ref_issuer?: string[];
            /**
             * The maximum number of Rev organizations to be retrieved per page.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Filters by owners. */
            owned_by?: string[];
            /**
             * Filters by owners.
             * @deprecated
             */
            owned_by_ids?: string[];
            /**
             * Fields to sort the Rev organizations by and the direction to sort
             * them.
             */
            sort_by?: string[];
            /** State values to be filtered. */
            state?: OrgState[];
            /**
             * Filters on tags. Input will be of the format (tags=<tag id
             * 1>=<value>&tags=<tag id 2>)
             */
            tags?: string[];
            /** Array of tier for Rev organizations to be filtered. */
            tier?: string[];
            /** Types of Rev organizations to be filtered. */
            type?: RevOrgType[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevOrgsListResponse, any>>;
        /**
         * @description Gets the list of Rev organizations' information belonging to the authenticated user's Dev Organization which the user is also authorized to access.
         *
         * @tags rev-orgs
         * @name RevOrgsListPost
         * @request POST:/internal/rev-orgs.list
         * @secure
         */
        revOrgsListPost: (data: RevOrgsListRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsListResponse, any>>;
        /**
         * @description Updates the Rev organization's information.
         *
         * @tags rev-orgs
         * @name RevOrgsUpdate
         * @request POST:/internal/rev-orgs.update
         * @secure
         */
        revOrgsUpdate: (data: RevOrgsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<RevOrgsUpdateResponse, any>>;
        /**
         * @description Gets the list of Rev users' information across all Rev organizations in user's Dev organization.
         *
         * @tags rev-users
         * @name RevUsersListAll
         * @request GET:/internal/rev-users.all.list
         * @secure
         */
        revUsersListAll: (query?: {
            /** Filters for Rev users that were created by the specified user(s). */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
             */
            custom_field_filter?: string[];
            /** List of emails of Rev users to be filtered. */
            email?: string[];
            /** List of external ref for Rev users to be filtered. */
            external_ref?: string[];
            /** List of external ref issuers for Rev users to be filtered. */
            external_ref_issuer?: string[];
            /**
             * The maximum number of Rev users to return per page. The default is
             * '50', the maximum is '100'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * Array of display id's of Rev orgs to be filtered.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_oid?: string[];
            /**
             * Array of ID's of Rev orgs to be filtered.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /** Fields to sort the Rev users by and the direction to sort them. */
            sort_by?: string[];
            /** List of state of Rev users to be filtered. */
            state?: UserState[];
            /**
             * List of tags to be filtered. Input will be of the format (tags=<tag
             * id 1>=<value>&tags=<tag id 2>).
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevUsersListAllResponse, any>>;
        /**
         * @description Gets the list of Rev users' information across all Rev organizations in user's Dev organization.
         *
         * @tags rev-users
         * @name RevUsersListAllPost
         * @request POST:/internal/rev-users.all.list
         * @secure
         */
        revUsersListAllPost: (data: RevUsersListAllRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersListAllResponse, any>>;
        /**
         * @description ### Owner: akanksha.deswal@devrev.ai ### Gets the count of Rev users matching given filter.
         *
         * @tags rev-users
         * @name RevUsersCount
         * @request GET:/internal/rev-users.count
         * @secure
         */
        revUsersCount: (query?: {
            /** Filters for Rev users that were created by the specified user(s). */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
             */
            custom_field_filter?: string[];
            /** List of emails of Rev users to be filtered. */
            email?: string[];
            /** List of external ref for Rev users to be filtered. */
            external_ref?: string[];
            /** List of external ref issuers for Rev users to be filtered. */
            external_ref_issuer?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * List of Rev organizations IDs for Rev users to be filtered.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /** List of state of Rev users to be filtered. */
            state?: UserState[];
            /**
             * List of tags to be filtered. Input will be of the format (tags=<tag
             * id 1>=<value>&tags=<tag id 2>).
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevUsersCountResponse, any>>;
        /**
         * @description Gets the count of Rev users matching given filter.
         *
         * @tags rev-users
         * @name RevUsersCountPost
         * @request POST:/internal/rev-users.count
         * @secure
         */
        revUsersCountPost: (data: RevUsersCountRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersCountResponse, any>>;
        /**
         * @description Creates a Rev user for a Rev organization. Rev user can be a customer or a lead of an organization.
         *
         * @tags rev-users
         * @name RevUsersCreate
         * @request POST:/internal/rev-users.create
         * @secure
         */
        revUsersCreate: (data: RevUsersCreateRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersCreateResponse, any>>;
        /**
         * @description Deletes a Rev user.
         *
         * @tags rev-users
         * @name RevUsersDelete
         * @request POST:/internal/rev-users.delete
         * @secure
         */
        revUsersDelete: (data: RevUsersDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Returns the Rev user of a Rev organization by its ID.
         *
         * @tags rev-users
         * @name RevUsersGet
         * @request GET:/internal/rev-users.get
         * @secure
         */
        revUsersGet: (query: {
            /** The ID of Rev user to be retrieved. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RevUsersGetResponse, any>>;
        /**
         * @description Returns the Rev user of a Rev organization by its ID.
         *
         * @tags rev-users
         * @name RevUsersGetPost
         * @request POST:/internal/rev-users.get
         * @secure
         */
        revUsersGetPost: (data: RevUsersGetRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersGetResponse, any>>;
        /**
         * @description Lists collections of Rev users by groups.
         *
         * @tags rev-users
         * @name RevUsersGroup
         * @request GET:/internal/rev-users.group
         * @secure
         */
        revUsersGroup: (query: {
            /** The field to group the rev users by. */
            group_by: string;
            /** Filters for Rev users that were created by the specified user(s). */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
             */
            custom_field_filter?: string[];
            /** List of emails of Rev users to be filtered. */
            email?: string[];
            /** List of external ref for Rev users to be filtered. */
            external_ref?: string[];
            /** List of external ref issuers for Rev users to be filtered. */
            external_ref_issuer?: string[];
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of rev users to return for an individual group. If
             * not set, then the default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /** Array of display id's of Rev organizations to be filtered. */
            rev_oid?: string[];
            /** Fields to sort the Rev users by. */
            sort_by?: string[];
            /** List of state of Rev users to be filtered. */
            state?: UserState[];
            /**
             * List of tags to be filtered. Input will be of the format (tags=<tag
             * id 1>=<value>&tags=<tag id 2>).
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevUsersGroupResponse, any>>;
        /**
         * @description Lists collections of Rev users by groups.
         *
         * @tags rev-users
         * @name RevUsersGroupPost
         * @request POST:/internal/rev-users.group
         * @secure
         */
        revUsersGroupPost: (data: RevUsersGroupRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersGroupResponse, any>>;
        /**
         * @description Returns a list of all Rev Users belonging to the authenticated user's Dev Organization.
         *
         * @tags rev-users
         * @name RevUsersList
         * @request GET:/internal/rev-users.list
         * @secure
         */
        revUsersList: (query?: {
            /** Filters for Rev users that were created by the specified user(s). */
            created_by?: string[];
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'created_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'created_date.before'?: string;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters on custom fields. Input will be of the format
             * (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2)
             */
            custom_field_filter?: string[];
            /** List of emails of Rev users to be filtered. */
            email?: string[];
            /** List of external ref for Rev users to be filtered. */
            external_ref?: string[];
            /** List of external ref issuers for Rev users to be filtered. */
            external_ref_issuer?: string[];
            /**
             * The maximum number of Rev users to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'modified_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'modified_date.before'?: string;
            /**
             * The ID of Rev organization to list all Rev users of.
             * @deprecated
             * @example "don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"
             */
            org_id?: string;
            /**
             * List of IDs of Rev organizations to be filtered.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org?: string[];
            /** Fields to sort the Rev users by and the direction to sort them. */
            sort_by?: string[];
            /** List of state of Rev users to be filtered. */
            state?: UserState[];
            /**
             * List of tags to be filtered. Input will be of the format (tags=<tag
             * id 1>=<value>&tags=<tag id 2>).
             */
            tags?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<RevUsersListResponse, any>>;
        /**
         * @description Returns a list of all Rev Users belonging to the authenticated user's Dev Organization.
         *
         * @tags rev-users
         * @name RevUsersListPost
         * @request POST:/internal/rev-users.list
         * @secure
         */
        revUsersListPost: (data: RevUsersListRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersListResponse, any>>;
        /**
         * @description Gets the authenticated Rev user's information.
         *
         * @tags rev-users
         * @name RevUsersSelfGet
         * @request GET:/internal/rev-users.self.get
         * @secure
         */
        revUsersSelfGet: (params?: RequestParams) => Promise<AxiosResponse<RevUsersSelfResponse, any>>;
        /**
         * @description Gets the authenticated Rev user's information.
         *
         * @tags rev-users
         * @name RevUsersSelfGetPost
         * @request POST:/internal/rev-users.self.get
         * @secure
         */
        revUsersSelfGetPost: (data: RevUsersSelfRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersSelfResponse, any>>;
        /**
         * @description Updates the authenticated Rev user.
         *
         * @tags rev-users
         * @name RevUsersSelfUpdate
         * @request POST:/internal/rev-users.self.update
         * @secure
         */
        revUsersSelfUpdate: (data: RevUsersSelfUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersSelfUpdateResponse, any>>;
        /**
         * @description Updates a Rev user.
         *
         * @tags rev-users
         * @name RevUsersUpdate
         * @request POST:/internal/rev-users.update
         * @secure
         */
        revUsersUpdate: (data: RevUsersUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<RevUsersUpdateResponse, any>>;
        /**
         * @description Gets the reward transactions based on the given filters.
         *
         * @tags commerce
         * @name RewardTransactionsList
         * @request GET:/internal/reward.transactions.list
         * @secure
         */
        rewardTransactionsList: (query?: {
            /**
             * The transaction date from which to aggregate reward transaction
             * objects.
             * @format date-time
             */
            from_transaction_date?: string;
            /**
             * List of fields to sort the reward transaction object, by and how to
             * sort them. Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
            /**
             * The transaction date till which to aggregate reward transaction
             * objects.
             * @format date-time
             */
            to_transaction_date?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RewardTransactionsListResponse, any>>;
        /**
         * @description Gets the reward transactions based on the given filters.
         *
         * @tags commerce
         * @name RewardTransactionsListPost
         * @request POST:/internal/reward.transactions.list
         * @secure
         */
        rewardTransactionsListPost: (data: RewardTransactionsListRequest, params?: RequestParams) => Promise<AxiosResponse<RewardTransactionsListResponse, any>>;
        /**
         * @description Creates a reward.
         *
         * @tags commerce
         * @name RewardsCreate
         * @request POST:/internal/rewards.create
         * @secure
         */
        rewardsCreate: (data: RewardsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<RewardsCreateResponse, any>>;
        /**
         * @description Gets a reward.
         *
         * @tags commerce
         * @name RewardsGet
         * @request GET:/internal/rewards.get
         * @secure
         */
        rewardsGet: (query: {
            /** The reward object's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RewardsGetResponse, any>>;
        /**
         * @description Gets a reward.
         *
         * @tags commerce
         * @name RewardsGetPost
         * @request POST:/internal/rewards.get
         * @secure
         */
        rewardsGetPost: (data: RewardsGetRequest, params?: RequestParams) => Promise<AxiosResponse<RewardsGetResponse, any>>;
        /**
         * @description Gets the rewards based on the given filters.
         *
         * @tags commerce
         * @name RewardsList
         * @request GET:/internal/rewards.list
         * @secure
         */
        rewardsList: (query?: {
            /**
             * The expiry date from which to aggregate reward objects.
             * @format date-time
             */
            from_expiry_date?: string;
            /**
             * List of fields to sort the reward object, by and how to sort them.
             * Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
            /**
             * The expiry date till which to aggregate reward objects.
             * @format date-time
             */
            to_expiry_date?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RewardsListResponse, any>>;
        /**
         * @description Gets the rewards based on the given filters.
         *
         * @tags commerce
         * @name RewardsListPost
         * @request POST:/internal/rewards.list
         * @secure
         */
        rewardsListPost: (data: RewardsListRequest, params?: RequestParams) => Promise<AxiosResponse<RewardsListResponse, any>>;
        /**
         * @description Transfers rewards from a rev user to its own rev org or to a rev user of the same rev org.
         *
         * @tags commerce
         * @name RewardsTransfer
         * @request POST:/internal/rewards.transfer
         * @secure
         */
        rewardsTransfer: (data: RewardsTransferRequest, params?: RequestParams) => Promise<AxiosResponse<RewardsTransferResponse, any>>;
        /**
         * @description Converts rewards to credits for a rev org.
         *
         * @tags commerce
         * @name RewardsTransferToCredits
         * @request POST:/internal/rewards.transfer-to-credits
         * @secure
         */
        rewardsTransferToCredits: (data: RewardsTransferToCreditsRequest, params?: RequestParams) => Promise<AxiosResponse<RewardsTransferToCreditsResponse, any>>;
        /**
         * @description Creates a role.
         *
         * @tags roles
         * @name RolesCreate
         * @request POST:/internal/roles.create
         * @secure
         */
        rolesCreate: (data: RolesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<RolesCreateResponse, any>>;
        /**
         * @description Deletes the requested role.
         *
         * @tags roles
         * @name RolesDelete
         * @request POST:/internal/roles.delete
         * @secure
         */
        rolesDelete: (data: RolesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the requested role's information.
         *
         * @tags roles
         * @name RolesGet
         * @request GET:/internal/roles.get
         * @secure
         */
        rolesGet: (query: {
            /** ID for the role. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<RolesGetResponse, any>>;
        /**
         * @description Gets the requested role's information.
         *
         * @tags roles
         * @name RolesGetPost
         * @request POST:/internal/roles.get
         * @secure
         */
        rolesGetPost: (data: RolesGetRequest, params?: RequestParams) => Promise<AxiosResponse<RolesGetResponse, any>>;
        /**
         * @description Lists the available roles.
         *
         * @tags roles
         * @name RolesList
         * @request GET:/internal/roles.list
         * @secure
         */
        rolesList: (params?: RequestParams) => Promise<AxiosResponse<RolesListResponse, any>>;
        /**
         * @description Lists the available roles.
         *
         * @tags roles
         * @name RolesListPost
         * @request POST:/internal/roles.list
         * @secure
         */
        rolesListPost: (data: RolesListRequest, params?: RequestParams) => Promise<AxiosResponse<RolesListResponse, any>>;
        /**
         * @description Creates a room and returns the room details.
         *
         * @tags rooms
         * @name RoomsCreate
         * @request POST:/internal/rooms.create
         * @secure
         */
        roomsCreate: (data: RoomsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<RoomsCreateResponse, any>>;
        /**
         * @description Informs a room of a user update.
         *
         * @tags rooms
         * @name RoomsInform
         * @request POST:/internal/rooms.inform
         * @secure
         */
        roomsInform: (data: RoomsInformRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the aggregated schema.
         *
         * @tags schemas
         * @name AggregatedSchemaGet
         * @request GET:/internal/schemas.aggregated.get
         * @secure
         */
        aggregatedSchemaGet: (query: {
            /** The list of custom schema fragment DONs which are to be aggregated. */
            custom_schema_fragment_ids: string[];
            /** The stock schema fragment which is to be aggregated. */
            stock_schema_fragment_id: string;
            /** The default value for this field. */
            'per_object_schema.default_value'?: object;
            /** Description of the field. */
            'per_object_schema.description'?: string;
            /** Composite type. */
            'per_object_schema.devrev_composite_type'?: string;
            /** Allowed values for a string or []string type. */
            'per_object_schema.devrev_enum'?: string[];
            /** DevRev field type. */
            'per_object_schema.devrev_field_type'?: string;
            /** Object ID types. */
            'per_object_schema.devrev_id_type'?: string[];
            /** Gateway api name of the field. */
            'per_object_schema.gateway.api_name'?: string;
            /** Whether this field is filterable, groupable and sortable. */
            'per_object_schema.is_filterable'?: boolean;
            /** Whether this field can hold PII. */
            'per_object_schema.is_pii'?: boolean;
            /** Whether this field is required or not. */
            'per_object_schema.is_required'?: boolean;
            /** Whether this field is a system field or not. */
            'per_object_schema.is_system'?: boolean;
            /** Name of the field. */
            'per_object_schema.name'?: string;
            /** Allowed values of the field. */
            'per_object_schema.ui.allowed_values'?: string[];
            /** Fields on which this field depends on. */
            'per_object_schema.ui.dependent_fields'?: string[];
            /**
             * Detail view UI hint overrides.
             * @format int32
             */
            'per_object_schema.ui.detail_view'?: number;
            /** enum group key. */
            'per_object_schema.ui.devrev_enum_groups.group_key'?: string;
            /** true if header is visible. */
            'per_object_schema.ui.devrev_enum_groups.is_header_visible'?: boolean;
            /** label of the field. */
            'per_object_schema.ui.devrev_enum_groups.label'?: string;
            /** display name of the field. */
            'per_object_schema.ui.display_name'?: string;
            /** Whether field is active in detail view. */
            'per_object_schema.ui.is_active_in_detail_view'?: boolean;
            /** Whether stock field is rendered at top. */
            'per_object_schema.ui.is_base_field'?: boolean;
            /** Whether field supports bulk action. */
            'per_object_schema.ui.is_bulk_action_enabled'?: boolean;
            /** Indicates if the field holds a currency value in USD. */
            'per_object_schema.ui.is_currency_field'?: boolean;
            /** Whether field is groupable. */
            'per_object_schema.ui.is_groupable'?: boolean;
            /** Whether field is hidden in UI. */
            'per_object_schema.ui.is_hidden'?: boolean;
            /** Whether field is hidden in UI during creation. */
            'per_object_schema.ui.is_hidden_during_create'?: boolean;
            /** Whether field is read-only in UI. */
            'per_object_schema.ui.is_read_only'?: boolean;
            /** Whether field is shown in summary. */
            'per_object_schema.ui.is_shown_in_summary'?: boolean;
            /** Whether field is sortable. */
            'per_object_schema.ui.is_sortable'?: boolean;
            /**
             * List view UI hint overrides.
             * @format int32
             */
            'per_object_schema.ui.list_view'?: number;
            /**
             * Order in which field is shown.
             * @format int32
             */
            'per_object_schema.ui.order'?: number;
            /** Placeholder for the field. */
            'per_object_schema.ui.placeholder'?: string;
            /** Tooltip for field. */
            'per_object_schema.ui.tooltip'?: string;
            /** Unit of measurment. */
            'per_object_schema.ui.unit'?: string;
            /** string contains. */
            'per_object_schema.validation.contains'?: string;
            /** disables validations for this field. */
            'per_object_schema.validation.disabled'?: boolean;
            /**
             * exact array length.
             * @format int32
             */
            'per_object_schema.validation.eq_items'?: number;
            /**
             * exact string length.
             * @format int32
             */
            'per_object_schema.validation.eq_len'?: number;
            /**
             * int must be greater than this.
             * @format int32
             */
            'per_object_schema.validation.gt'?: number;
            /**
             * int must be greater or equal than this.
             * @format int32
             */
            'per_object_schema.validation.gte'?: number;
            /**
             * int must be less than this.
             * @format int32
             */
            'per_object_schema.validation.lt'?: number;
            /**
             * int must be less or equal than this.
             * @format int32
             */
            'per_object_schema.validation.lte'?: number;
            /**
             * maximum array length.
             * @format int32
             */
            'per_object_schema.validation.max_items'?: number;
            /**
             * maximum string length.
             * @format int32
             */
            'per_object_schema.validation.max_len'?: number;
            /**
             * minimum array length.
             * @format int32
             */
            'per_object_schema.validation.min_items'?: number;
            /**
             * minimum string length.
             * @format int32
             */
            'per_object_schema.validation.min_len'?: number;
            /** string pattern (re). */
            'per_object_schema.validation.pattern'?: string;
            /** string prefix. */
            'per_object_schema.validation.prefix'?: string;
            /** string suffix. */
            'per_object_schema.validation.suffix'?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<AggregatedSchemaGetResponse, any>>;
        /**
         * @description Gets the aggregated schema.
         *
         * @tags schemas
         * @name AggregatedSchemaGetPost
         * @request POST:/internal/schemas.aggregated.get
         * @secure
         */
        aggregatedSchemaGetPost: (data: AggregatedSchemaGetRequest, params?: RequestParams) => Promise<AxiosResponse<AggregatedSchemaGetResponse, any>>;
        /**
         * @description Gets a custom schema fragment.
         *
         * @tags schemas
         * @name CustomSchemaFragmentsGet
         * @request GET:/internal/schemas.custom.get
         * @secure
         */
        customSchemaFragmentsGet: (query: {
            /** The ID of the custom schema fragment. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<CustomSchemaFragmentsGetResponse, any>>;
        /**
         * @description Gets a custom schema fragment.
         *
         * @tags schemas
         * @name CustomSchemaFragmentsGetPost
         * @request POST:/internal/schemas.custom.get
         * @secure
         */
        customSchemaFragmentsGetPost: (data: CustomSchemaFragmentsGetRequest, params?: RequestParams) => Promise<AxiosResponse<CustomSchemaFragmentsGetResponse, any>>;
        /**
         * @description Lists custom schema fragments.
         *
         * @tags schemas
         * @name CustomSchemaFragmentsList
         * @request GET:/internal/schemas.custom.list
         * @secure
         */
        customSchemaFragmentsList: (query?: {
            /** The list of app names. */
            app?: string[];
            /**
             * The cursor to resume iteration from, otherwise if not provided, then
             * iteration starts from the beginning.
             */
            cursor?: string;
            /** The list of leaf types. */
            leaf_type?: string[];
            /**
             * The maximum number of items.
             * @format int32
             */
            limit?: number;
            /** The list of fields to sort the items by and how to sort them. */
            sort_by?: string[];
            /** The list of subtypes. */
            subtype?: string[];
            /** Filters for custom schema fragment of the provided types. */
            types?: CustomSchemaFragmentType[];
        }, params?: RequestParams) => Promise<AxiosResponse<CustomSchemaFragmentsListResponse, any>>;
        /**
         * @description Lists custom schema fragments.
         *
         * @tags schemas
         * @name CustomSchemaFragmentsListPost
         * @request POST:/internal/schemas.custom.list
         * @secure
         */
        customSchemaFragmentsListPost: (data: CustomSchemaFragmentsListRequest, params?: RequestParams) => Promise<AxiosResponse<CustomSchemaFragmentsListResponse, any>>;
        /**
         * @description Creates or updates a custom schema fragment.
         *
         * @tags schemas
         * @name CustomSchemaFragmentsSet
         * @request POST:/internal/schemas.custom.set
         * @secure
         */
        customSchemaFragmentsSet: (data: CustomSchemaFragmentsSetRequest, params?: RequestParams) => Promise<AxiosResponse<CustomSchemaFragmentsSetResponse, any>>;
        /**
         * @description Gets a stock schema fragment.
         *
         * @tags schemas
         * @name StockSchemaFragmentsGet
         * @request GET:/internal/schemas.stock.get
         * @secure
         */
        stockSchemaFragmentsGet: (query?: {
            /** The ID of the stock schema fragment. */
            id?: string;
            /** The leaf type this fragment applies to. */
            leaf_type?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<StockSchemaFragmentsGetResponse, any>>;
        /**
         * @description Gets a stock schema fragment.
         *
         * @tags schemas
         * @name StockSchemaFragmentsGetPost
         * @request POST:/internal/schemas.stock.get
         * @secure
         */
        stockSchemaFragmentsGetPost: (data: StockSchemaFragmentsGetRequest, params?: RequestParams) => Promise<AxiosResponse<StockSchemaFragmentsGetResponse, any>>;
        /**
         * @description Lists stock schema fragments.
         *
         * @tags schemas
         * @name StockSchemaFragmentsList
         * @request GET:/internal/schemas.stock.list
         * @secure
         */
        stockSchemaFragmentsList: (query?: {
            /**
             * The cursor to resume iteration from, otherwise if not provided, then
             * iteration starts from the beginning.
             */
            cursor?: string;
            /** The list of leaf types. */
            leaf_type?: string[];
            /**
             * The maximum number of items.
             * @format int32
             */
            limit?: number;
            /** The list of fields to sort the items by and how to sort them. */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<StockSchemaFragmentsListResponse, any>>;
        /**
         * @description Lists stock schema fragments.
         *
         * @tags schemas
         * @name StockSchemaFragmentsListPost
         * @request POST:/internal/schemas.stock.list
         * @secure
         */
        stockSchemaFragmentsListPost: (data: StockSchemaFragmentsListRequest, params?: RequestParams) => Promise<AxiosResponse<StockSchemaFragmentsListResponse, any>>;
        /**
         * @description Lists subtypes.
         *
         * @tags schemas
         * @name SubtypesList
         * @request GET:/internal/schemas.subtypes.list
         * @secure
         */
        subtypesList: (query: {
            /** Leaf type for which subtypes are required. */
            leaf_type: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SubtypesListResponse, any>>;
        /**
         * @description Lists subtypes.
         *
         * @tags schemas
         * @name SubtypesListPost
         * @request POST:/internal/schemas.subtypes.list
         * @secure
         */
        subtypesListPost: (data: SubtypesListRequest, params?: RequestParams) => Promise<AxiosResponse<SubtypesListResponse, any>>;
        /**
         * @description Searches for records based on a given query.
         *
         * @tags search
         * @name SearchCore
         * @request GET:/internal/search.core
         * @secure
         */
        searchCore: (query: {
            /** The query string. */
            query: string;
            /**
             * The cursor from where to begin iteration. Start from beginning if not
             * provided.
             */
            cursor?: string;
            /** The namespaces to search in. */
            namespaces?: string[];
            /**
             * The order in which to sort the search results. The default is
             * RELEVANCE.
             */
            sort_by?: SearchSortByParam;
            /** Sorting order. */
            sort_order?: SearchSortOrderParam;
        }, params?: RequestParams) => Promise<AxiosResponse<SearchCoreResponse, any>>;
        /**
         * @description Searches for records based on a given query.
         *
         * @tags search
         * @name SearchCorePost
         * @request POST:/internal/search.core
         * @secure
         */
        searchCorePost: (data: SearchCoreRequest, params?: RequestParams) => Promise<AxiosResponse<SearchCoreResponse, any>>;
        /**
         * @description Typeahead search.
         *
         * @tags search
         * @name SearchTypeahead
         * @request GET:/internal/search.typeahead
         * @secure
         */
        searchTypeahead: (query: {
            /** The fields to search on. */
            fields: string[];
            /** The namespaces to search in. */
            namespaces: SearchNamespace[];
            /** The query string. */
            query: string;
            /**
             * The cursor from where to begin iteration. Start from beginning if not
             * provided.
             */
            cursor?: string;
            /**
             * The order in which to sort the search results. The default is
             * RELEVANCE.
             */
            sort_by?: SearchSortByParam;
            /** Sorting order. */
            sort_order?: SearchSortOrderParam;
        }, params?: RequestParams) => Promise<AxiosResponse<SearchTypeaheadResponse, any>>;
        /**
         * @description Typeahead search.
         *
         * @tags search
         * @name SearchTypeaheadPost
         * @request POST:/internal/search.typeahead
         * @secure
         */
        searchTypeaheadPost: (data: SearchTypeaheadRequest, params?: RequestParams) => Promise<AxiosResponse<SearchTypeaheadResponse, any>>;
        /**
         * @description Creates a service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsCreate
         * @request POST:/internal/service-accounts.create
         * @secure
         */
        serviceAccountsCreate: (data: ServiceAccountsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsCreateResponse, any>>;
        /**
         * @description Deletes a service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsDelete
         * @request POST:/internal/service-accounts.delete
         * @secure
         */
        serviceAccountsDelete: (data: ServiceAccountsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: prabath.siriwardena@devrev.ai ### Gets a service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsGet
         * @request GET:/internal/service-accounts.get
         * @secure
         */
        serviceAccountsGet: (query: {
            /** The ID of the requested service account. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsGetResponse, any>>;
        /**
         * @description Gets a service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsGetPost
         * @request POST:/internal/service-accounts.get
         * @secure
         */
        serviceAccountsGetPost: (data: ServiceAccountsGetRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsGetResponse, any>>;
        /**
         * @description Creates a keyring under the corresponding service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsKeyringsCreate
         * @request POST:/internal/service-accounts.keyrings.create
         * @secure
         */
        serviceAccountsKeyringsCreate: (data: ServiceAccountsKeyringsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsKeyringsCreateResponse, any>>;
        /**
         * @description Deletes a keyring under the corresponding service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsKeyringsDelete
         * @request POST:/internal/service-accounts.keyrings.delete
         * @secure
         */
        serviceAccountsKeyringsDelete: (data: ServiceAccountsKeyringsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: prabath.siriwardena@devrev.ai ### Gets a keyring under the corresponding service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsKeyringsGet
         * @request GET:/internal/service-accounts.keyrings.get
         * @secure
         */
        serviceAccountsKeyringsGet: (query: {
            /** The ID of the keyring. */
            key_id: string;
            /** The ID corresponding to the requested keyring. */
            service_account_id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsKeyringsGetResponse, any>>;
        /**
         * @description Gets a keyring under the corresponding service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsKeyringsGetPost
         * @request POST:/internal/service-accounts.keyrings.get
         * @secure
         */
        serviceAccountsKeyringsGetPost: (data: ServiceAccountsKeyringsGetRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsKeyringsGetResponse, any>>;
        /**
         * @description Updates a keyring under the corresponding service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsKeyringsUpdate
         * @request POST:/internal/service-accounts.keyrings.update
         * @secure
         */
        serviceAccountsKeyringsUpdate: (data: ServiceAccountsKeyringsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsKeyringsUpdateResponse, any>>;
        /**
         * @description ### Owner: prabath.siriwardena@devrev.ai ### Lists the service accounts.
         *
         * @tags service-accounts
         * @name ServiceAccountsList
         * @request GET:/internal/service-accounts.list
         * @secure
         */
        serviceAccountsList: (params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsListResponse, any>>;
        /**
         * @description Lists the service accounts.
         *
         * @tags service-accounts
         * @name ServiceAccountsListPost
         * @request POST:/internal/service-accounts.list
         * @secure
         */
        serviceAccountsListPost: (data: ServiceAccountsListRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsListResponse, any>>;
        /**
         * @description Updates a service account.
         *
         * @tags service-accounts
         * @name ServiceAccountsUpdate
         * @request POST:/internal/service-accounts.update
         * @secure
         */
        serviceAccountsUpdate: (data: ServiceAccountsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<ServiceAccountsUpdateResponse, any>>;
        /**
         * @description Cancels a service plan.
         *
         * @tags commerce
         * @name ServicePlansCancel
         * @request POST:/internal/service-plans.cancel
         * @secure
         */
        servicePlansCancel: (data: ServicePlansCancelRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Creates a service plan object.
         *
         * @tags commerce
         * @name ServicePlansCreate
         * @request POST:/internal/service-plans.create
         * @secure
         */
        servicePlansCreate: (data: ServicePlansCreateRequest, params?: RequestParams) => Promise<AxiosResponse<ServicePlansCreateResponse, any>>;
        /**
         * @description Gets a service plan object.
         *
         * @tags commerce
         * @name ServicePlansGet
         * @request GET:/internal/service-plans.get
         * @secure
         */
        servicePlansGet: (query: {
            /** The service plan's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ServicePlansGetResponse, any>>;
        /**
         * @description Gets a service plan object.
         *
         * @tags commerce
         * @name ServicePlansGetPost
         * @request POST:/internal/service-plans.get
         * @secure
         */
        servicePlansGetPost: (data: ServicePlansGetRequest, params?: RequestParams) => Promise<AxiosResponse<ServicePlansGetResponse, any>>;
        /**
         * @description Gets compatible skus that can be purchased with the current configuration of the service plan.
         *
         * @tags commerce
         * @name ServicePlansGetCompatibleSkus
         * @request GET:/internal/service-plans.get-compatible-skus
         * @secure
         */
        servicePlansGetCompatibleSkus: (query?: {
            /** The service plan's DON. */
            id?: string;
            /**
             * The product ID for which to get the compatible SKUs.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            product_id?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<ServicePlansGetCompatibleSkusResponse, any>>;
        /**
         * @description Gets compatible skus that can be purchased with the current configuration of the service plan.
         *
         * @tags commerce
         * @name ServicePlansGetCompatibleSkusPost
         * @request POST:/internal/service-plans.get-compatible-skus
         * @secure
         */
        servicePlansGetCompatibleSkusPost: (data: ServicePlansGetCompatibleSkusRequest, params?: RequestParams) => Promise<AxiosResponse<ServicePlansGetCompatibleSkusResponse, any>>;
        /**
         * @description Gets the service plan objects based on the given filters.
         *
         * @tags commerce
         * @name ServicePlansList
         * @request GET:/internal/service-plans.list
         * @secure
         */
        servicePlansList: (query?: {
            /** The list of service plan DONs which are to be aggregated. */
            ids?: string[];
            /**
             * The list of rev org DONs which are to be aggregated.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org_ids?: string[];
            /**
             * List of fields to sort the service plan object, by and how to sort
             * them. Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
            /** The list of states which are to be aggregated. */
            states?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<ServicePlansListResponse, any>>;
        /**
         * @description Gets the service plan objects based on the given filters.
         *
         * @tags commerce
         * @name ServicePlansListPost
         * @request POST:/internal/service-plans.list
         * @secure
         */
        servicePlansListPost: (data: ServicePlansListRequest, params?: RequestParams) => Promise<AxiosResponse<ServicePlansListResponse, any>>;
        /**
         * @description Deletes pending update for a service plan object.
         *
         * @tags commerce
         * @name ServicePlansPendingUpdateCancel
         * @request POST:/internal/service-plans.pending-update.cancel
         * @secure
         */
        servicePlansPendingUpdateCancel: (data: ServicePlansPendingUpdateCancelRequest, params?: RequestParams) => Promise<AxiosResponse<ServicePlansPendingUpdateCancelResponse, any>>;
        /**
         * @description Updates a service plan object.
         *
         * @tags commerce
         * @name ServicePlansUpdate
         * @request POST:/internal/service-plans.update
         * @secure
         */
        servicePlansUpdate: (data: ServicePlansUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<ServicePlansUpdateResponse, any>>;
        /**
         * @description Creates a sku rule.
         *
         * @tags commerce
         * @name SkuRulesCreate
         * @request POST:/internal/skurules.create
         * @secure
         */
        skuRulesCreate: (data: SkuRulesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<SkuRulesCreateResponse, any>>;
        /**
         * @description Deletes a sku rule.
         *
         * @tags commerce
         * @name SkuRulesDelete
         * @request POST:/internal/skurules.delete
         * @secure
         */
        skuRulesDelete: (data: SkuRulesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a sku rule.
         *
         * @tags commerce
         * @name SkuRulesGet
         * @request GET:/internal/skurules.get
         * @secure
         */
        skuRulesGet: (query: {
            /** The sku rule's DON */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SkuRulesGetResponse, any>>;
        /**
         * @description Gets a sku rule.
         *
         * @tags commerce
         * @name SkuRulesGetPost
         * @request POST:/internal/skurules.get
         * @secure
         */
        skuRulesGetPost: (data: SkuRulesGetRequest, params?: RequestParams) => Promise<AxiosResponse<SkuRulesGetResponse, any>>;
        /**
         * @description Gets the sku rules based on the given filters.
         *
         * @tags commerce
         * @name SkuRulesList
         * @request GET:/internal/skurules.list
         * @secure
         */
        skuRulesList: (query?: {
            /** The list of allowed sku names which are to be aggregated. */
            allowed_sku_names?: string[];
            /** The list of sku rule DONs which are to be aggregated. */
            ids?: string[];
            /**
             * The list of product DONs which are to be aggregated.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            product_ids?: string[];
            /**
             * List of fields to sort the sku rules, by and how to sort them.
             * Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<SkuRulesListResponse, any>>;
        /**
         * @description Gets the sku rules based on the given filters.
         *
         * @tags commerce
         * @name SkuRulesListPost
         * @request POST:/internal/skurules.list
         * @secure
         */
        skuRulesListPost: (data: SkuRulesListRequest, params?: RequestParams) => Promise<AxiosResponse<SkuRulesListResponse, any>>;
        /**
         * @description Updates a sku rule.
         *
         * @tags commerce
         * @name SkuRulesUpdate
         * @request POST:/internal/skurules.update
         * @secure
         */
        skuRulesUpdate: (data: SkuRulesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<SkuRulesUpdateResponse, any>>;
        /**
         * @description Creates a SKU.
         *
         * @tags commerce
         * @name SkusCreate
         * @request POST:/internal/skus.create
         * @secure
         */
        skusCreate: (data: SkusCreateRequest, params?: RequestParams) => Promise<AxiosResponse<SkusCreateResponse, any>>;
        /**
         * @description Deletes a SKU.
         *
         * @tags commerce
         * @name SkusDelete
         * @request POST:/internal/skus.delete
         * @secure
         */
        skusDelete: (data: SkusDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a SKU.
         *
         * @tags commerce
         * @name SkusGet
         * @request GET:/internal/skus.get
         * @secure
         */
        skusGet: (query: {
            /** The SKU object's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SkusGetResponse, any>>;
        /**
         * @description Gets a SKU.
         *
         * @tags commerce
         * @name SkusGetPost
         * @request POST:/internal/skus.get
         * @secure
         */
        skusGetPost: (data: SkusGetRequest, params?: RequestParams) => Promise<AxiosResponse<SkusGetResponse, any>>;
        /**
         * @description Gets the SKUs based on the given filters.
         *
         * @tags commerce
         * @name SkusList
         * @request GET:/internal/skus.list
         * @secure
         */
        skusList: (query?: {
            /** The list of SKU DONs which are to be aggregated. */
            ids?: string[];
            /** The list of SKU names which are to be aggregated. */
            names?: string[];
            /**
             * The list of product DONs which are to be aggregated.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            product_ids?: string[];
            /**
             * The list of rev org DONs which are to be aggregated.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            rev_org_ids?: string[];
            /** The list of SKU types which are to be aggregated. */
            sku_types?: SkuType[];
            /** The list of SKU versions which are to be aggregated. */
            sku_versions?: number[];
            /**
             * List of fields to sort the SKU object, by and how to sort them.
             * Default is to sort by created_date in descending order.
             */
            sort_by?: string[];
            /** The list of SKU states which are to be aggregated. */
            states?: SkuState[];
        }, params?: RequestParams) => Promise<AxiosResponse<SkusListResponse, any>>;
        /**
         * @description Gets the SKUs based on the given filters.
         *
         * @tags commerce
         * @name SkusListPost
         * @request POST:/internal/skus.list
         * @secure
         */
        skusListPost: (data: SkusListRequest, params?: RequestParams) => Promise<AxiosResponse<SkusListResponse, any>>;
        /**
         * @description Updates a SKU.
         *
         * @tags commerce
         * @name SkusUpdate
         * @request POST:/internal/skus.update
         * @secure
         */
        skusUpdate: (data: SkusUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<SkusUpdateResponse, any>>;
        /**
         * @description Versions a SKU.
         *
         * @tags commerce
         * @name SkusVersion
         * @request POST:/internal/skus.version
         * @secure
         */
        skusVersion: (data: SkusVersionRequest, params?: RequestParams) => Promise<AxiosResponse<SkusVersionResponse, any>>;
        /**
         * @description  Assigns the SLA to a set of Rev organizations.
         *
         * @tags slas
         * @name SlasAssign
         * @request POST:/internal/slas.assign
         * @secure
         */
        slasAssign: (data: SlasAssignRequest, params?: RequestParams) => Promise<AxiosResponse<SlasAssignResponse, any>>;
        /**
         * @description Creates an SLA in draft status.
         *
         * @tags slas
         * @name SlasCreate
         * @request POST:/internal/slas.create
         * @secure
         */
        slasCreate: (data: SlasCreateRequest, params?: RequestParams) => Promise<AxiosResponse<SlasCreateResponse, any>>;
        /**
         * @description ### Owner: lorinc.body@devrev.ai ### Gets an SLA.
         *
         * @tags slas
         * @name SlasGet
         * @request GET:/internal/slas.get
         * @secure
         */
        slasGet: (query: {
            /** The ID of the SLA to get. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SlasGetResponse, any>>;
        /**
         * @description Gets an SLA.
         *
         * @tags slas
         * @name SlasGetPost
         * @request POST:/internal/slas.get
         * @secure
         */
        slasGetPost: (data: SlasGetRequest, params?: RequestParams) => Promise<AxiosResponse<SlasGetResponse, any>>;
        /**
         * @description Changes the status of an SLA.
         *
         * @tags slas
         * @name SlasTransition
         * @request POST:/internal/slas.transition
         * @secure
         */
        slasTransition: (data: SlasTransitionRequest, params?: RequestParams) => Promise<AxiosResponse<SlasTransitionResponse, any>>;
        /**
         * @description Creates a snap-in package.
         *
         * @tags snap-in-packages
         * @name SnapInPackagesCreate
         * @request POST:/internal/snap-in-packages.create
         * @secure
         */
        snapInPackagesCreate: (data: SnapInPackagesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInPackagesCreateResponse, any>>;
        /**
         * @description Deletes a snap-in package.
         *
         * @tags snap-in-packages
         * @name SnapInPackagesDelete
         * @request POST:/internal/snap-in-packages.delete
         * @secure
         */
        snapInPackagesDelete: (data: SnapInPackagesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description ### Owner: peter.marinsek@devrev.ai ### Gets a snap-in package.
         *
         * @tags snap-in-packages
         * @name SnapInPackagesGet
         * @request GET:/internal/snap-in-packages.get
         * @secure
         */
        snapInPackagesGet: (query: {
            /** The ID of the snap-in package to get. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SnapInPackagesGetResponse, any>>;
        /**
         * @description Gets a snap-in package.
         *
         * @tags snap-in-packages
         * @name SnapInPackagesGetPost
         * @request POST:/internal/snap-in-packages.get
         * @secure
         */
        snapInPackagesGetPost: (data: SnapInPackagesGetRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInPackagesGetResponse, any>>;
        /**
         * @description ### Owner: peter.marinsek@devrev.ai ### Lists snap-in packages for a Dev organization.
         *
         * @tags snap-in-packages
         * @name SnapInPackagesList
         * @request GET:/internal/snap-in-packages.list
         * @secure
         */
        snapInPackagesList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of snap-in packages to return. The default is
             * '50', the maximum is '100'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Fields to sort the snap-in packages by and the direction to sort
             * them.
             */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<SnapInPackagesListResponse, any>>;
        /**
         * @description Lists snap-in packages for a Dev organization.
         *
         * @tags snap-in-packages
         * @name SnapInPackagesListPost
         * @request POST:/internal/snap-in-packages.list
         * @secure
         */
        snapInPackagesListPost: (data: SnapInPackagesListRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInPackagesListResponse, any>>;
        /**
         * @description Creates a snap-in version.
         *
         * @tags snap-in-versions
         * @name SnapInVersionsCreate
         * @request POST:/internal/snap-in-versions.create
         * @secure
         */
        snapInVersionsCreate: (data: SnapInVersionsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInVersionsCreateResponse, any>>;
        /**
         * @description Deletes a snap-in version.
         *
         * @tags snap-in-versions
         * @name SnapInVersionsDelete
         * @request POST:/internal/snap-in-versions.delete
         * @secure
         */
        snapInVersionsDelete: (data: SnapInVersionsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description ### Owner: peter.marinsek@devrev.ai ### Gets a snap-in version.
         *
         * @tags snap-in-versions
         * @name SnapInVersionsGet
         * @request GET:/internal/snap-in-versions.get
         * @secure
         */
        snapInVersionsGet: (query: {
            /** The ID of the snap-in version to get. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SnapInVersionsGetResponse, any>>;
        /**
         * @description Gets a snap-in version.
         *
         * @tags snap-in-versions
         * @name SnapInVersionsGetPost
         * @request POST:/internal/snap-in-versions.get
         * @secure
         */
        snapInVersionsGetPost: (data: SnapInVersionsGetRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInVersionsGetResponse, any>>;
        /**
         * @description Deletes a SnapIn.
         *
         * @tags snap-ins
         * @name SnapInsDelete
         * @request POST:/internal/snap-ins.delete
         * @secure
         */
        snapInsDelete: (data: SnapInsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Deploys a SnapIn.
         *
         * @tags snap-ins
         * @name SnapInsDeploy
         * @request POST:/internal/snap-ins.deploy
         * @secure
         */
        snapInsDeploy: (data: SnapInsDeployRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInsDeployResponse, any>>;
        /**
         * @description Creates a draft SnapIn from given SnapIn version.
         *
         * @tags snap-ins
         * @name SnapInsDraftCreate
         * @request POST:/internal/snap-ins.draft.create
         * @secure
         */
        snapInsDraftCreate: (data: SnapInsDraftCreateRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInsDraftCreateResponse, any>>;
        /**
         * @description ### Owner: harpinder.singh@devrev.ai ### Gets a SnapIn.
         *
         * @tags snap-ins
         * @name SnapInsGet
         * @request GET:/internal/snap-ins.get
         * @secure
         */
        snapInsGet: (query: {
            /** The ID of the snap-in to get. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SnapInsGetResponse, any>>;
        /**
         * @description Gets a SnapIn.
         *
         * @tags snap-ins
         * @name SnapInsGetPost
         * @request POST:/internal/snap-ins.get
         * @secure
         */
        snapInsGetPost: (data: SnapInsGetRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInsGetResponse, any>>;
        /**
         * @description ### Owner: harpinder.singh@devrev.ai ### Lists snap-ins for a Dev organization.
         *
         * @tags snap-ins
         * @name SnapInsList
         * @request GET:/internal/snap-ins.list
         * @secure
         */
        snapInsList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of snap-ins to return. The default is '50', the
             * maximum is '100'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Fields to sort the snap-ins by and the direction to sort them. */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<SnapInsListResponse, any>>;
        /**
         * @description Lists snap-ins for a Dev organization.
         *
         * @tags snap-ins
         * @name SnapInsListPost
         * @request POST:/internal/snap-ins.list
         * @secure
         */
        snapInsListPost: (data: SnapInsListRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInsListResponse, any>>;
        /**
         * @description Updates a SnapIn.
         *
         * @tags snap-ins
         * @name SnapInsUpdate
         * @request POST:/internal/snap-ins.update
         * @secure
         */
        snapInsUpdate: (data: SnapInsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<SnapInsUpdateResponse, any>>;
        /**
         * @description Executes snap kit actions.
         *
         * @name ExecuteSnapKitAction
         * @request POST:/internal/snap-kit-action.execute
         * @secure
         */
        executeSnapKitAction: (data: ExecuteSnapKitActionRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: harpinder.singh@devrev.ai ### Lists snaps for a Dev organization.
         *
         * @tags flows, snap-ins
         * @name SnapsList
         * @request GET:/internal/snaps.list
         * @secure
         */
        snapsList: (params?: RequestParams) => Promise<AxiosResponse<SnapsListResponse, any>>;
        /**
         * @description Lists snaps for a Dev organization.
         *
         * @tags flows, snap-ins
         * @name SnapsListPost
         * @request POST:/internal/snaps.list
         * @secure
         */
        snapsListPost: (data: SnapsListRequest, params?: RequestParams) => Promise<AxiosResponse<SnapsListResponse, any>>;
        /**
         * @description Connects to an open socket.
         *
         * @tags sockets
         * @name SocketsConnect
         * @request POST:/internal/sockets.connect
         * @secure
         */
        socketsConnect: (data: SocketsConnectRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Opens a new socket.
         *
         * @tags sockets
         * @name SocketsOpen
         * @request POST:/internal/sockets.open
         * @secure
         */
        socketsOpen: (data: SocketsOpenRequest, params?: RequestParams) => Promise<AxiosResponse<SocketsOpenResponse, any>>;
        /**
         * @description Gets the requested user's information.
         *
         * @tags sys-users
         * @name SysUsersGet
         * @request GET:/internal/sys-users.get
         * @secure
         */
        sysUsersGet: (query?: {
            /** User ID of the requested system user. */
            id?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SysUsersGetResponse, any>>;
        /**
         * @description Gets the requested user's information.
         *
         * @tags sys-users
         * @name SysUsersGetPost
         * @request POST:/internal/sys-users.get
         * @secure
         */
        sysUsersGetPost: (data: SysUsersGetRequest, params?: RequestParams) => Promise<AxiosResponse<SysUsersGetResponse, any>>;
        /**
         * @description Gets the list of system users in the user's Dev organization.
         *
         * @tags sys-users
         * @name SysUsersList
         * @request GET:/internal/sys-users.list
         * @secure
         */
        sysUsersList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The number of system users to be retrieved.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Fields to sort the system users by and the direction to sort them. */
            sort_by?: string[];
        }, params?: RequestParams) => Promise<AxiosResponse<SysUsersListResponse, any>>;
        /**
         * @description Gets the list of system users in the user's Dev organization.
         *
         * @tags sys-users
         * @name SysUsersListPost
         * @request POST:/internal/sys-users.list
         * @secure
         */
        sysUsersListPost: (data: SysUsersListRequest, params?: RequestParams) => Promise<AxiosResponse<SysUsersListResponse, any>>;
        /**
         * @description Updates the Sys user.
         *
         * @tags sys-users
         * @name SysUsersUpdate
         * @request POST:/internal/sys-users.update
         * @secure
         */
        sysUsersUpdate: (data: SysUsersUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<SysUsersUpdateResponse, any>>;
        /**
         * @description Creates a new tag, which is used to create associations between objects and a logical concept denoted by the tag's name.
         *
         * @tags tags
         * @name TagsCreate
         * @request POST:/internal/tags.create
         * @secure
         */
        tagsCreate: (data: TagsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<TagsCreateResponse, any>>;
        /**
         * @description Deletes a tag.
         *
         * @tags tags
         * @name TagsDelete
         * @request POST:/internal/tags.delete
         * @secure
         */
        tagsDelete: (data: TagsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets a tag's information.
         *
         * @tags tags
         * @name TagsGet
         * @request GET:/internal/tags.get
         * @secure
         */
        tagsGet: (query: {
            /**
             * The requested tag's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<TagsGetResponse, any>>;
        /**
         * @description Gets a tag's information.
         *
         * @tags tags
         * @name TagsGetPost
         * @request POST:/internal/tags.get
         * @secure
         */
        tagsGetPost: (data: TagsGetRequest, params?: RequestParams) => Promise<AxiosResponse<TagsGetResponse, any>>;
        /**
         * @description Lists the available tags.
         *
         * @tags tags
         * @name TagsList
         * @request GET:/internal/tags.list
         * @secure
         */
        tagsList: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of tags to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
        }, params?: RequestParams) => Promise<AxiosResponse<TagsListResponse, any>>;
        /**
         * @description Lists the available tags.
         *
         * @tags tags
         * @name TagsListPost
         * @request POST:/internal/tags.list
         * @secure
         */
        tagsListPost: (data: TagsListRequest, params?: RequestParams) => Promise<AxiosResponse<TagsListResponse, any>>;
        /**
         * @description Updates a tag's information.
         *
         * @tags tags
         * @name TagsUpdate
         * @request POST:/internal/tags.update
         * @secure
         */
        tagsUpdate: (data: TagsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<TagsUpdateResponse, any>>;
        /**
         * @description Creates a new entry on an object's timeline.
         *
         * @tags timeline-entries
         * @name TimelineEntriesCreate
         * @request POST:/internal/timeline-entries.create
         * @secure
         */
        timelineEntriesCreate: (data: TimelineEntriesCreateRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesCreateResponse, any>>;
        /**
         * @description Deletes an entry from an object's timeline.
         *
         * @tags timeline-entries
         * @name TimelineEntriesDelete
         * @request POST:/internal/timeline-entries.delete
         * @secure
         */
        timelineEntriesDelete: (data: TimelineEntriesDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets an entry on an object's timeline.
         *
         * @tags timeline-entries
         * @name TimelineEntriesGet
         * @request GET:/internal/timeline-entries.get
         * @secure
         */
        timelineEntriesGet: (query: {
            /** The ID of the timeline entry to get. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesGetResponse, any>>;
        /**
         * @description Gets an entry on an object's timeline.
         *
         * @tags timeline-entries
         * @name TimelineEntriesGetPost
         * @request POST:/internal/timeline-entries.get
         * @secure
         */
        timelineEntriesGetPost: (data: TimelineEntriesGetRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesGetResponse, any>>;
        /**
         * @description Lists the timeline entries for an object.
         *
         * @tags timeline-entries
         * @name TimelineEntriesList
         * @request GET:/internal/timeline-entries.list
         * @secure
         */
        timelineEntriesList: (query?: {
            /**
             * The collection(s) to list entries from, otherwise if not provided,
             * all entries are returned.
             */
            collections?: TimelineEntriesCollection[];
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The entry to begin iteration from. Note the entry will *not* be
             * included in the result (exclusive). If provided, then no cursor
             * should be set.
             */
            entry?: string;
            /**
             * The ID of the object to list timeline entries for.
             * @deprecated
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id?: string;
            /**
             * The maximum number of entries to return. If not set, then this
             * defaults to `50`.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * The ID of the object to list timeline entries for.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            object?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesListResponse, any>>;
        /**
         * @description Lists the timeline entries for an object.
         *
         * @tags timeline-entries
         * @name TimelineEntriesListPost
         * @request POST:/internal/timeline-entries.list
         * @secure
         */
        timelineEntriesListPost: (data: TimelineEntriesListRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesListResponse, any>>;
        /**
         * @description Updates an entry on an object's timeline.
         *
         * @tags timeline-entries
         * @name TimelineEntriesUpdate
         * @request POST:/internal/timeline-entries.update
         * @secure
         */
        timelineEntriesUpdate: (data: TimelineEntriesUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesUpdateResponse, any>>;
        /**
         * @description Creates a comment on an object.
         *
         * @tags timeline-entries
         * @name TimelineCommentsCreate
         * @request POST:/internal/timeline.comments.create
         * @secure
         */
        timelineCommentsCreate: (data: TimelineCommentsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineCommentsCreateResponse, any>>;
        /**
         * @description Gets an entry on an object's timeline.
         *
         * @tags timeline-entries
         * @name OldTimelineEntriesGet
         * @request GET:/internal/timeline.entries.get
         * @secure
         */
        oldTimelineEntriesGet: (query: {
            /** The ID of the timeline entry to get. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesGetResponse, any>>;
        /**
         * @description Gets an entry on an object's timeline.
         *
         * @tags timeline-entries
         * @name OldTimelineEntriesGetPost
         * @request POST:/internal/timeline.entries.get
         * @secure
         */
        oldTimelineEntriesGetPost: (data: TimelineEntriesGetRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesGetResponse, any>>;
        /**
         * @description Lists the timeline entries for an object.
         *
         * @tags timeline-entries
         * @name OldTimelineEntriesList
         * @request GET:/internal/timeline.entries.list
         * @secure
         */
        oldTimelineEntriesList: (query?: {
            /**
             * The collection(s) to list entries from, otherwise if not provided,
             * all entries are returned.
             */
            collections?: TimelineEntriesCollection[];
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The entry to begin iteration from. Note the entry will *not* be
             * included in the result (exclusive). If provided, then no cursor
             * should be set.
             */
            entry?: string;
            /**
             * The ID of the object to list timeline entries for.
             * @deprecated
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            id?: string;
            /**
             * The maximum number of entries to return. If not set, then this
             * defaults to `50`.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * The ID of the object to list timeline entries for.
             * @example "don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"
             */
            object?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesListResponse, any>>;
        /**
         * @description Lists the timeline entries for an object.
         *
         * @tags timeline-entries
         * @name OldTimelineEntriesListPost
         * @request POST:/internal/timeline.entries.list
         * @secure
         */
        oldTimelineEntriesListPost: (data: TimelineEntriesListRequest, params?: RequestParams) => Promise<AxiosResponse<TimelineEntriesListResponse, any>>;
        /**
         * @description Translates input text to specified target language.
         *
         * @tags translation
         * @name Translate
         * @request POST:/internal/translate
         * @secure
         */
        translate: (data: TranslateRequest, params?: RequestParams) => Promise<AxiosResponse<TranslateResponse, any>>;
        /**
         * @description Returns the supported languages for translation.
         *
         * @tags translation
         * @name TranslationLanguagesList
         * @request GET:/internal/translation.languages.list
         * @secure
         */
        translationLanguagesList: (query?: {
            /**
             * The language to use to return localized, human readable names of
             * supported languages.
             */
            target_language?: string;
        }, params?: RequestParams) => Promise<AxiosResponse<SupportedLanguagesResponse, any>>;
        /**
         * @description Returns the supported languages for translation.
         *
         * @tags translation
         * @name TranslationLanguagesListPost
         * @request POST:/internal/translation.languages.list
         * @secure
         */
        translationLanguagesListPost: (data: SupportedLanguagesRequest, params?: RequestParams) => Promise<AxiosResponse<SupportedLanguagesResponse, any>>;
        /**
         * @description Translates input text to specified target language.
         *
         * @tags translation
         * @name TranslationTranslate
         * @request POST:/internal/translation.translate
         * @secure
         */
        translationTranslate: (data: TranslateRequest, params?: RequestParams) => Promise<AxiosResponse<TranslateResponse, any>>;
        /**
         * @description Creates a UOM on a part.
         *
         * @tags commerce
         * @name UomsCreate
         * @request POST:/internal/uoms.create
         * @secure
         */
        uomsCreate: (data: UomsCreateRequest, params?: RequestParams) => Promise<AxiosResponse<UomsCreateResponse, any>>;
        /**
         * @description Deletes a UOM.
         *
         * @tags commerce
         * @name UomsDelete
         * @request POST:/internal/uoms.delete
         * @secure
         */
        uomsDelete: (data: UomsDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<void, any>>;
        /**
         * @description Gets a UOM.
         *
         * @tags commerce
         * @name UomsGet
         * @request GET:/internal/uoms.get
         * @secure
         */
        uomsGet: (query: {
            /** The UOM's DON. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<UomsGetResponse, any>>;
        /**
         * @description Gets a UOM.
         *
         * @tags commerce
         * @name UomsGetPost
         * @request POST:/internal/uoms.get
         * @secure
         */
        uomsGetPost: (data: UomsGetRequest, params?: RequestParams) => Promise<AxiosResponse<UomsGetResponse, any>>;
        /**
         * @description Gets the UOMs based on the given filters.
         *
         * @tags commerce
         * @name UomsList
         * @request GET:/internal/uoms.list
         * @secure
         */
        uomsList: (query?: {
            /** The list of aggregation types which are to be aggregated. */
            aggregation_types?: UomAggregationType[];
            /** The list of UOM DONs which are to be aggregated. */
            ids?: string[];
            /** The list of meter names which are to be aggregated. */
            meter_names?: string[];
            /**
             * The list of part DONs which are to be aggregated.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            part_ids?: string[];
            /**
             * The list of product DONs which are to be aggregated.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            product_ids?: string[];
            /**
             * List of fields to sort the UOMs, by and how to sort them. Default is
             * to sort by created_date in descending order.
             */
            sort_by?: string[];
            /** The list of unit types which are to be aggregated. */
            unit_types?: UnitType[];
        }, params?: RequestParams) => Promise<AxiosResponse<UomsListResponse, any>>;
        /**
         * @description Gets the UOMs based on the given filters.
         *
         * @tags commerce
         * @name UomsListPost
         * @request POST:/internal/uoms.list
         * @secure
         */
        uomsListPost: (data: UomsListRequest, params?: RequestParams) => Promise<AxiosResponse<UomsListResponse, any>>;
        /**
         * @description Updates a UOM.
         *
         * @tags commerce
         * @name UomsUpdate
         * @request POST:/internal/uoms.update
         * @secure
         */
        uomsUpdate: (data: UomsUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<UomsUpdateResponse, any>>;
        /**
         * @description Returns the user's privileges for the target object.
         *
         * @tags users
         * @name UserPrivileges
         * @request GET:/internal/user.privileges
         * @secure
         */
        userPrivileges: (query?: {
            /** The ID of the target object for which user privileges are requested. */
            'target.id'?: string;
            /**
             * The type of the target object for which user privileges are
             * requested.
             */
            'target.object_type'?: ObjectTypeProto;
        }, params?: RequestParams) => Promise<AxiosResponse<UserPrivilegesResponse, any>>;
        /**
         * @description Returns the user's privileges for the target object.
         *
         * @tags users
         * @name UserPrivilegesPost
         * @request POST:/internal/user.privileges
         * @secure
         */
        userPrivilegesPost: (data: UserPrivilegesRequest, params?: RequestParams) => Promise<AxiosResponse<UserPrivilegesResponse, any>>;
        /**
         * @description Delete the invitation sent to the user.
         *
         * @tags dev-users
         * @name UserInvitationDelete
         * @request POST:/internal/users.invitations.delete
         * @secure
         */
        userInvitationDelete: (data: UserInvitationDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the list of Dev organizations that the Dev user is invited to.
         *
         * @tags dev-orgs
         * @name DevUserInvitationsList
         * @request GET:/internal/users.invitations.list
         * @secure
         */
        devUserInvitationsList: (params?: RequestParams) => Promise<AxiosResponse<ListDevUserInvitationsResponse, any>>;
        /**
         * @description Gets the list of Dev organizations that the Dev user is invited to.
         *
         * @tags dev-orgs
         * @name DevUserInvitationsListPost
         * @request POST:/internal/users.invitations.list
         * @secure
         */
        devUserInvitationsListPost: (data: ListDevUserInvitationsRequest, params?: RequestParams) => Promise<AxiosResponse<ListDevUserInvitationsResponse, any>>;
        /**
         * @description Creates a vista.
         *
         * @tags vistas
         * @name VistasCreate
         * @request POST:/internal/vistas.create
         * @secure
         */
        vistasCreate: (data: VistasCreateRequest, params?: RequestParams) => Promise<AxiosResponse<VistasCreateResponse, any>>;
        /**
         * @description Deletes the requested vista.
         *
         * @tags vistas
         * @name VistasDelete
         * @request POST:/internal/vistas.delete
         * @secure
         */
        vistasDelete: (data: VistasDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Gets the requested vistas's information.
         *
         * @tags vistas
         * @name VistasGet
         * @request GET:/internal/vistas.get
         * @secure
         */
        vistasGet: (query: {
            /** The vista's ID. */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<VistasGetResponse, any>>;
        /**
         * @description Gets the requested vistas's information.
         *
         * @tags vistas
         * @name VistasGetPost
         * @request POST:/internal/vistas.get
         * @secure
         */
        vistasGetPost: (data: VistasGetRequest, params?: RequestParams) => Promise<AxiosResponse<VistasGetResponse, any>>;
        /**
         * @description Lists the available vistas.
         *
         * @tags vistas
         * @name VistasList
         * @request GET:/internal/vistas.list
         * @secure
         */
        vistasList: (query?: {
            /**
             * Filters for vistas created by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by?: string[];
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /** Whether the default vistas should be fetched or not. */
            is_default?: boolean;
            /**
             * The maximum number of vistas to return. The default is '50', the
             * maximum is '100'.
             * @format int32
             */
            limit?: number;
            /**
             * Filters for vistas accessible to the input members.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            members?: string[];
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Filters for vistas of specific object types like works, parts etc. */
            object_type?: DynamicVistaFilterType[];
            /** Fields to sort the vistas by and the direction to sort them. */
            sort_by?: string[];
            /** Filters for vistas of the specific type. */
            type?: VistaType[];
        }, params?: RequestParams) => Promise<AxiosResponse<VistasListResponse, any>>;
        /**
         * @description Lists the available vistas.
         *
         * @tags vistas
         * @name VistasListPost
         * @request POST:/internal/vistas.list
         * @secure
         */
        vistasListPost: (data: VistasListRequest, params?: RequestParams) => Promise<AxiosResponse<VistasListResponse, any>>;
        /**
         * @description Updates the requested vista.
         *
         * @tags vistas
         * @name VistasUpdate
         * @request POST:/internal/vistas.update
         * @secure
         */
        vistasUpdate: (data: VistasUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<VistasUpdateResponse, any>>;
        /**
         * @description Gets requesting user watcher events for an object.
         *
         * @tags watchers
         * @name WatchersGet
         * @request GET:/internal/watchers.get
         * @secure
         */
        watchersGet: (query: {
            /**
             * The object's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<WatchersGetResponse, any>>;
        /**
         * @description Gets requesting user watcher events for an object.
         *
         * @tags watchers
         * @name WatchersGetPost
         * @request POST:/internal/watchers.get
         * @secure
         */
        watchersGetPost: (data: WatchersGetRequest, params?: RequestParams) => Promise<AxiosResponse<WatchersGetResponse, any>>;
        /**
         * @description Lists watchers of an object.
         *
         * @tags watchers
         * @name WatchersList
         * @request GET:/internal/watchers.list
         * @secure
         */
        watchersList: (query: {
            /**
             * The object's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
             */
            id: string;
            /**
             * The cursor to resume iteration from, otherwise if not provided, then
             * iteration starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of watchers to return. If not set or `<= 0`, then
             * this defaults to `50`.
             * @format int32
             */
            limit?: number;
        }, params?: RequestParams) => Promise<AxiosResponse<WatchersListResponse, any>>;
        /**
         * @description Lists watchers of an object.
         *
         * @tags watchers
         * @name WatchersListPost
         * @request POST:/internal/watchers.list
         * @secure
         */
        watchersListPost: (data: WatchersListRequest, params?: RequestParams) => Promise<AxiosResponse<WatchersListResponse, any>>;
        /**
         * @description Updates watchers on the object.
         *
         * @tags watchers
         * @name WatchersUpdate
         * @request POST:/internal/watchers.update
         * @secure
         */
        watchersUpdate: (data: WatchersUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description Creates a new webhook target.
         *
         * @tags webhooks
         * @name WebhooksCreate
         * @request POST:/internal/webhooks.create
         * @secure
         */
        webhooksCreate: (data: WebhooksCreateRequest, params?: RequestParams) => Promise<AxiosResponse<WebhooksCreateResponse, any>>;
        /**
         * @description Deletes the requested webhook.
         *
         * @tags webhooks
         * @name WebhooksDelete
         * @request POST:/internal/webhooks.delete
         * @secure
         */
        webhooksDelete: (data: WebhooksDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: brian.byrne@devrev.ai ### Gets the requested webhook's information.
         *
         * @tags webhooks
         * @name WebhooksGet
         * @request GET:/internal/webhooks.get
         * @secure
         */
        webhooksGet: (query: {
            /**
             * ID for the webhook.
             * @example "don:<partition>:integration:devo/<dev-org-id>:webhook/<webhook-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<WebhooksGetResponse, any>>;
        /**
         * @description Gets the requested webhook's information.
         *
         * @tags webhooks
         * @name WebhooksGetPost
         * @request POST:/internal/webhooks.get
         * @secure
         */
        webhooksGetPost: (data: WebhooksGetRequest, params?: RequestParams) => Promise<AxiosResponse<WebhooksGetResponse, any>>;
        /**
         * @description ### Owner: brian.byrne@devrev.ai ### Lists the webhooks.
         *
         * @tags webhooks
         * @name WebhooksList
         * @request GET:/internal/webhooks.list
         * @secure
         */
        webhooksList: (params?: RequestParams) => Promise<AxiosResponse<WebhooksListResponse, any>>;
        /**
         * @description Lists the webhooks.
         *
         * @tags webhooks
         * @name WebhooksListPost
         * @request POST:/internal/webhooks.list
         * @secure
         */
        webhooksListPost: (data: WebhooksListRequest, params?: RequestParams) => Promise<AxiosResponse<WebhooksListResponse, any>>;
        /**
         * @description Updates the requested webhook.
         *
         * @tags webhooks
         * @name WebhooksUpdate
         * @request POST:/internal/webhooks.update
         * @secure
         */
        webhooksUpdate: (data: WebhooksUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<WebhooksUpdateResponse, any>>;
        /**
         * @description ### Owner: anshu.avinash@devrev.ai ### Get count of work matching given filter.
         *
         * @tags works
         * @name WorksCount
         * @request GET:/internal/works.count
         * @secure
         */
        worksCount: (query?: {
            /**
             * Filters for work actual_close after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_after_date?: string;
            /**
             * Filters for work actual_close before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_before_date?: string;
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part?: string[];
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part_ids?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part_ids?: string[];
            /**
             * Filters for work created after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_after_date?: string;
            /**
             * Filters for work created before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_before_date?: string;
            /**
             * Filters for work created by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by?: string[];
            /**
             * Filters for work created by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by_ids?: string[];
            /** The filter operator to be applied on created_by. */
            created_by_op?: WorksFilterCreatedByOperatorType;
            /**
             * Filters for work excluding the provided work IDs.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude?: string[];
            /**
             * Filters for work excluding the provided work IDs.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude_work_ids?: string[];
            /**
             * Filters for issues with any of the provided priorities.
             * @deprecated
             */
            'issue.priorities'?: IssuePriority[];
            /** Filters for issues with any of the provided priorities. */
            'issue.priority'?: IssuePriority[];
            /** Filters for issue with any of the provided subtype. */
            'issue.subtype'?: string[];
            /**
             * Filters for work modified after the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_after_date?: string;
            /**
             * Filters for work modified before the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_before_date?: string;
            /**
             * Filters for work owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for work owned by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** The filter operator to be applied on owned_by. */
            owned_by_op?: WorksFilterOwnedByOperatorType;
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for work for the provided stage names. */
            stage_names?: string[];
            /** Filters for work with any of the provided states. */
            state?: string[];
            /**
             * Filters for work with any of the provided tags.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** The filter operator to be applied. */
            tag_ids_op?: WorksFilterTagIdsOperatorType;
            /**
             * Filters for work with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
            /**
             * Filters for work whose target close date is after the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_after_date?: string;
            /**
             * Filters for work whose target close date is before the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_before_date?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'target_close_date.before'?: string;
            /** Filter for tasks with any of the provided embedded values. */
            'task.embedded'?: boolean[];
            /**
             * Filters for tasks with any of the provided priorities.
             * @deprecated
             */
            'task.priorities'?: TaskPriority[];
            /** Filters for tasks with any of the provided priorities. */
            'task.priority'?: TaskPriority[];
            /**
             * Filters for tasks which started after the provided timestamp.
             * @format date-time
             */
            'task.start_after_date'?: string;
            /**
             * Filters for tasks which started before the provided timestamp.
             * @format date-time
             */
            'task.start_before_date'?: string;
            /**
             * Filters for tickets that are associated with any of the provided Rev
             * organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org'?: string[];
            /**
             * Filters for tickets associated to the provided Rev organizations
             * using an operator.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org_ids'?: string[];
            /** The filter operator to be applied. */
            'ticket.rev_org_ids_op'?: WorksFilterTicketRevOrgIDsOperatorType;
            /**
             * Filters for tickets with any of the provided severities.
             * @deprecated
             */
            'ticket.severities'?: TicketSeverity[];
            /** Filters for tickets with any of the provided severities. */
            'ticket.severity'?: TicketSeverity[];
            /** Filters for ticket with any of the provided subtype. */
            'ticket.subtype'?: string[];
            /** Filters for work of the provided types. */
            type?: WorkType[];
            /**
             * Filters for work of the provided types.
             * @deprecated
             */
            types?: WorkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<WorksCountResponse, any>>;
        /**
         * @description Get count of work matching given filter.
         *
         * @tags works
         * @name WorksCountPost
         * @request POST:/internal/works.count
         * @secure
         */
        worksCountPost: (data: WorksCountRequest, params?: RequestParams) => Promise<AxiosResponse<WorksCountResponse, any>>;
        /**
         * @description Creates new work ([issue](https://devrev.ai/docs/product/build), [ticket](https://devrev.ai/docs/product/support)) item.
         *
         * @tags works
         * @name WorksCreate
         * @request POST:/internal/works.create
         * @secure
         */
        worksCreate: (data: WorksCreateRequest, params?: RequestParams) => Promise<AxiosResponse<WorksCreateResponse, any>>;
        /**
         * @description Deletes a work item.
         *
         * @tags works
         * @name WorksDelete
         * @request POST:/internal/works.delete
         * @secure
         */
        worksDelete: (data: WorksDeleteRequest, params?: RequestParams) => Promise<AxiosResponse<object, any>>;
        /**
         * @description ### Owner: anshu.avinash@devrev.ai ### Exports a collection of work items.
         *
         * @tags works
         * @name WorksExport
         * @request GET:/internal/works.export
         * @secure
         */
        worksExport: (query?: {
            /**
             * Filters for work actual_close after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_after_date?: string;
            /**
             * Filters for work actual_close before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_before_date?: string;
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part?: string[];
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part_ids?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part_ids?: string[];
            /**
             * Filters for work created after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_after_date?: string;
            /**
             * Filters for work created before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_before_date?: string;
            /**
             * Filters for work created by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by?: string[];
            /**
             * Filters for work created by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by_ids?: string[];
            /** The filter operator to be applied on created_by. */
            created_by_op?: WorksFilterCreatedByOperatorType;
            /**
             * Filters for work excluding the provided work IDs.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude?: string[];
            /**
             * Filters for work excluding the provided work IDs.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude_work_ids?: string[];
            /**
             * The number of work items to return. The default is '50', the maximum
             * is '5000'.
             * @format int32
             */
            first?: number;
            /**
             * Filters for issues with any of the provided priorities.
             * @deprecated
             */
            'issue.priorities'?: IssuePriority[];
            /** Filters for issues with any of the provided priorities. */
            'issue.priority'?: IssuePriority[];
            /** Filters for issue with any of the provided subtype. */
            'issue.subtype'?: string[];
            /**
             * Filters for work modified after the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_after_date?: string;
            /**
             * Filters for work modified before the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_before_date?: string;
            /**
             * Filters for work owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for work owned by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** The filter operator to be applied on owned_by. */
            owned_by_op?: WorksFilterOwnedByOperatorType;
            /** Fields to sort the work items by and the direction to sort them. */
            sort_by?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for work for the provided stage names. */
            stage_names?: string[];
            /** Filters for work with any of the provided states. */
            state?: string[];
            /**
             * Filters for work with any of the provided tags.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** The filter operator to be applied. */
            tag_ids_op?: WorksFilterTagIdsOperatorType;
            /**
             * Filters for work with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
            /**
             * Filters for work whose target close date is after the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_after_date?: string;
            /**
             * Filters for work whose target close date is before the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_before_date?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'target_close_date.before'?: string;
            /** Filter for tasks with any of the provided embedded values. */
            'task.embedded'?: boolean[];
            /**
             * Filters for tasks with any of the provided priorities.
             * @deprecated
             */
            'task.priorities'?: TaskPriority[];
            /** Filters for tasks with any of the provided priorities. */
            'task.priority'?: TaskPriority[];
            /**
             * Filters for tasks which started after the provided timestamp.
             * @format date-time
             */
            'task.start_after_date'?: string;
            /**
             * Filters for tasks which started before the provided timestamp.
             * @format date-time
             */
            'task.start_before_date'?: string;
            /**
             * Filters for tickets that are associated with any of the provided Rev
             * organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org'?: string[];
            /**
             * Filters for tickets associated to the provided Rev organizations
             * using an operator.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org_ids'?: string[];
            /** The filter operator to be applied. */
            'ticket.rev_org_ids_op'?: WorksFilterTicketRevOrgIDsOperatorType;
            /**
             * Filters for tickets with any of the provided severities.
             * @deprecated
             */
            'ticket.severities'?: TicketSeverity[];
            /** Filters for tickets with any of the provided severities. */
            'ticket.severity'?: TicketSeverity[];
            /** Filters for ticket with any of the provided subtype. */
            'ticket.subtype'?: string[];
            /** Filters for work of the provided types. */
            type?: WorkType[];
            /**
             * Filters for work of the provided types.
             * @deprecated
             */
            types?: WorkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<WorksExportResponse, any>>;
        /**
         * @description Exports a collection of work items.
         *
         * @tags works
         * @name WorksExportPost
         * @request POST:/internal/works.export
         * @secure
         */
        worksExportPost: (data: WorksExportRequest, params?: RequestParams) => Promise<AxiosResponse<WorksExportResponse, any>>;
        /**
         * @description ### Owner: anshu.avinash@devrev.ai ### Gets a work item's information.
         *
         * @tags works
         * @name WorksGet
         * @request GET:/internal/works.get
         * @secure
         */
        worksGet: (query: {
            /**
             * The work's ID.
             * @example "don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"
             */
            id: string;
        }, params?: RequestParams) => Promise<AxiosResponse<WorksGetResponse, any>>;
        /**
         * @description Gets a work item's information.
         *
         * @tags works
         * @name WorksGetPost
         * @request POST:/internal/works.get
         * @secure
         */
        worksGetPost: (data: WorksGetRequest, params?: RequestParams) => Promise<AxiosResponse<WorksGetResponse, any>>;
        /**
         * @description ### Owner: anshu.avinash@devrev.ai ### Lists collections of works by groups.
         *
         * @tags works
         * @name WorksGroup
         * @request GET:/internal/works.group
         * @secure
         */
        worksGroup: (query: {
            /** The field to group the works by. */
            group_by: string;
            /**
             * Filters for work actual_close after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_after_date?: string;
            /**
             * Filters for work actual_close before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_before_date?: string;
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part?: string[];
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part_ids?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part_ids?: string[];
            /**
             * Filters for work created after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_after_date?: string;
            /**
             * Filters for work created before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_before_date?: string;
            /**
             * Filters for work created by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by?: string[];
            /**
             * Filters for work created by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by_ids?: string[];
            /** The filter operator to be applied on created_by. */
            created_by_op?: WorksFilterCreatedByOperatorType;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters for work excluding the provided work IDs.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude?: string[];
            /**
             * Filters for work excluding the provided work IDs.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude_work_ids?: string[];
            /**
             * Filters for issues with any of the provided priorities.
             * @deprecated
             */
            'issue.priorities'?: IssuePriority[];
            /** Filters for issues with any of the provided priorities. */
            'issue.priority'?: IssuePriority[];
            /** Filters for issue with any of the provided subtype. */
            'issue.subtype'?: string[];
            /**
             * The maximum number of groups to return. If not set, then the default
             * is '10'.
             * @format int32
             */
            limit?: number;
            /**
             * The maximum number of works to return for an individual group. If not
             * set, then the default is '50'.
             * @format int32
             */
            limit_per_group?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for work modified after the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_after_date?: string;
            /**
             * Filters for work modified before the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_before_date?: string;
            /**
             * Filters for work owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for work owned by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** The filter operator to be applied on owned_by. */
            owned_by_op?: WorksFilterOwnedByOperatorType;
            /** Comma-separated fields to sort the works by. */
            sort_by?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for work for the provided stage names. */
            stage_names?: string[];
            /** Filters for work with any of the provided states. */
            state?: string[];
            /**
             * Filters for work with any of the provided tags.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** The filter operator to be applied. */
            tag_ids_op?: WorksFilterTagIdsOperatorType;
            /**
             * Filters for work with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
            /**
             * Filters for work whose target close date is after the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_after_date?: string;
            /**
             * Filters for work whose target close date is before the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_before_date?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'target_close_date.before'?: string;
            /** Filter for tasks with any of the provided embedded values. */
            'task.embedded'?: boolean[];
            /**
             * Filters for tasks with any of the provided priorities.
             * @deprecated
             */
            'task.priorities'?: TaskPriority[];
            /** Filters for tasks with any of the provided priorities. */
            'task.priority'?: TaskPriority[];
            /**
             * Filters for tasks which started after the provided timestamp.
             * @format date-time
             */
            'task.start_after_date'?: string;
            /**
             * Filters for tasks which started before the provided timestamp.
             * @format date-time
             */
            'task.start_before_date'?: string;
            /**
             * Filters for tickets that are associated with any of the provided Rev
             * organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org'?: string[];
            /**
             * Filters for tickets associated to the provided Rev organizations
             * using an operator.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org_ids'?: string[];
            /** The filter operator to be applied. */
            'ticket.rev_org_ids_op'?: WorksFilterTicketRevOrgIDsOperatorType;
            /**
             * Filters for tickets with any of the provided severities.
             * @deprecated
             */
            'ticket.severities'?: TicketSeverity[];
            /** Filters for tickets with any of the provided severities. */
            'ticket.severity'?: TicketSeverity[];
            /** Filters for ticket with any of the provided subtype. */
            'ticket.subtype'?: string[];
            /** Filters for work of the provided types. */
            type?: WorkType[];
            /**
             * Filters for work of the provided types.
             * @deprecated
             */
            types?: WorkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<WorksGroupResponse, any>>;
        /**
         * @description Lists collections of works by groups.
         *
         * @tags works
         * @name WorksGroupPost
         * @request POST:/internal/works.group
         * @secure
         */
        worksGroupPost: (data: WorksGroupRequest, params?: RequestParams) => Promise<AxiosResponse<WorksGroupResponse, any>>;
        /**
         * @description ### Owner: anshu.avinash@devrev.ai ### Lists a collection of work items.
         *
         * @tags works
         * @name WorksList
         * @request GET:/internal/works.list
         * @secure
         */
        worksList: (query?: {
            /**
             * Filters for work actual_close after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_after_date?: string;
            /**
             * Filters for work actual_close before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            actual_close_before_date?: string;
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part?: string[];
            /**
             * Filters for work which have one of the parts present as its ancestor
             * part or primary part.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            ancestor_part_ids?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part?: string[];
            /**
             * Filters for work belonging to any of the provided parts.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<part-type>/<part-id>"]
             */
            applies_to_part_ids?: string[];
            /**
             * Filters for work created after the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_after_date?: string;
            /**
             * Filters for work created before the timestamp provided.
             * @deprecated
             * @format date-time
             */
            created_before_date?: string;
            /**
             * Filters for work created by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by?: string[];
            /**
             * Filters for work created by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            created_by_ids?: string[];
            /** The filter operator to be applied on created_by. */
            created_by_op?: WorksFilterCreatedByOperatorType;
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * Filters for work excluding the provided work IDs.
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude?: string[];
            /**
             * Filters for work excluding the provided work IDs.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:<work-type>/<work-id>"]
             */
            exclude_work_ids?: string[];
            /**
             * Filters for issues with any of the provided priorities.
             * @deprecated
             */
            'issue.priorities'?: IssuePriority[];
            /** Filters for issues with any of the provided priorities. */
            'issue.priority'?: IssuePriority[];
            /** Filters for issue with any of the provided subtype. */
            'issue.subtype'?: string[];
            /**
             * The maximum number of works to return. The default is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /**
             * Filters for work modified after the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_after_date?: string;
            /**
             * Filters for work modified before the provided timestamp.
             * @deprecated
             * @format date-time
             */
            modified_before_date?: string;
            /**
             * Filters for work owned by any of these users.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by?: string[];
            /**
             * Filters for work owned by any of these users.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:devu/<dev-user-id>"]
             */
            owned_by_ids?: string[];
            /** The filter operator to be applied on owned_by. */
            owned_by_op?: WorksFilterOwnedByOperatorType;
            /** Fields to sort the works by and the direction to sort them. */
            sort_by?: string[];
            /** Filters for records in the provided stage(s). */
            'stage.name'?: string[];
            /** Filters for work for the provided stage names. */
            stage_names?: string[];
            /** Filters for work with any of the provided states. */
            state?: string[];
            /**
             * Filters for work with any of the provided tags.
             * @deprecated
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tag_ids?: string[];
            /** The filter operator to be applied. */
            tag_ids_op?: WorksFilterTagIdsOperatorType;
            /**
             * Filters for work with any of the provided tags.
             * @example ["don:<partition>:core:devo/<dev-org-id>:tag/<tag-id>"]
             */
            tags?: string[];
            /**
             * Filters for work whose target close date is after the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_after_date?: string;
            /**
             * Filters for work whose target close date is before the provided
             * timestamp.
             * @deprecated
             * @format date-time
             */
            target_close_before_date?: string;
            /**
             * Filters for objects created after the provided timestamp (inclusive).
             * @format date-time
             */
            'target_close_date.after'?: string;
            /**
             * Filters for objects created before the provided timestamp
             * (inclusive).
             * @format date-time
             */
            'target_close_date.before'?: string;
            /** Filter for tasks with any of the provided embedded values. */
            'task.embedded'?: boolean[];
            /**
             * Filters for tasks with any of the provided priorities.
             * @deprecated
             */
            'task.priorities'?: TaskPriority[];
            /** Filters for tasks with any of the provided priorities. */
            'task.priority'?: TaskPriority[];
            /**
             * Filters for tasks which started after the provided timestamp.
             * @format date-time
             */
            'task.start_after_date'?: string;
            /**
             * Filters for tasks which started before the provided timestamp.
             * @format date-time
             */
            'task.start_before_date'?: string;
            /**
             * Filters for tickets that are associated with any of the provided Rev
             * organizations.
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org'?: string[];
            /**
             * Filters for tickets associated to the provided Rev organizations
             * using an operator.
             * @deprecated
             * @example ["don:<partition>:identity:devo/<dev-org-id>:revo/<rev-org-id>"]
             */
            'ticket.rev_org_ids'?: string[];
            /** The filter operator to be applied. */
            'ticket.rev_org_ids_op'?: WorksFilterTicketRevOrgIDsOperatorType;
            /**
             * Filters for tickets with any of the provided severities.
             * @deprecated
             */
            'ticket.severities'?: TicketSeverity[];
            /** Filters for tickets with any of the provided severities. */
            'ticket.severity'?: TicketSeverity[];
            /** Filters for ticket with any of the provided subtype. */
            'ticket.subtype'?: string[];
            /** Filters for work of the provided types. */
            type?: WorkType[];
            /**
             * Filters for work of the provided types.
             * @deprecated
             */
            types?: WorkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<WorksListResponse, any>>;
        /**
         * @description Lists a collection of work items.
         *
         * @tags works
         * @name WorksListPost
         * @request POST:/internal/works.list
         * @secure
         */
        worksListPost: (data: WorksListRequest, params?: RequestParams) => Promise<AxiosResponse<WorksListResponse, any>>;
        /**
         * @description ### Owner: anshu.avinash@devrev.ai ### Lists suggested works.
         *
         * @tags works
         * @name WorksSuggest
         * @request GET:/internal/works.suggest
         * @secure
         */
        worksSuggest: (query?: {
            /**
             * The cursor to resume iteration from. If not provided, then iteration
             * starts from the beginning.
             */
            cursor?: string;
            /**
             * The maximum number of works to return. If not set, then the default
             * is '50'.
             * @format int32
             */
            limit?: number;
            /**
             * The iteration mode to use, otherwise if not set, then "after" is
             * used.
             */
            mode?: ListMode;
            /** Filters for work of the provided types. */
            type?: WorkType[];
            /**
             * Filters for work of the provided types.
             * @deprecated
             */
            types?: WorkType[];
        }, params?: RequestParams) => Promise<AxiosResponse<WorksSuggestResponse, any>>;
        /**
         * @description Lists suggested works.
         *
         * @tags works
         * @name WorksSuggestPost
         * @request POST:/internal/works.suggest
         * @secure
         */
        worksSuggestPost: (data: WorksSuggestRequest, params?: RequestParams) => Promise<AxiosResponse<WorksSuggestResponse, any>>;
        /**
         * @description Updates a work item's information.
         *
         * @tags works
         * @name WorksUpdate
         * @request POST:/internal/works.update
         * @secure
         */
        worksUpdate: (data: WorksUpdateRequest, params?: RequestParams) => Promise<AxiosResponse<WorksUpdateResponse, any>>;
    };
}
