// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v4.25.2
// source: schema.proto

/* eslint-disable */
import * as _m0 from 'protobufjs/minimal';
import { Struct, Value } from './struct.pb';

export const protobufPackage = 'devrev.operation';

export interface Error {
  message: string;
  type: Error_Type;
}

export enum Error_Type {
  Unknown = 0,
  /** InvalidRequest - Invalid request. */
  InvalidRequest = 1,
  /** RetryExecution - Client should retry operation execution. */
  RetryExecution = 2,
  UNRECOGNIZED = -1,
}

export function error_TypeFromJSON(object: any): Error_Type {
  switch (object) {
    case 0:
    case 'Unknown':
      return Error_Type.Unknown;
    case 1:
    case 'InvalidRequest':
      return Error_Type.InvalidRequest;
    case 2:
    case 'RetryExecution':
      return Error_Type.RetryExecution;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return Error_Type.UNRECOGNIZED;
  }
}

export function error_TypeToJSON(object: Error_Type): string {
  switch (object) {
    case Error_Type.Unknown:
      return 'Unknown';
    case Error_Type.InvalidRequest:
      return 'InvalidRequest';
    case Error_Type.RetryExecution:
      return 'RetryExecution';
    case Error_Type.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface OperationMetadata {
  namespace: string;
  slug: string;
  type: OperationMetadata_Type;
}

export enum OperationMetadata_Type {
  Unknown = 0,
  Action = 1,
  UNRECOGNIZED = -1,
}

export function operationMetadata_TypeFromJSON(
  object: any
): OperationMetadata_Type {
  switch (object) {
    case 0:
    case 'Unknown':
      return OperationMetadata_Type.Unknown;
    case 1:
    case 'Action':
      return OperationMetadata_Type.Action;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return OperationMetadata_Type.UNRECOGNIZED;
  }
}

export function operationMetadata_TypeToJSON(
  object: OperationMetadata_Type
): string {
  switch (object) {
    case OperationMetadata_Type.Unknown:
      return 'Unknown';
    case OperationMetadata_Type.Action:
      return 'Action';
    case OperationMetadata_Type.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface ExecuteOperationInput {
  /** Operation metadata. */
  metadata: OperationMetadata | undefined;
  /** Input port name. If not specified then we'll use 'default' input port. */
  input_port_name: string;
  /** Input payload. */
  data: any | undefined;
}

export interface ExecuteOperationResult {
  /** Serialization format used. */
  serialization_format: ExecuteOperationResult_SerializationFormat;
  /** Serialized data (base64 encoded). */
  data: string;
}

export enum ExecuteOperationResult_SerializationFormat {
  Unknown = 0,
  Proto = 1,
  UNRECOGNIZED = -1,
}

export function executeOperationResult_SerializationFormatFromJSON(
  object: any
): ExecuteOperationResult_SerializationFormat {
  switch (object) {
    case 0:
    case 'Unknown':
      return ExecuteOperationResult_SerializationFormat.Unknown;
    case 1:
    case 'Proto':
      return ExecuteOperationResult_SerializationFormat.Proto;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ExecuteOperationResult_SerializationFormat.UNRECOGNIZED;
  }
}

export function executeOperationResult_SerializationFormatToJSON(
  object: ExecuteOperationResult_SerializationFormat
): string {
  switch (object) {
    case ExecuteOperationResult_SerializationFormat.Unknown:
      return 'Unknown';
    case ExecuteOperationResult_SerializationFormat.Proto:
      return 'Proto';
    case ExecuteOperationResult_SerializationFormat.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface OutputValue {
  /**
   * List of values to send to an output port. Each value is a JSON with keys as field names.
   * Null values are dropped.
   */
  values: { [key: string]: any }[];
}

export interface PortOutput {
  /** Name of the port. */
  port_name: string;
  /** Output value. */
  output: OutputValue | undefined;
}

export interface OperationOutput {
  error: Error | undefined;
  /**
   * NOTE: Only one of `output` and `port_outputs` should be set.
   *
   * This sends output to 'default' output port.
   * Most of the operation developers are concerned with sending output
   * on the default port and can thus use this. For more advanced usage
   * use `port_outputs` below.
   */
  output: OutputValue | undefined;
  /** This sends output to specific output ports. There should only be 1 item corresponding to a port_name. */
  port_outputs: PortOutput[];
}

function createBaseError(): Error {
  return { message: '', type: 0 };
}

export const Error = {
  encode(message: Error, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== '') {
      writer.uint32(10).string(message.message);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      type: isSet(object.type) ? error_TypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.type !== 0) {
      obj.type = error_TypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.message = object.message ?? '';
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return { namespace: '', slug: '', type: 0 };
}

export const OperationMetadata = {
  encode(
    message: OperationMetadata,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.namespace !== '') {
      writer.uint32(10).string(message.namespace);
    }
    if (message.slug !== '') {
      writer.uint32(18).string(message.slug);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OperationMetadata {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      namespace: isSet(object.namespace)
        ? globalThis.String(object.namespace)
        : '',
      slug: isSet(object.slug) ? globalThis.String(object.slug) : '',
      type: isSet(object.type)
        ? operationMetadata_TypeFromJSON(object.type)
        : 0,
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.namespace !== '') {
      obj.namespace = message.namespace;
    }
    if (message.slug !== '') {
      obj.slug = message.slug;
    }
    if (message.type !== 0) {
      obj.type = operationMetadata_TypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationMetadata>, I>>(
    base?: I
  ): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationMetadata>, I>>(
    object: I
  ): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.namespace = object.namespace ?? '';
    message.slug = object.slug ?? '';
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseExecuteOperationInput(): ExecuteOperationInput {
  return { metadata: undefined, input_port_name: '', data: undefined };
}

export const ExecuteOperationInput = {
  encode(
    message: ExecuteOperationInput,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.metadata !== undefined) {
      OperationMetadata.encode(
        message.metadata,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.input_port_name !== '') {
      writer.uint32(18).string(message.input_port_name);
    }
    if (message.data !== undefined) {
      Value.encode(Value.wrap(message.data), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ExecuteOperationInput {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteOperationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input_port_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteOperationInput {
    return {
      metadata: isSet(object.metadata)
        ? OperationMetadata.fromJSON(object.metadata)
        : undefined,
      input_port_name: isSet(object.input_port_name)
        ? globalThis.String(object.input_port_name)
        : '',
      data: isSet(object?.data) ? object.data : undefined,
    };
  },

  toJSON(message: ExecuteOperationInput): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = OperationMetadata.toJSON(message.metadata);
    }
    if (message.input_port_name !== '') {
      obj.input_port_name = message.input_port_name;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteOperationInput>, I>>(
    base?: I
  ): ExecuteOperationInput {
    return ExecuteOperationInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteOperationInput>, I>>(
    object: I
  ): ExecuteOperationInput {
    const message = createBaseExecuteOperationInput();
    message.metadata =
      object.metadata !== undefined && object.metadata !== null
        ? OperationMetadata.fromPartial(object.metadata)
        : undefined;
    message.input_port_name = object.input_port_name ?? '';
    message.data = object.data ?? undefined;
    return message;
  },
};

function createBaseExecuteOperationResult(): ExecuteOperationResult {
  return { serialization_format: 0, data: '' };
}

export const ExecuteOperationResult = {
  encode(
    message: ExecuteOperationResult,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.serialization_format !== 0) {
      writer.uint32(8).int32(message.serialization_format);
    }
    if (message.data !== '') {
      writer.uint32(18).string(message.data);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ExecuteOperationResult {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteOperationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serialization_format = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteOperationResult {
    return {
      serialization_format: isSet(object.serialization_format)
        ? executeOperationResult_SerializationFormatFromJSON(
            object.serialization_format
          )
        : 0,
      data: isSet(object.data) ? globalThis.String(object.data) : '',
    };
  },

  toJSON(message: ExecuteOperationResult): unknown {
    const obj: any = {};
    if (message.serialization_format !== 0) {
      obj.serialization_format =
        executeOperationResult_SerializationFormatToJSON(
          message.serialization_format
        );
    }
    if (message.data !== '') {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteOperationResult>, I>>(
    base?: I
  ): ExecuteOperationResult {
    return ExecuteOperationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteOperationResult>, I>>(
    object: I
  ): ExecuteOperationResult {
    const message = createBaseExecuteOperationResult();
    message.serialization_format = object.serialization_format ?? 0;
    message.data = object.data ?? '';
    return message;
  },
};

function createBaseOutputValue(): OutputValue {
  return { values: [] };
}

export const OutputValue = {
  encode(
    message: OutputValue,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.values) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutputValue {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(
            Struct.unwrap(Struct.decode(reader, reader.uint32()))
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputValue {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? [...object.values]
        : [],
    };
  },

  toJSON(message: OutputValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputValue>, I>>(base?: I): OutputValue {
    return OutputValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputValue>, I>>(
    object: I
  ): OutputValue {
    const message = createBaseOutputValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBasePortOutput(): PortOutput {
  return { port_name: '', output: undefined };
}

export const PortOutput = {
  encode(
    message: PortOutput,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.port_name !== '') {
      writer.uint32(10).string(message.port_name);
    }
    if (message.output !== undefined) {
      OutputValue.encode(message.output, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortOutput {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.port_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = OutputValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortOutput {
    return {
      port_name: isSet(object.port_name)
        ? globalThis.String(object.port_name)
        : '',
      output: isSet(object.output)
        ? OutputValue.fromJSON(object.output)
        : undefined,
    };
  },

  toJSON(message: PortOutput): unknown {
    const obj: any = {};
    if (message.port_name !== '') {
      obj.port_name = message.port_name;
    }
    if (message.output !== undefined) {
      obj.output = OutputValue.toJSON(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortOutput>, I>>(base?: I): PortOutput {
    return PortOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortOutput>, I>>(
    object: I
  ): PortOutput {
    const message = createBasePortOutput();
    message.port_name = object.port_name ?? '';
    message.output =
      object.output !== undefined && object.output !== null
        ? OutputValue.fromPartial(object.output)
        : undefined;
    return message;
  },
};

function createBaseOperationOutput(): OperationOutput {
  return { error: undefined, output: undefined, port_outputs: [] };
}

export const OperationOutput = {
  encode(
    message: OperationOutput,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).ldelim();
    }
    if (message.output !== undefined) {
      OutputValue.encode(message.output, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.port_outputs) {
      PortOutput.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OperationOutput {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = OutputValue.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.port_outputs.push(PortOutput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationOutput {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      output: isSet(object.output)
        ? OutputValue.fromJSON(object.output)
        : undefined,
      port_outputs: globalThis.Array.isArray(object?.port_outputs)
        ? object.port_outputs.map((e: any) => PortOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OperationOutput): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.output !== undefined) {
      obj.output = OutputValue.toJSON(message.output);
    }
    if (message.port_outputs?.length) {
      obj.port_outputs = message.port_outputs.map((e) => PortOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationOutput>, I>>(
    base?: I
  ): OperationOutput {
    return OperationOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationOutput>, I>>(
    object: I
  ): OperationOutput {
    const message = createBaseOperationOutput();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.output =
      object.output !== undefined && object.output !== null
        ? OutputValue.fromPartial(object.output)
        : undefined;
    message.port_outputs =
      object.port_outputs?.map((e) => PortOutput.fromPartial(e)) || [];
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
